# Combined C++ Sources

## AnimationBonesConstraintsSample.cpp

```cpp
#include "AnimationBonesConstraintsSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(AnimationBonesConstraintsSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesConstraintsSample::init()
{
#ifndef DEBUG
	if (Engine::get()->getBuildConfiguration() == Engine::BUILD_CONFIG_RELEASE)
		Log::warning("Current build configuration is Release. Visualization of ObjectMeshSkinned "
					 "Bones is not available with this build configuration\n");
#endif

	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesConstraintsSample::init(): skinned is null\n");
		return;
	}

	// create IK chain and initialize bone sequence
	chain_id = skinned->addIKChain();
	skinned->setIKChainConstraint(ObjectMeshSkinned::CHAIN_CONSTRAINT_BONE_ROTATIONS, chain_id);
	for (int i = 0; i < ik_chain_bones.size(); i++)
		skinned->addIKChainBone(ik_chain_bones[i], chain_id);

	target_translator = WidgetManipulatorTranslator::create();
	target_translator->setTransform(translate(Vec3(2.0f, 2.0f, 0.5f)));
	target_translator->setLifetime(Widget::LIFETIME_WORLD);
	WindowManager::getMainWindow()->addChild(target_translator);

	skinned->setIKChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);

	// create constraints
	for (int i = 0; i < constraints.size(); i++)
	{
		const Constraint &c = constraints[i];
		int index = skinned->addBoneConstraint(c.name);
		if (index == -1)
			continue;

		skinned->setBoneConstraintYawAxis(c.yaw_axis, index);
		skinned->setBoneConstraintPitchAxis(c.pitch_axis, index);
		skinned->setBoneConstraintRollAxis(c.roll_axis, index);

		skinned->setBoneConstraintYawAngles(c.yaw_min_angle, c.yaw_max_angle, index);
		skinned->setBoneConstraintPitchAngles(c.pitch_min_angle, c.pitch_max_angle, index);
		skinned->setBoneConstraintRollAngles(c.roll_min_angle, c.roll_max_angle, index);

		skinned->addVisualizeConstraint(index);
	}

	skinned->addVisualizeIKChain(chain_id);
	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesConstraintsSample::update()
{
	if (chain_id == -1)
		return;

	PlayerPtr player = Game::getPlayer();
	if (player.isValid() == false)
		return;

	target_translator->setModelview(player->getCamera()->getModelview());
	target_translator->setProjection(player->getCamera()->getProjection());

	skinned->setIKChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);
}

void AnimationBonesConstraintsSample::shutdown()
{
	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

```

## AnimationBonesIKSample.cpp

```cpp
#include "AnimationBonesIKSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(AnimationBonesIKSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesIKSample::init()
{
#ifndef DEBUG
	if (Engine::get()->getBuildConfiguration() == Engine::BUILD_CONFIG_RELEASE)
		Log::warning("Current build configuration is Release. Visualization of ObjectMeshSkinned "
					 "Bones is not available with this build configuration\n");
#endif

	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesIKSample::init(): skinned is null\n");
		return;
	}

	// create IK chain and initialize bone sequence
	chain_id = skinned->addIKChain();
	for (int i = 0; i < bones.size(); i++)
		skinned->addIKChainBone(bones[i], chain_id);

	target_translator = WidgetManipulatorTranslator::create();
	target_translator->setTransform(translate(Vec3(-0.175f, 0.5f, 0.5f)));
	target_translator->setLifetime(Widget::LIFETIME_WORLD);
	WindowManager::getMainWindow()->addChild(target_translator);

	pole_translator = WidgetManipulatorTranslator::create();
	pole_translator->setTransform(translate(Vec3(-0.3f, 1.0f, 1.0f)));
	pole_translator->setLifetime(Widget::LIFETIME_WORLD);
	WindowManager::getMainWindow()->addChild(pole_translator);

	skinned->setIKChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);
	skinned->setIKChainPoleWorldPosition(pole_translator->getTransform().getTranslate(), chain_id);

	skinned->addVisualizeIKChain(chain_id);
	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesIKSample::update()
{
	if (chain_id == -1)
		return;

	PlayerPtr player = Game::getPlayer();
	if (player.isValid() == false)
		return;

	target_translator->setModelview(player->getCamera()->getModelview());
	target_translator->setProjection(player->getCamera()->getProjection());

	pole_translator->setModelview(player->getCamera()->getModelview());
	pole_translator->setProjection(player->getCamera()->getProjection());

	skinned->setIKChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);
	skinned->setIKChainPoleWorldPosition(pole_translator->getTransform().getTranslate(), chain_id);
}

void AnimationBonesIKSample::shutdown()
{
	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

```

## AnimationBonesLookAtSample.cpp

```cpp
#include "AnimationBonesLookAtSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(AnimationBonesLookAtSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesLookAtSample::init()
{
#ifndef DEBUG
	if (Engine::get()->getBuildConfiguration() == Engine::BUILD_CONFIG_RELEASE)
		Log::warning("Current build configuration is Release. Visualization of ObjectMeshSkinned "
					 "Bones is not available with this build configuration\n");
#endif

	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesLookAtSample::init(): skinned is null\n");
		return;
	}

	// create LookAt chain and initialize bone sequence
	chain_id = skinned->addLookAtChain();
	for (int i = 0; i < bones.size(); i++)
	{
		const Bone &b = bones[i];
		int index = skinned->addLookAtChainBone(b.name, chain_id);
		if (index == -1)
			continue;

		// these axes must be in the local basis of the bone
		skinned->setLookAtChainBoneAxis(Vec3(b.axis), index, chain_id);
		skinned->setLookAtChainBoneUp(Vec3(b.up), index, chain_id);

		skinned->setLookAtChainBoneWeight(b.weight, index, chain_id);
	}

	target_translator = WidgetManipulatorTranslator::create();
	target_translator->setTransform(translate(Vec3(1.5f, 1.5f, 1.6f)));
	target_translator->setLifetime(Widget::LIFETIME_WORLD);
	WindowManager::getMainWindow()->addChild(target_translator);

	pole_translator = WidgetManipulatorTranslator::create();
	pole_translator->setTransform(translate(Vec3(0.0f, 0.0f, 3.0f)));
	pole_translator->setLifetime(Widget::LIFETIME_WORLD);
	WindowManager::getMainWindow()->addChild(pole_translator);

	skinned->setLookAtChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);
	skinned->setLookAtChainPoleWorldPosition(pole_translator->getTransform().getTranslate(), chain_id);

	skinned->addVisualizeLookAtChain(chain_id);
	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesLookAtSample::update()
{
	if (chain_id == -1)
		return;

	PlayerPtr player = Game::getPlayer();
	if (player.isValid() == false)
		return;

	target_translator->setModelview(player->getCamera()->getModelview());
	target_translator->setProjection(player->getCamera()->getProjection());

	pole_translator->setModelview(player->getCamera()->getModelview());
	pole_translator->setProjection(player->getCamera()->getProjection());

	skinned->setLookAtChainTargetWorldPosition(target_translator->getTransform().getTranslate(), chain_id);
	skinned->setLookAtChainPoleWorldPosition(pole_translator->getTransform().getTranslate(), chain_id);
}

void AnimationBonesLookAtSample::shutdown()
{
	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

```

## AnimationBonesMasksSample.cpp

```cpp
#include "AnimationBonesMasksSample.h"

#include <UnigineGui.h>

REGISTER_COMPONENT(AnimationBonesMasksSample);

using namespace Unigine;

void AnimationBonesMasksSample::init()
{
	ObjectMeshSkinnedPtr skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesMasksSample::init(): skinned is null\n");
		return;
	}

	skinned->setLayerFrameUsesEnabled(0, true);
	for (int i = 0; i < rotation_only_bones.size(); i++)
	{
		int bone = skinned->findBone(rotation_only_bones[i]);
		if (bone != -1)
			skinned->setLayerBoneFrameUses(0, bone, ObjectMeshSkinned::ANIM_FRAME_USES_ROTATION);
	}
}

```

## AnimationBonesRetargetingSample.cpp

```cpp
#include "AnimationBonesRetargetingSample.h"

#include <UnigineGui.h>

REGISTER_COMPONENT(AnimationBonesRetargetingSample);

using namespace Unigine;

void AnimationBonesRetargetingSample::init()
{
	ObjectMeshSkinnedPtr skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesRetargetingSample::init(): skinned is null\n");
		return;
	}

	BonesRetargetingPtr retargeting = BonesRetargeting::create();

	// Loading the names of bones from two skeletons
	// to further configure the mapping between them.
	bool res = retargeting->loadBones(src_mesh_path, skinned->getMeshPath());
	if (res == false)
	{
		Log::error("AnimationBonesRetargetingSample::init(): can't load bones from meshes\n");
		return;
	}

	// In our example the skeletons have the same bone names,
	// so we will use a special method to calculate the proportions.
	// In general, you can use setNameMapping(src_bone, dst_bone).
	retargeting->findEqualNameMapping();

	// By default, all bones use positions from their default position. (T-pose and MODE_BIND).
	// But in order to avoid the character "hanging" in the air, we must adjust the bones
	// standing on the ground and the hip bones. To do this, we transfer them to the proportion mode.
	if (String::isEmpty(on_ground_bone_name) == false)
		retargeting->setBoneMode(on_ground_bone_name, BonesRetargeting::MODE_PROPORTION);

	if (String::isEmpty(hips_bone_name) == false)
		retargeting->setBoneMode(hips_bone_name, BonesRetargeting::MODE_PROPORTION);

	// Register retargeting for a specific mesh and a specific animation.
	ObjectMeshSkinned::setRetargeting(retargeting, anim_path, skinned->getMeshPath());

	// And update the animation on the default zero layer.
	skinned->setAnimPath(anim_path);
}

void AnimationBonesRetargetingSample::shutdown()
{
	ObjectMeshSkinnedPtr skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid())
		ObjectMeshSkinned::removeRetargeting(anim_path, skinned->getMeshPath());
}

```

## AnimationBonesRootMotion.cpp

```cpp
#include "AnimationBonesRootMotion.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(AnimationBonesRootMotion);

using namespace Unigine;
using namespace Math;

void FrameUpdater::init(ObjectMeshSkinnedPtr &skinned)
{
	// this callback can be called from any thread and not every frame
	// it depends on the object update settings
	// this ifps takes into account all these features
	skinned->getEventUpdate().connect(skinned_connection, [](float ifps, const ObjectMeshSkinnedPtr &obj)
	{
		// just update the frames in a loop
		float frame = obj->getLayerFrame(0);
		frame += ifps * 30.0f;

		const int num_frames = obj->getLayerNumFrames(0);
		if (frame >= (num_frames - 1))
			frame -= (num_frames - 1);

		obj->setLayerFrame(0, frame);
	});
}

void RootMotionFrameUpdater::init(ObjectMeshSkinnedPtr &skinned, const char *root_bone_name, Unigine::Math::AXIS in_axis_forward)
{
	axis_forward = in_axis_forward;

	// find the bone the offset of which will be applied to the object
	root_bone = skinned->findBone(root_bone_name);
	if (root_bone == -1)
		return;

	skinned->getEventUpdate().connect(skinned_connection, [this](float ifps, const ObjectMeshSkinnedPtr &obj)
	{
		float frame = obj->getLayerFrame(0);
		frame += ifps * 30.0f;

		const int num_frames = obj->getLayerNumFrames(0);
		if (frame >= (num_frames - 1))
		{
			// we need to save the bone offset to the last frame...
			obj->setLayerFrame(0, itof(num_frames - 1));
			mat4 bone_t = obj->getLayerBoneTransform(0, root_bone);
			update_proj_bone_transform(bone_t, axis_forward);
			last_frame_delta = inverse(prev_proj_bone_t) * proj_bone_t;

			// ...and update the previous transform to frame zero
			obj->setLayerFrame(0, 0.0f);
			bone_t = obj->getLayerBoneTransform(0, root_bone);
			update_proj_bone_transform(bone_t, axis_forward);
			prev_proj_bone_t = proj_bone_t;

			frame -= (num_frames - 1);
		} else
		{
			last_frame_delta = mat4_identity;
		}

		obj->setLayerFrame(0, frame);

		// get the bone transformation projected onto the XY plane
		mat4 bone_t = obj->getLayerBoneTransform(0, root_bone);
		update_proj_bone_transform(bone_t, axis_forward);

		// calculate the bone offset based on the previous transformation
		// and on the offset in the last frame
		root_motion_delta = inverse(prev_proj_bone_t) * (proj_bone_t * last_frame_delta);

		// save the last update frame, since this callback is not called every frame
		root_motion_delta_frame = Engine::get()->getFrame();

		// move the root bone to the origin
		bone_t = inverse(proj_bone_t) * bone_t;
		obj->setLayerBoneTransform(0, root_bone, bone_t);

		prev_proj_bone_t = proj_bone_t;
	});
}

void RootMotionFrameUpdater::applyRootMotion(ObjectMeshSkinnedPtr &skinned)
{
	// apply the offset to the object if it really was in this frame
	long long frame = Engine::get()->getFrame();
	if (frame == root_motion_delta_frame)
	{
		skinned->setWorldTransform(skinned->getWorldTransform() * Mat4(root_motion_delta));
		root_motion_delta = mat4_identity;
	}
}

void RootMotionFrameUpdater::update_proj_bone_transform(const mat4 &bone_t, AXIS axis_forward)
{
	vec3 forward_axis;
	switch (axis_forward) {
		case AXIS_X: forward_axis = bone_t.getAxisX(); break;
		case AXIS_Y: forward_axis = bone_t.getAxisY(); break;
		case AXIS_Z: forward_axis = bone_t.getAxisZ(); break;
		case AXIS_NX: forward_axis = -bone_t.getAxisX(); break;
		case AXIS_NY: forward_axis = -bone_t.getAxisY(); break;
		case AXIS_NZ: forward_axis = -bone_t.getAxisZ(); break;
	}
	vec3 position = projectOntoPlane(bone_t.getTranslate(), vec3_up);
	forward_axis = projectOntoPlane(forward_axis, vec3_up);
	forward_axis.normalize();
	vec3 right_axis = cross(forward_axis, vec3_up);
	right_axis.normalize();

	proj_bone_t.setColumn3(0, right_axis);
	proj_bone_t.setColumn3(1, forward_axis);
	proj_bone_t.setColumn3(2, vec3_up);
	proj_bone_t.setColumn3(3, position);
}

void AnimationBonesRootMotion::init()
{
	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesRootMotion::init(): skinned is null\n");
		return;
	}

	skinned_root_motion = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_root_motion_node.get());
	if (skinned_root_motion.isValid() == false)
	{
		Log::error("AnimationBonesRootMotion::init(): root motion skinned is null\n");
		return;
	}

	skinned->stop();
	skinned_root_motion->stop();

	skinned->setAnimPath(animation_path.get());
	skinned_root_motion->setAnimPath(animation_path.get());

	frame_updater.init(skinned);
	root_motion_frame_updater.init(skinned_root_motion, root_bone_name);

	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesRootMotion::update()
{
	auto render_transform = [](const Mat4 t)
	{
		Vec3 p = t.getTranslate();
		Visualizer::renderVector(p, p + t.getAxisX(), vec4_red);
		Visualizer::renderVector(p, p + t.getAxisY(), vec4_green);
		Visualizer::renderVector(p, p + t.getAxisZ(), vec4_blue);
	};

	render_transform(skinned->getWorldTransform());
	render_transform(skinned_root_motion->getWorldTransform());
}

void AnimationBonesRootMotion::post_update()
{
	root_motion_frame_updater.applyRootMotion(skinned_root_motion);
}

void AnimationBonesRootMotion::shutdown()
{
	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

```

## AnimationBonesSandboxSample.cpp

```cpp
#include "AnimationBonesSandboxSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(AnimationBonesSandboxSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesSandboxSample::init()
{
#ifndef DEBUG
	if (Engine::get()->getBuildConfiguration() == Engine::BUILD_CONFIG_RELEASE)
		Log::warning("Current build configuration is Release. Visualization of ObjectMeshSkinned "
					 "Bones is not available with this build configuration\n");
#endif

	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesSandboxSample::init(): skinned is null\n");
		return;
	}

	skinned->setVisualizeAllBones(true);

	// LookAt chain
	{
		int id = skinned->addLookAtChain();
		skinned->setLookAtChainTargetWorldPosition(Vec3(0.0f, 2.0f, 1.5f), id);
		skinned->setLookAtChainPoleWorldPosition(Vec3(0.0f, 0.0f, 3.0f), id);

		int index = -1;

		index = skinned->addLookAtChainBone("spine_1", id);
		skinned->setLookAtChainBoneAxis(Vec3(0.0f, 0.f, 1.0f), index, id);
		skinned->setLookAtChainBoneUp(Vec3(0.0f, 1.0f, 0.0f), index, id);
		skinned->setLookAtChainBoneWeight(0.05f, index, id);

		index = skinned->addLookAtChainBone("spine_2", id);
		skinned->setLookAtChainBoneAxis(Vec3(0.0f, 0.f, 1.0f), index, id);
		skinned->setLookAtChainBoneUp(Vec3(0.0f, 1.0f, 0.0f), index, id);
		skinned->setLookAtChainBoneWeight(0.1f, index, id);

		index = skinned->addLookAtChainBone("spine_3", id);
		skinned->setLookAtChainBoneAxis(Vec3(0.0f, 0.f, 1.0f), index, id);
		skinned->setLookAtChainBoneUp(Vec3(0.0f, 1.0f, 0.0f), index, id);
		skinned->setLookAtChainBoneWeight(0.15f, index, id);

		index = skinned->addLookAtChainBone("neck", id);
		skinned->setLookAtChainBoneAxis(Vec3(0.0f, 0.f, 1.0f), index, id);
		skinned->setLookAtChainBoneUp(Vec3(0.0f, 1.0f, 0.0f), index, id);
		skinned->setLookAtChainBoneWeight(0.2f, index, id);

		index = skinned->addLookAtChainBone("head", id);
		skinned->setLookAtChainBoneAxis(Vec3(0.0f, 0.f, 1.0f), index, id);
		skinned->setLookAtChainBoneUp(Vec3(0.0f, 1.0f, 0.0f), index, id);
		skinned->setLookAtChainBoneWeight(1.0f, index, id);
	}

	// IK chain
	{
		int id = skinned->addIKChain();
		int bone = skinned->findBone("foot_l");
		skinned->setIKChainTargetWorldPosition(skinned->getBoneWorldTransform(bone).getTranslate(), id);
		bone = skinned->findBone("shin_l");
		skinned->setIKChainPoleWorldPosition(skinned->getBoneWorldTransform(bone).getTranslate() + Vec3_forward, id);

		skinned->addIKChainBone("thigh_l", id);
		skinned->addIKChainBone("shin_l", id);
		skinned->addIKChainBone("foot_l", id);
	}

	// constraints
	{
		int index = skinned->addBoneConstraint("head");
		skinned->setBoneConstraintYawAngles(-40.0f, 40.0f, index);
		skinned->setBoneConstraintYawAxis(vec3(0.0f, 1.0f, 0.0f), index);
		skinned->setBoneConstraintPitchAngles(-40.0f, 40.0f, index);
		skinned->setBoneConstraintPitchAxis(vec3(1.0f, 0.0f, 0.0f), index);
		skinned->setBoneConstraintRollAngles(-0.0f, 0.0f, index);
		skinned->setBoneConstraintRollAxis(vec3(0.0f, 0.0f, 1.0f), index);
	}

	main_hbox = WidgetHBox::create();
	main_hbox->setLifetime(Widget::LIFETIME_WINDOW);

	main_vbox = WidgetVBox::create(0, 5);
	main_vbox->setBackground(1);
	main_hbox->addChild(main_vbox, Gui::ALIGN_EXPAND);

	bone_selection.init(skinned);
	main_vbox->addChild(bone_selection.getWidget(), Gui::ALIGN_LEFT);

	look_at_editor.init(skinned, &bone_selection);
	main_vbox->addChild(look_at_editor.getWidget(), Gui::ALIGN_LEFT);

	ik_editor.init(skinned, &bone_selection);
	main_vbox->addChild(ik_editor.getWidget(), Gui::ALIGN_LEFT);

	constraint_editor.init(skinned, &bone_selection);
	main_vbox->addChild(constraint_editor.getWidget(), Gui::ALIGN_LEFT);

	editors_window = EngineWindowViewport::create("Bones Sandbox Editors", 600, 1000);
	editors_window->setCanBeNested(false);
	editors_window->setCanCreateGroup(false);
	editors_window->addChild(main_hbox, Gui::ALIGN_EXPAND);
	editors_window->setPosition(ivec2(40, 40));
	editors_window->show();

	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesSandboxSample::shutdown()
{
	editors_window.deleteLater();

	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

```

## AnimationBonesSimpleFootPlacementSample.cpp

```cpp
#include "AnimationBonesSimpleFootPlacementSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(AnimationBonesSimpleFootPlacementSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesSimpleFootPlacementSample::init()
{
#ifndef DEBUG
	if (Engine::get()->getBuildConfiguration() == Engine::BUILD_CONFIG_RELEASE)
		Log::warning("Current build configuration is Release. Visualization of ObjectMeshSkinned "
					 "Bones is not available with this build configuration\n");
#endif

	skinned = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node.get());
	if (skinned.isValid() == false)
	{
		Log::error("AnimationBonesSimpleFootPlacementSample::init(): skinned is null\n");
		return;
	}

	// create IK-chain and initialize bone sequence
	chain_ids[FOOT_LEFT] = skinned->addIKChain();
	for (int i = 0; i < left_leg_bones.size(); i++)
	{
		int bone = skinned->findBone(left_leg_bones[i]);
		if (bone == -1)
			continue;

		skinned->addIKChainBone(bone, chain_ids[FOOT_LEFT]);
		effector_bones[FOOT_LEFT] = bone;
	}
	skinned->setIKChainPoleWorldPosition(Vec3(0.5, 1.0f, 1.5), chain_ids[FOOT_LEFT]);

	chain_ids[FOOT_RIGHT] = skinned->addIKChain();
	for (int i = 0; i < right_leg_bones.size(); i++)
	{
		int bone = skinned->findBone(right_leg_bones[i]);
		if (bone == -1)
			continue;

		skinned->addIKChainBone(bone, chain_ids[FOOT_RIGHT]);
		effector_bones[FOOT_RIGHT] = bone;
	}
	skinned->setIKChainPoleWorldPosition(Vec3(1.0, 0.5f, 1.5), chain_ids[FOOT_RIGHT]);

	for (int i = FOOT_LEFT; i < FOOT_NUM; i++)
	{
		if (effector_bones[i] == -1)
			continue;

		Mat4 t = skinned->getBoneWorldTransform(effector_bones[i]);
		skinned->setIKChainTargetWorldPosition(t.getTranslate(), chain_ids[i]);

		skinned->setIKChainUseEffectorRotation(true, chain_ids[i]);
		skinned->setIKChainEffectorWorldRotation(t.getRotate(), chain_ids[i]);

		skinned->addVisualizeIKChain(chain_ids[i]);
	}

	if (obstacle.get().isValid())
	{
		translator = WidgetManipulatorTranslator::create();
		translator->setLifetime(Widget::LIFETIME_WORLD);
		translator->setTransform(obstacle->getWorldTransform());
		WindowManager::getMainWindow()->addChild(translator);

		rotator = WidgetManipulatorRotator::create();
		rotator->setLifetime(Widget::LIFETIME_WORLD);
		rotator->setTransform(obstacle->getWorldTransform());
		rotator->setHidden(true);
		WindowManager::getMainWindow()->addChild(rotator);
	}

	skinned->getEventBeginIKSolvers().connect(this, &AnimationBonesSimpleFootPlacementSample::on_begin_ik_solvers);

	Visualizer::setEnabled(true);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void AnimationBonesSimpleFootPlacementSample::update()
{
	PlayerPtr player = Game::getPlayer();
	if (obstacle.get().isValid() && player.isValid())
	{
		if (Input::isKeyDown(Input::KEY_T))
		{
			translator->setHidden(false);
			rotator->setHidden(true);
			translator->setTransform(obstacle->getWorldTransform());
		}

		if (Input::isKeyDown(Input::KEY_R))
		{
			rotator->setHidden(false);
			translator->setHidden(true);
			rotator->setTransform(obstacle->getWorldTransform());
		}

		if (translator->isHidden() == false)
		{
			translator->setModelview(player->getCamera()->getModelview());
			translator->setProjection(player->getCamera()->getProjection());
			obstacle->setWorldTransform(translator->getTransform());
		}

		if (rotator->isHidden() == false)
		{
			rotator->setModelview(player->getCamera()->getModelview());
			rotator->setProjection(player->getCamera()->getProjection());
			obstacle->setWorldTransform(rotator->getTransform());
		}
	}
}

void AnimationBonesSimpleFootPlacementSample::shutdown()
{
	Visualizer::setEnabled(false);
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
}

void AnimationBonesSimpleFootPlacementSample::on_begin_ik_solvers()
{
	for (int i = FOOT_LEFT; i < FOOT_NUM; i++)
	{
		if (effector_bones[i] == -1)
			continue;

		Mat4 t = skinned->getBoneWorldTransform(effector_bones[i]);
		Vec3 foot_pos(t.getTranslate());
		quat foot_rot(t.getRotate());

		Visualizer::renderVector(foot_pos + Vec3_up * 0.5f, foot_pos + Vec3_down * foot_height, vec4_blue);

		PhysicsIntersectionNormalPtr intersection = PhysicsIntersectionNormal::create();
		ObjectPtr obj = Physics::getIntersection(foot_pos + Vec3_up * 0.5f, foot_pos + Vec3_down * foot_height, 1, intersection);
		if (obj != nullptr)
		{
			Visualizer::renderVector(intersection->getPoint(), intersection->getPoint() + Vec3(intersection->getNormal()), vec4_blue);

			foot_pos = intersection->getPoint() + Vec3_up * foot_height;
			foot_rot = rotationFromTo(vec3_up, intersection->getNormal()) * foot_rot;
		}

		skinned->setIKChainTargetWorldPosition(foot_pos, chain_ids[i]);
		skinned->setIKChainEffectorWorldRotation(foot_rot, chain_ids[i]);
	}
}

```

## AnimationBonesStateMachineSample.cpp

```cpp
#include "AnimationBonesStateMachineSample.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>
#include <UnigineProperties.h>

REGISTER_COMPONENT(AnimationBonesStateMachineSample);

using namespace Unigine;
using namespace Math;

void AnimationBonesStateMachineSample::init()
{
	// walk state machine
	skinned_machine_walk = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node_machine_walk.get());
	if (skinned_machine_walk.isValid() == false)
	{
		Log::error("AnimationBonesStateMachineSample::init(): skinned is null\n");
		return;
	}

	UGUID prop_guid = FileSystem::pathToGuid(state_machine_walk_prop_path.get());
	PropertyPtr state_machine_walk_prop = Properties::findPropertyByGUID(prop_guid);
	if (state_machine_walk_prop.isNull())
		state_machine_walk_prop = Properties::findPropertyByPath(state_machine_walk_prop_path.get());

	state_machine_walk.initFromProperty(skinned_machine_walk, state_machine_walk_prop, Math::AXIS(axis_forward.get()));

	// idle turn state machine
	skinned_machine_idle_turn = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node_machine_idle_turn.get());
	if (skinned_machine_idle_turn.isValid() == false)
	{
		Log::error("AnimationBonesStateMachineSample::init(): skinned is null\n");
		return;
	}

	prop_guid = FileSystem::pathToGuid(state_machine_idle_turn_prop_path.get());
	PropertyPtr state_machine_idle_turn_prop = Properties::findPropertyByGUID(prop_guid);
	if (state_machine_idle_turn_prop.isNull())
		state_machine_idle_turn_prop = Properties::findPropertyByPath(state_machine_idle_turn_prop_path.get());

	state_machine_idle_turn.initFromProperty(skinned_machine_idle_turn, state_machine_idle_turn_prop, Math::AXIS(axis_forward.get()));

	// walk run state machine
	skinned_machine_walk_run = checked_ptr_cast<ObjectMeshSkinned>(mesh_skinned_node_machine_walk_run.get());
	if (skinned_machine_walk_run.isValid() == false)
	{
		Log::error("AnimationBonesStateMachineSample::init(): skinned is null\n");
		return;
	}

	prop_guid = FileSystem::pathToGuid(state_machine_walk_run_prop_path.get());
	PropertyPtr state_machine_walk_run_prop = Properties::findPropertyByGUID(prop_guid);
	if (state_machine_walk_run_prop.isNull())
		state_machine_walk_run_prop = Properties::findPropertyByPath(state_machine_walk_run_prop_path.get());

	state_machine_walk_run.initFromProperty(skinned_machine_walk_run, state_machine_walk_run_prop, Math::AXIS(axis_forward.get()));
}

void AnimationBonesStateMachineSample::update()
{
	// walk
	{
		if (Input::isKeyDown(Input::KEY_T))
			state_machine_walk.setFloatVariable("speed", 1.0f);

		if (Input::isKeyDown(Input::KEY_G))
			state_machine_walk.setFloatVariable("speed", 0.0f);

		state_machine_walk.setFlagVariable("turn", 0);
		if (Input::isKeyDown(Input::KEY_Y))
			state_machine_walk.setFlagVariable("turn", 1);

		skinned_machine_walk->setWorldTransform(skinned_machine_walk->getWorldTransform() * Mat4(state_machine_walk.getRootMotionDelta()));
	}

	// idle turn
	{
		float turn = state_machine_idle_turn.getFloatVariable("turn");
		if (Input::isKeyPressed(Input::KEY_V))
			turn += Game::getIFps();
		if (Input::isKeyPressed(Input::KEY_C))
			turn -= Game::getIFps();
		turn = clamp(turn, -1.0f, 1.0f);
		state_machine_idle_turn.setFloatVariable("turn", turn);

		skinned_machine_idle_turn->setWorldTransform(skinned_machine_idle_turn->getWorldTransform() * Mat4(state_machine_idle_turn.getRootMotionDelta()));
	}

	// walk run
	{
		float y = state_machine_walk_run.getFloatVariable("y");
		if (Input::isKeyPressed(Input::KEY_I))
			y += Game::getIFps();
		if (Input::isKeyPressed(Input::KEY_K))
			y -= Game::getIFps();
		y = saturate(y);
		state_machine_walk_run.setFloatVariable("y", y);

		float x = state_machine_walk_run.getFloatVariable("x");
		if (Input::isKeyPressed(Input::KEY_L))
			x += Game::getIFps();
		if (Input::isKeyPressed(Input::KEY_J))
			x -= Game::getIFps();
		x = clamp(x, -1.0f, 1.0f);
		state_machine_walk_run.setFloatVariable("x", x);

		skinned_machine_walk_run->setWorldTransform(skinned_machine_walk_run->getWorldTransform() * Mat4(state_machine_walk_run.getRootMotionDelta()));
	}
}

```

## AppSystemLogic.cpp

```cpp
#include "AppSystemLogic.h"
#include <UnigineComponentSystem.h>

#include "menu_ui/SamplesManager.h"
// System logic, it exists during the application life cycle.
// These methods are called right after corresponding system script's (UnigineScript) methods.

AppSystemLogic::AppSystemLogic()
{
}

AppSystemLogic::~AppSystemLogic()
{
}

int AppSystemLogic::init()
{
	// Write here code to be called on engine initialization.
	Unigine::Engine::get()->setBackgroundUpdate(
		Unigine::Engine::BACKGROUND_UPDATE_RENDER_NON_MINIMIZED);

	SamplesManager::get()->parseMetaXml("../cpp_samples.sample");
	Unigine::World::loadWorld("cpp_samples/cpp_samples");

	Unigine::ComponentSystem::get()->initialize();
	Unigine::Input::setMouseHandle(Unigine::Input::MOUSE_HANDLE_USER);

	return 1;
}
////////////////////////////////////////////////////////////////////////////////
// start of the main loop
////////////////////////////////////////////////////////////////////////////////
int AppSystemLogic::update()
{
	// Write here code to be called before updating each render frame.
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
// end of the main loop
////////////////////////////////////////////////////////////////////////////////

int AppSystemLogic::shutdown()
{
	// Write here code to be called on engine shutdown.
	return 1;
}

```

## AppWorldLogic.cpp

```cpp
#include "AppWorldLogic.h"
#include <UnigineWorld.h>
#include <UnigineDir.h>
#include <UnigineFileSystem.h>
#include <UnigineWidgets.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;


AppWorldLogic::AppWorldLogic()
{
	
}

AppWorldLogic::~AppWorldLogic()
{
}

int AppWorldLogic::init()
{
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
// start of the main loop
////////////////////////////////////////////////////////////////////////////////
int AppWorldLogic::update()
{
	// Write here code to be called before updating each render frame: specify all graphics-related functions you want to be called every frame while your application executes.
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
// end of the main loop
////////////////////////////////////////////////////////////////////////////////

int AppWorldLogic::shutdown()
{
	return 1;
}

```

## AsyncQueueSample.cpp

```cpp
#include "AsyncQueueSample.h"

#include <UnigineAsyncQueue.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(AsyncQueueSample)

void AsyncQueueSample::init()
{
	// Enqueue meshes to load
	for (int i = 0; i < meshes.size(); ++i)
	{
		const char *name = meshes[i];
		AsyncLoadRequest request;
		request.name = name;
		request.id = AsyncQueue::loadMesh(name);
		mesh_load_requests.push_back(request);
	}

	// Enqueue textures to load
	for (int i = 0; i < textures.size(); ++i)
	{
		AsyncQueue::loadImage(textures[i]);
	}

	AsyncQueue::getEventImageLoaded().connect(this, &AsyncQueueSample::image_loaded_callback);


	Console::setOnscreen(true);
}

void AsyncQueueSample::update()
{
	// check mesh load requests
	for (int i = 0; i < mesh_load_requests.size(); ++i)
	{
		const AsyncLoadRequest &request = mesh_load_requests[i];
		if (!AsyncQueue::checkMesh(request.id))
		{
			continue;
		}

		// grab loaded mesh using AsyncQueue::takeMesh() method
		MeshPtr mesh = AsyncQueue::takeMesh(request.id);

		if (mesh != nullptr)
		{
			// object with loaded mesh
			const ObjectMeshDynamicPtr object_mesh_dynamic = ObjectMeshDynamic::create(mesh);

			// set some position to this object
			constexpr Scalar initial_pos = -5.;
			constexpr Scalar step = 5.;
			object_mesh_dynamic->setPosition(
				Vec3(initial_pos + static_cast<float>(objects_placed) * step, 0., 0.));
			objects_placed++;

			// remove mesh from AsyncQueue
			AsyncQueue::removeMesh(request.id);
			Log::message("Loaded mesh \"%s\"\n", request.name.get());

			// remove request from requests collection
			mesh_load_requests.remove(i--);
		}
	}
}
void AsyncQueueSample::shutdown()
{
	for (auto &sprite : sprites)
	{
		sprite.deleteLater();
	}

	Console::setOnscreen(false);
}

void AsyncQueueSample::image_loaded_callback(const char *name, int id)
{
	auto loaded_image = AsyncQueue::takeImage(id);
	if (!loaded_image)
	{
		return;
	}

	AsyncQueue::removeImage(id);
	Log::message("Image \"%s\" loaded\n", name);

	auto main_window = WindowManager::getMainWindow();
	auto gui = main_window->getGui();

	auto sprite = WidgetSprite::create(gui);
	sprites.push_back(sprite);
	gui->addChild(sprite, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);
	sprite->setImage(loaded_image);
	sprite->setWidth(100);
	sprite->setHeight(100);

	ivec2 initial_sprite_position = ivec2(0, main_window->getSize().y - 200);

	auto new_pos = ivec2(initial_sprite_position.x + sprites.size() * 100,
		initial_sprite_position.y);
	sprite->setPosition(new_pos.x, new_pos.y);
}

```

## AsyncQueueStressSample.cpp

```cpp
#include "AsyncQueueStressSample.h"

#include <UnigineAsyncQueue.h>
#include <UnigineGame.h>
#include <UnigineProfiler.h>

REGISTER_COMPONENT(AsyncQueueStressSample);

using namespace Unigine;
using namespace Math;

void AsyncQueueStressSample::init()
{
	Profiler::setEnabled(true);

	num_nodes_loaded = 0;

	sample_description_window.createWindow(Gui::ALIGN_RIGHT);

	WidgetGroupBoxPtr parameters = sample_description_window.getParameterGroupBox();
	
	auto num_nodes_hbox = WidgetHBox::create(5);
	parameters->addChild(num_nodes_hbox, Gui::ALIGN_EXPAND);

	auto multithread_label = WidgetLabel::create("Num nodes");
	num_nodes_hbox->addChild(multithread_label);

	auto spinbox_hbox = WidgetHBox::create();
	auto editline = WidgetEditLine::create();
	editline->setValidator(Gui::VALIDATOR_INT);
	auto spinbox = WidgetSpinBox::create();
	editline->addAttach(spinbox);
	spinbox->setMinValue(1);
	spinbox->setMaxValue(10000);
	spinbox->setValue(100);
	spinbox_hbox->addChild(editline);
	spinbox_hbox->addChild(spinbox);
	num_nodes_hbox->addChild(spinbox_hbox, Gui::ALIGN_RIGHT);

	auto request_load_nodes_button = WidgetButton::create("Request Load Nodes Async");
	parameters->addChild(request_load_nodes_button, Gui::ALIGN_EXPAND);

	num_nodes_loaded_label = WidgetLabel::create();
	parameters->addChild(num_nodes_loaded_label, Gui::ALIGN_EXPAND);

	request_load_nodes_button->getEventClicked().connect(*this, [this, spinbox]()
	{
		AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_BACKGROUND, MakeCallback(this, &AsyncQueueStressSample::load_nodes, spinbox->getValue()));
	});
}

void AsyncQueueStressSample::update()
{
	num_nodes_loaded_label->setText("Num nodes loaded " + String::ltoa(num_nodes_loaded));
	if (num_nodes_loaded > 2000)
		num_nodes_loaded_label->setFontColor(vec4_red);
}

void AsyncQueueStressSample::shutdown()
{
	Profiler::setEnabled(false);

	sample_description_window.shutdown();
}

void AsyncQueueStressSample::load_nodes(int num)
{
	for (int i = 0; i < num; ++i)
	{
		// here we are loading the node not in the main thread, so it will not be added to the spatial tree
		NodePtr loaded_node = World::loadNode(node_to_spawn.get(), false);
		Vec3 position;
		position.x = Game::getRandomFloat(-100.0f, 100.0f);
		position.y = Game::getRandomFloat(-100.0f, 100.0f);
		position.z = Game::getRandomFloat(0.0f, 50.0f);
		loaded_node->setWorldPosition(position);

		num_nodes_loaded++;

		AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_MAIN, MakeCallback([loaded_node]()
			{
				// call updateEnabled which will recursively go through all the children and add them to the spatial tree
				loaded_node->updateEnabled();
			}));
	}
}

```

## AsyncQueueTasksSample.cpp

```cpp
#include "AsyncQueueTasksSample.h"

#include <UnigineAsyncQueue.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(AsyncQueueTasksSample);

using namespace Unigine;

void AsyncQueueTasksSample::init()
{
	Console::setOnscreen(true);

	// create sample UI
	sample_description_window.createWindow(Gui::ALIGN_RIGHT);

	WidgetGroupBoxPtr parameters = sample_description_window.getParameterGroupBox();
	
	auto async_thread_type_hbox = WidgetHBox::create(5);
	parameters->addChild(async_thread_type_hbox, Gui::ALIGN_EXPAND);

	auto async_thread_type_label = WidgetLabel::create("Task Thread Type");
	async_thread_type_hbox->addChild(async_thread_type_label);

	auto async_thread_type_combobox = WidgetComboBox::create();
	async_thread_type_combobox->addItem("BACKGORUND");
	async_thread_type_combobox->addItem("ASYNC");
	async_thread_type_combobox->addItem("GPU STREAM");
	async_thread_type_combobox->addItem("FILE STREAM");
	async_thread_type_combobox->addItem("MAIN");
	async_thread_type_combobox->addItem("NEW");
	async_thread_type_hbox->addChild(async_thread_type_combobox, Gui::ALIGN_EXPAND);

	auto run_async_button = WidgetButton::create("Run Async");
	run_async_button->getEventClicked().connect(*this, [instance = this, async_thread_type_combobox]()
		{
			// run a task asynchronously in a specified thread
			// also you can specify priority of your task
			// ASYNC_PRIORITY_CRITICAL - hight
			// ASYNC_PRIORITY_DEFAULT - medium
			// ASYNC_PRIORITY_BACKGROUND - low
			AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD(async_thread_type_combobox->getCurrentItem()), MakeCallback(instance, &AsyncQueueTasksSample::async_task));
		});
	parameters->addChild(run_async_button, Gui::ALIGN_EXPAND);

	auto spacer = WidgetSpacer::create();
	parameters->addChild(spacer, Gui::ALIGN_EXPAND);

	auto multithread_hbox = WidgetHBox::create(5);
	parameters->addChild(multithread_hbox, Gui::ALIGN_EXPAND);

	auto multithread_label = WidgetLabel::create("Num threads");
	multithread_hbox->addChild(multithread_label);

	auto spinbox_hbox = WidgetHBox::create();
	auto multithread_editline = WidgetEditLine::create();
	multithread_editline->setEditable(false);
	auto multithread_spinbox = WidgetSpinBox::create();
	multithread_editline->addAttach(multithread_spinbox);
	multithread_spinbox->setMinValue(1);
	multithread_spinbox->setMaxValue(20);
	multithread_spinbox->setValue(1);
	spinbox_hbox->addChild(multithread_editline);
	spinbox_hbox->addChild(multithread_spinbox);
	multithread_hbox->addChild(spinbox_hbox, Gui::ALIGN_RIGHT);

	auto frame_checkbox = WidgetCheckBox::create("Wait for multithreaded task to complete in frame");
	parameters->addChild(frame_checkbox, Gui::ALIGN_LEFT);

	auto run_async_multithread_button = WidgetButton::create("Run Async Multithread");
	run_async_multithread_button->getEventClicked().connect(*this, [instance = this, multithread_spinbox, frame_checkbox]()
		{
			// run a task in a multithread mode, current thread number and total amount of thread are passed to the callback
			// does not block the thread from which it is called
			if(frame_checkbox->isChecked())
				AsyncQueue::runFrameAsyncMultiThread(MakeCallback(instance, &AsyncQueueTasksSample::multithread_task), multithread_spinbox->getValue());
			else
				AsyncQueue::runAsyncMultiThread(MakeCallback(instance, &AsyncQueueTasksSample::multithread_task), multithread_spinbox->getValue());
		});
	parameters->addChild(run_async_multithread_button, Gui::ALIGN_EXPAND);

	auto run_sync_multithread_button = WidgetButton::create("Run Sync Multithread");
	run_sync_multithread_button->getEventClicked().connect(*this, [instance = this, multithread_spinbox, frame_checkbox]()
		{
			// run a task in a multithread mode, current thread number and total amount of thread are passed to the callback
			// blocks the thread from which it was called (the calling thread will be unblocked after the task is completed in all threads)
			if(frame_checkbox->isChecked())
				AsyncQueue::runFrameSyncMultiThread(MakeCallback(instance, &AsyncQueueTasksSample::multithread_task), multithread_spinbox->getValue());
			else	
				AsyncQueue::runSyncMultiThread(MakeCallback(instance, &AsyncQueueTasksSample::multithread_task), multithread_spinbox->getValue());
		});
	parameters->addChild(run_sync_multithread_button, Gui::ALIGN_EXPAND);
}

void AsyncQueueTasksSample::shutdown()
{
	Console::setOnscreen(false);
	sample_description_window.shutdown();
}

void AsyncQueueTasksSample::async_task()
{
	// simulate task work
	Thread::sleep(200);

	Log::message("This is async task, thread id: %d\n", Thread::getID());
}

void AsyncQueueTasksSample::multithread_task(int current_thread, int total_thread)
{
	// simulate task work
	Thread::sleep(200);

	Log::message("This is multithread task(current thread: %d, total number of threads: %d), thread id: %d\n", current_thread, total_thread, Thread::getID());
}

```

## AsyncTasks.cpp

```cpp
/* Copyright (C) 2005-2023, UNIGINE. All rights reserved.
 *
 * This file is a part of the UNIGINE 2 SDK.
 *
 * Your use and / or redistribution of this software in source and / or
 * binary form, with or without modification, is subject to: (i) your
 * ongoing acceptance of and compliance with the terms and conditions of
 * the UNIGINE License Agreement; and (ii) your inclusion of this notice
 * in any version of this software that you use or redistribute.
 * A copy of the UNIGINE License Agreement is available by contacting
 * UNIGINE. at http://unigine.com/
 */

#include "AsyncTasks.h"

using namespace Unigine;


ThreadQueue &ThreadQueue::get()
{
	static ThreadQueue instance;
	return instance;
}

void ThreadQueue::add(AsyncTaskBase *task)
{
	ScopedLock lock(mutex);
	queue.append(task);
}

void ThreadQueue::remove(AsyncTaskBase *task)
{
	ScopedLock lock(mutex);
	queue.removeOne(task);
}

void ThreadQueue::process()
{
	while (isRunning())
	{
		AsyncTaskBase *task = nullptr;
		{
			ScopedLock lock(mutex);
			if (queue.size())
				task = queue.takeFirst();
		}
		if (task)
			task->process();
		Thread::switchThread();
	}
}

AsyncTaskBase::AsyncTaskBase()
{
}

AsyncTaskBase::~AsyncTaskBase()
{
	ThreadQueue::get().remove(this);
}

```

## BoatControl.cpp

```cpp
#include "BoatControl.h"
#include <UnigineConsole.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(BoatControl);

using namespace Unigine;
using namespace Math;


void BoatControl::init()
{

}

void BoatControl::update()
{
	if (Console::isActive())
		return;


	int fb = int(Input::isKeyPressed(Input::KEY_W)) - int(Input::isKeyPressed(Input::KEY_S));
	int rl = int(Input::isKeyPressed(Input::KEY_A)) - int(Input::isKeyPressed(Input::KEY_D));

	float ifps = Game::getIFps();
	forward = lerp(forward, Scalar(max_speed.get() * fb), Scalar(ifps * acceleration_factor.get()));
	if (Math::abs(forward) < min_speed_for_rot.get())
		rl = 0;
	if (invert_rear_dir.get() && forward < 0.0)
		rl = -rl;

	rotation = lerp(rotation, float(max_rotation.get() * rl), ifps);

	node->rotate(0, 0, rotation * ifps);
	node->translate(0, forward * ifps, 0);
}

void BoatControl::shutdown()
{

}
```

## BoatFoam.cpp

```cpp
#include "BoatFoam.h"
#include <UnigineConsole.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(BoatFoam);

using namespace Unigine;
using namespace Math;


void BoatFoam::init()
{
	std::function<void(const NodePtr&)> collect = [this, &collect](const NodePtr &in_node)
	{
		if (!in_node)
			return;
		ObjectParticlesPtr p = checked_ptr_cast<ObjectParticles>(in_node);
		if (p)
		{
			auto & particles = foam_particles.append();
			particles.particles = p;
			particles.life_mean = p->getLifeMean();
			particles.life_spread = p->getLifeSpread();
			particles.spaw_rate = p->getSpawnRate();
			particles.velocity_min = p->getVelocityOverTimeModifier()->getConstantMin();
			particles.velocity_max = p->getVelocityOverTimeModifier()->getConstantMax();
		}

		NodeReferencePtr nr = checked_ptr_cast<NodeReference>(in_node);
		if (nr)
		{
			collect(nr->getReference());
		}

		for (int i = 0 ; i < in_node->getNumChildren(); i++)
		{
			collect(in_node->getChild(i));
		}
	};

	foam = checked_ptr_cast<DecalOrtho>(decal_foam.get());
	collect(foam);
}

void BoatFoam::update()
{
	float ifps = Game::getIFps();
	Vec3 p = node->getWorldPosition();
	Vec3 velocity = (p - last_position) / ifps;
	velocity = clamp(velocity, Vec3(-100, -100, 0), Vec3(100,100,0));
	velocity_scalar = Unigine::Math::lerp(velocity_scalar, float(velocity.length()), ifps);
	last_position = p;

	update_foam_decal_size();
	update_particles_params();
}

void BoatFoam::shutdown()
{

}

void BoatFoam::update_foam_decal_size()
{
	if (foam_particles.size() == 0) {
		return;
	}

	Vec3 pos = node->getWorldPosition();
	WorldBoundBox decal_bound_box(pos, pos);
	for (const auto & it : foam_particles)
	{
		decal_bound_box.expand(it.particles->getWorldBoundBoxParticles());
	}

	Vec3 min = decal_bound_box.minimum - Vec3(decal_padding);
	Vec3 max = decal_bound_box.maximum + Vec3(decal_padding);
	foam->setWidth((float)max.x - (float)min.x);
	foam->setHeight((float)max.y - (float)min.y);

	Vec3 center = (max + min) * 0.5f;
	center.z = pos.z + foam->getRadius() * 0.5f;

	Mat4 old_transform = foam->getTransform();
	foam->setWorldPosition(center);
	foam->setWorldRotation(quat_identity, true);
	Mat4 new_transform = foam->getTransform();

	Mat4 offset = inverse(new_transform) * old_transform;
	for(const auto & it : foam_particles)
	{
		it.particles->setTransform(offset * it.particles->getTransform());
	}
}

void BoatFoam::update_particles_params()
{
	float spawn_scale = clamp(velocity_scalar / max_ship_velocity_for_spawn_scale, 0.0f, 1.0f);
	float life_scale = clamp(velocity_scalar / max_ship_velocity_for_life_scale, 0.0f, 1.0f);
	float velocity_scale = clamp(velocity_scalar / max_ship_velocity_for_velocity_scale, 0.0f, 1.0f);

	float global_lifetime_param = Console::getFloat("global_lifetime");

	for(const auto & it : foam_particles) {

		it.particles->setSpawnRate(it.spaw_rate * spawn_scale);
		it.particles->setLife(it.life_mean * life_scale * global_lifetime_param, it.life_spread * life_scale);

		auto velocity_modifier = it.particles->getVelocityOverTimeModifier();
		velocity_modifier->setConstantMin(it.velocity_min * velocity_scale);
		velocity_modifier->setConstantMax(it.velocity_max * velocity_scale);
	}
}


```

## BoatSample.cpp

```cpp
#include "BoatSample.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(BoatSample);

using namespace Unigine;
using namespace Math;

ConsoleVariableFloat global_lifetime("global_lifetime", "global_lifetime", 0, 1.0f, 0.0f, 100.0f);

void BoatSample::init()
{
	auto water_object = checked_ptr_cast<ObjectWaterGlobal>(water.get());
	if (water_object)
	{
		water_object->setFetchSteepnessQuality(ObjectWaterGlobal::STEEPNESS_QUALITY_HIGH);
		water_object->setFetchAmplitudeThreshold(0.001f);
	}

	Console::setFloat("global_buoyancy", 1.0f);

	sample_description_window.createWindow();

	sample_description_window.addFloatParameter("Beaufort", "", 4, 1, 8, [this](float value) {
		auto water_object = checked_ptr_cast<ObjectWaterGlobal>(water.get());
		if (water_object)
		{
			water_object->setBeaufort(value);
		}
	});

	sample_description_window.addFloatParameter("Particles Life Time", "", 1, 0, 10,
		[](float v) { global_lifetime.set(v); });
}

void BoatSample::shutdown()
{
	sample_description_window.shutdown();
}

```

## BodyCallbacks.cpp

```cpp
#include "BodyCallbacks.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(BodyCallbacks)


void BodyCallbacks::init()
{
	// parameters validation
	auto file_path = mesh_file.get();
	if (String::isEmpty(file_path))
	{
		Log::error("BodyCallbacks::init(): Mesh File parameter is empty!\n");
		return;
	}

	frozen_mat = frozen_materal.get();
	if (!frozen_mat)
	{
		Log::error("BodyCallbacks::init(): Frozen Matreial parameter is empty!\n");
		return;
	}

	position_mat = position_materal.get();
	if (!position_mat)
	{
		Log::error("BodyCallbacks::init(): Position Matreial parameter is empty!\n");
		return;
	}

	// general Physics settings
	Physics::setFrozenLinearVelocity(0.1f);
	Physics::setFrozenAngularVelocity(0.1f);
	Physics::setNumIterations(4);

	// create object and physical body with a box shape
	ObjectMeshStaticPtr object = ObjectMeshStatic::create(file_path);
	BodyRigidPtr body = BodyRigid::create(object);
	ShapeBoxPtr shape = ShapeBox::create(body, vec3(1));
	object->setMaterial(position_mat, "*");

	// create tower
	for (int i = 0; i < tower_level; i++)
		for (int j = 0; j < tower_level - i; j++)
		{
			// clone created earlier object and calculate it's position in a tower
			auto cloned_object = static_ptr_cast<ObjectMeshStatic>(object->clone());
			cloned_object->setWorldTransform(
				translate(Vec3(0.0f, j - 0.5f * (tower_level - i) + 0.5f, i + 0.5f) * space));

			// add Frozen, Position and Contact callbacks to new object's body
			body = cloned_object->getBodyRigid();
			body->getEventFrozen().connect(body_connections, this, &BodyCallbacks::frozen_callback);
			body->getEventPosition().connect(body_connections, this,
				&BodyCallbacks::position_callback);
			body->getEventContactEnter().connect(body_connections, this,
				&BodyCallbacks::contact_callback);
			objects.append(cloned_object);
		}

	object.deleteLater();
}

void BodyCallbacks::shutdown()
{
	// remove all connections
	body_connections.disconnectAll();
	objects.clear();
}

void BodyCallbacks::frozen_callback(const Unigine::BodyPtr &body)
{
	body->getObject()->setMaterial(frozen_mat, "*");
}

void BodyCallbacks::position_callback(const Unigine::BodyPtr &body)
{
	body->getObject()->setMaterial(position_mat, "*");
}

void BodyCallbacks::contact_callback(const Unigine::BodyPtr &body)
{
	body->renderContacts();
}

```

## BodyFractureExplosion.cpp

```cpp
#include "BodyFractureExplosion.h"
#include "../../utils/BodyFractureUnit.h"
#include "UnigineMathLibVec4.h"
#include <UniginePhysics.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(BodyFractureExplosion);

using namespace Unigine;

void BodyFractureExplosion::explode()
{
	isExploding = true;
}

void BodyFractureExplosion::init()
{
	radius = 0;
	isExploding = false;

	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);
}

void BodyFractureExplosion::updatePhysics()
{
	if (!isExploding)
		return;

	Math::BoundSphere bound(Math::vec3(node->getWorldPosition()), radius);

	if (debug)
		Visualizer::renderBoundSphere(bound, Math::Mat4_identity, Math::vec4_red, 0.1f);

	auto actualPower = power * (1 - radius / max_radius);

	Vector<ObjectPtr> objects;
	if (World::getIntersection(bound, objects))
	{
		for (auto object : objects)
		{
			auto body = object->getBody();
			if (!body)
				continue;

			auto dir = Math::vec3(object->getWorldPosition() - node->getWorldPosition());
			dir.normalizeValid();

			if (debug)
				Visualizer::renderDirection(object->getWorldPosition(), dir, Math::vec4_blue, 0.25f, true, 0.8f, false);

			if (auto fractureUnit = getComponent<BodyFractureUnit>(object))
			{
				fractureUnit->crack(actualPower, object->getWorldPosition(), -dir);
			}

			if (auto rigidBody = checked_ptr_cast<BodyRigid>(body))
			{
				rigidBody->addForce(dir * actualPower);
			}
		}
	}

	radius = Math::min(radius + speed * Physics::getIFps(), max_radius);
	if (radius >= max_radius)
	{
		radius = 0;
		isExploding = false;
	}
}

void BodyFractureExplosion::shutdown()
{
	Visualizer::setEnabled(visualizer_enabled);
}

```

## BodyFractureExplosionSample.cpp

```cpp
#include "BodyFractureExplosionSample.h"
#include "BodyFractureExplosion.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(BodyFractureExplosionSample);

using namespace Unigine;

void BodyFractureExplosionSample::init()
{
	sample_description_window.createWindow();

	const auto& paramBox = sample_description_window.getParameterGroupBox();
	auto btn = WidgetButton::create("Explode!");
	btn->getEventClicked().connect(*this, [this]() {
		auto explosion = getComponent<BodyFractureExplosion>(target);
		if (explosion)
			explosion->explode();
	});
	paramBox->addChild(btn);
}

void BodyFractureExplosionSample::shutdown()
{
	sample_description_window.shutdown();
}

```

## BodyFractureShootingGalleryGun.cpp

```cpp
#include "BodyFractureShootingGalleryGun.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(BodyFractureShootingGalleryGun);

using namespace Unigine;

void BodyFractureShootingGalleryGun::update()
{
	if (Console::isActive())
		return;

	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT))
	{
		auto projectileNode = World::loadNode(projectile, true);
		if (!projectileNode)
			return;

		projectileNode->setWorldPosition(node->getWorldPosition() + Math::Vec3(node->getWorldDirection(Math::AXIS_NZ)));
		auto body = projectileNode->getObjectBodyRigid();
		if (!body)
			return;

		body->addLinearImpulse(node->getWorldDirection(Math::AXIS_NZ) * force);
	}
}

```

## BodyFractureShootingGallerySample.cpp

```cpp
#include "BodyFractureShootingGallerySample.h"

REGISTER_COMPONENT(BodyFractureShootingGallerySample);

using namespace Unigine;

void BodyFractureShootingGallerySample::init()
{
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
}

void BodyFractureShootingGallerySample::shutdown()
{
	Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
}

```

## BodyFractureUnit.cpp

```cpp
#include "BodyFractureUnit.h"
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(BodyFractureUnit);

using namespace Unigine;

BodyFracturePtr BodyFractureUnit::getBody() const
{
	return own_body;
}

bool BodyFractureUnit::isBroken()
{
	return own_body ? own_body->isBroken() : false;
}

void BodyFractureUnit::crack(float impulse, const Unigine::Math::Vec3 &point, const Unigine::Math::vec3 &normal)
{
	if (own_body && !own_body->isBroken() && impulse >= max_impulse)
		crack(own_body, point, normal);
}

void BodyFractureUnit::init()
{
	own_body = dynamic_ptr_cast<BodyFracture>(node->getObjectBody());
	if (!own_body)
	{
		Log::warning("BodyFractureUnit::init(): no fracture body was found\n");
		return;
	}

	own_body->setThreshold(threshold);
	own_body->setMaterial(material);

	own_body->getEventContactEnter().connect(this, &BodyFractureUnit::onContactEnter);

	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);
}

void BodyFractureUnit::update()
{
	if (!debug)
		return;

	if (!own_body || !own_body->isBroken())
	{
		Visualizer::renderObject(checked_ptr_cast<Object>(node), Math::vec4_white);
		return;
	}

	int cnt = own_body->getNumChildren();
	for (int i = 0; i < cnt; ++i)
		Visualizer::renderObject(own_body->getChild(i)->getObject(), Math::vec4_green);
}

void BodyFractureUnit::shutdown()
{
	Visualizer::setEnabled(visualizer_enabled);
}

void BodyFractureUnit::onContactEnter(const Unigine::BodyPtr &body, int num)
{
	if (!body)
		return;

	float impulse = body->getContactImpulse(num);
	if (impulse < max_impulse)
		return;

	auto b0 = body->getContactBody0(num);
	auto b1 = body->getContactBody1(num);

	while (b0 && b0->getType() != Body::BODY_FRACTURE)
		b0 = b0->getParent();
	while (b1 && b1->getType() != Body::BODY_FRACTURE)
		b1 = b1->getParent();

	auto bf0 = dynamic_ptr_cast<BodyFracture>(b0);
	auto bf1 = dynamic_ptr_cast<BodyFracture>(b1);
	auto fracture = bf1 ? bf1 : bf0;

	crack(fracture, body->getContactPoint(num), body->getContactNormal(num));

	own_body->getEventContactEnter().disconnect(this, &BodyFractureUnit::onContactEnter);
}

void BodyFractureUnit::crack(const Unigine::BodyFracturePtr &fracture, const Unigine::Math::Vec3 &point, const Unigine::Math::vec3 &normal)
{
	if (!fracture)
		return;

	switch (mode)
	{
	case MODE_SLICING:
		fracture->createSlicePieces(point, normal);
		break;
	case MODE_CRACKING:
		fracture->createCrackPieces(point, normal, cracking_num_cuts, cracking_num_rings, cracking_step);
		break;
	case MODE_SHATTERING:
		fracture->createShatterPieces(shattering_num_pieces);
		break;
	default:
		Log::warning("BodyFractureUnit::onContactEnter(body, int): Unknown fracturing mode %i\n", mode.get());
		break;
	}

	fracture->setBroken(true);
}

```

## BonesSandbox.cpp

```cpp
#include "BonesSandbox.h"

using namespace Unigine;
using namespace Math;

template<typename T>
Ptr<T> createWidgetOutline(const char *text)
{
	Ptr<T> widget = T::create(text);
	widget->setFontOutline(1);
	return widget;
}

template<typename T>
Ptr<T> createWidgetOutline()
{
	Ptr<T> widget = T::create();
	widget->setFontOutline(1);
	return widget;
}

WidgetVBoxPtr createNamedField(const char *name, const WidgetPtr &widget, int flags = Gui::ALIGN_LEFT)
{
	WidgetLabelPtr label = WidgetLabel::create(name);
	label->setFontOutline(1);

	WidgetVBoxPtr vbox = WidgetVBox::create();

	WidgetHBoxPtr hbox = WidgetHBox::create();
	vbox->addChild(hbox, Gui::ALIGN_EXPAND);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	hbox->addChild(widget, flags);

	return vbox;
}

WidgetVBoxPtr createNamedField(const char *name, const WidgetPtr &widget_0, const WidgetPtr &widget_1, int flags = Gui::ALIGN_LEFT)
{
	WidgetLabelPtr label = WidgetLabel::create(name);
	label->setFontOutline(1);

	WidgetVBoxPtr vbox = WidgetVBox::create();

	WidgetHBoxPtr hbox = WidgetHBox::create();
	vbox->addChild(hbox, Gui::ALIGN_EXPAND);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	hbox->addChild(widget_0, flags);
	hbox->addChild(widget_1, flags);

	return vbox;
}

// Widget Vec3

void WidgetVec3::init()
{
	main_hbox.deleteLater();
	main_hbox = WidgetHBox::create(5);

	x_line = createWidgetOutline<WidgetEditLine>();
	x_line->setValidator(Gui::VALIDATOR_FLOAT);
	x_spin_box = WidgetSpinBoxDouble::create(-10.0, 10.0, 0.0, 0.1);
	x_spin_box->addAttach(x_line);
	main_hbox->addChild(createNamedField("X: ", x_line, x_spin_box));

	y_line = createWidgetOutline<WidgetEditLine>();
	y_line->setValidator(Gui::VALIDATOR_FLOAT);
	y_spin_box = WidgetSpinBoxDouble::create(-10.0, 10.0, 0.0, 0.1);
	y_spin_box->addAttach(y_line);
	main_hbox->addChild(createNamedField("Y: ", y_line, y_spin_box));

	z_line = createWidgetOutline<WidgetEditLine>();
	z_line->setValidator(Gui::VALIDATOR_FLOAT);
	z_spin_box = WidgetSpinBoxDouble::create(-10.0, 10.0, 0.0, 0.1);
	z_spin_box->addAttach(z_line);
	main_hbox->addChild(createNamedField("Z: ", z_line, z_spin_box));

	x_spin_box->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	y_spin_box->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	z_spin_box->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	x_line->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	y_line->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	z_line->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
}

void WidgetVec3::setValue(const Vec3 &value)
{
	if (x_line == nullptr || y_line == nullptr || z_line == nullptr)
		return;

	x_line->setText(String::ftoa(toFloat(value.x)));
	y_line->setText(String::ftoa(toFloat(value.y)));
	z_line->setText(String::ftoa(toFloat(value.z)));
}

Vec3 WidgetVec3::getValue() const
{
	if (x_line == nullptr || y_line == nullptr || z_line == nullptr)
		return Vec3_zero;

	return Vec3(String::atof(x_line->getText()), String::atof(y_line->getText()), String::atof(z_line->getText()));
}

// Widget Vec2

void WidgetVec2::init()
{
	main_hbox.deleteLater();
	main_hbox = WidgetHBox::create(5);

	x_line = createWidgetOutline<WidgetEditLine>();
	x_line->setValidator(Gui::VALIDATOR_FLOAT);
	x_spin_box = WidgetSpinBoxDouble::create(-10.0, 10.0, 0.0, 0.1);
	x_spin_box->addAttach(x_line);
	main_hbox->addChild(createNamedField("X: ", x_line, x_spin_box));

	y_line = createWidgetOutline<WidgetEditLine>();
	y_line->setValidator(Gui::VALIDATOR_FLOAT);
	y_spin_box = WidgetSpinBoxDouble::create(-10.0, 10.0, 0.0, 0.1);
	y_spin_box->addAttach(y_line);
	main_hbox->addChild(createNamedField("Y: ", y_line, y_spin_box));

	x_spin_box->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	y_spin_box->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	x_line->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
	y_line->getEventChanged().connect(widget_connections, [this]() { event_changed.run(); });
}

void WidgetVec2::setValue(const Vec2 &value)
{
	if (x_line == nullptr || y_line == nullptr)
		return;

	x_line->setText(String::ftoa(toFloat(value.x)));
	y_line->setText(String::ftoa(toFloat(value.y)));
}

Vec2 WidgetVec2::getValue() const
{
	if (x_line == nullptr || y_line == nullptr)
		return Vec2_zero;

	return Vec2(String::atof(x_line->getText()), String::atof(y_line->getText()));
}

// Bone Selection

void BoneSelection::init(const ObjectMeshSkinnedPtr &obj)
{
	skinned = obj;

	if (main_group == nullptr)
		init_widgets();

	tree_box->clear();

	if (skinned.isValid())
	{
		int num_bones = skinned->getNumBones();
		for (int i = 0; i < num_bones; i++)
		{
			const char *name = skinned->getBoneName(i);
			tree_box->addItem(String::format("%s (%d)", name, i));
		}

		for (int i = 0; i < num_bones; i++)
		{
			int parent = skinned->getBoneParent(i);
			if (parent != -1)
				tree_box->setItemParent(i, parent);
		}
	}
}

int BoneSelection::getSelectedBone() const
{
	if (tree_box == nullptr)
		return -1;

	return tree_box->getCurrentItem();
}

void BoneSelection::init_widgets()
{
	main_group = createWidgetOutline<WidgetGroupBox>("<b>Bone Selection</b>");
	main_group->setFontRich(1);
	main_group->setFontSize(14);

	scroll_box = WidgetScrollBox::create();
	scroll_box->setWidth(350);
	scroll_box->setHeight(200);
	main_group->addChild(scroll_box, Gui::ALIGN_LEFT);

	tree_box = createWidgetOutline<WidgetTreeBox>();
	tree_box->setMultiSelection(false);
	scroll_box->addChild(tree_box, Gui::ALIGN_EXPAND);

	tree_box->getEventChanged().connect(widget_connection, [this]()
	{
		if (last_visualized_bone != -1)
			skinned->removeVisualizeBone(last_visualized_bone);

		last_visualized_bone = tree_box->getCurrentItem();
		if (last_visualized_bone != -1)
			skinned->addVisualizeBone(last_visualized_bone);
	});
}

// Look At Editor

void LookAtEditor::init(ObjectMeshSkinnedPtr &obj, const BoneSelection *selection)
{
	if (main_group == nullptr)
		init_widgets();

	skinned = obj;
	bone_selection = selection;

	update_chains_list();
}

int LookAtEditor::getSelectedChainID() const
{
	if (chains_list_box == nullptr)
		return 1;

	int index = chains_list_box->getCurrentItem();
	if (index == -1)
		return -1;

	return skinned->getLookAtChainID(index);
}

void LookAtEditor::init_widgets()
{
	// groups
	main_group = createWidgetOutline<WidgetGroupBox>("<b>Look At Editor</b>");
	main_group->setFontRich(1);
	main_group->setFontSize(14);

	grid_box = WidgetGridBox::create();
	main_group->addChild(grid_box, Gui::ALIGN_EXPAND);

	// chains
	chains_group = createWidgetOutline<WidgetGroupBox>("Chains");
	grid_box->addChild(chains_group, Gui::ALIGN_EXPAND);

	add_chain_button = createWidgetOutline<WidgetButton>("Add Look At Chain");
	chains_group->addChild(add_chain_button, Gui::ALIGN_LEFT);
	add_chain_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (skinned.isValid() == false)
			return;

		skinned->addLookAtChain();
		update_chains_list();
	});

	remove_chain_button = createWidgetOutline<WidgetButton>("Remove Look At Chain");
	chains_group->addChild(remove_chain_button, Gui::ALIGN_LEFT);
	remove_chain_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (skinned.isValid() == false)
			return;

		int id = getSelectedChainID();
		if (id != -1)
		{
			skinned->removeLookAtChain(id);
			update_chains_list();
		}
	});

	chains_list_box = createWidgetOutline<WidgetListBox>();
	chains_list_box->setMultiSelection(false);
	chains_group->addChild(chains_list_box, Gui::ALIGN_LEFT);
	chains_list_box->getEventChanged().connect(widget_connections, [this]()
	{
		chain_changed();
	});

	// chain settings
	chain_settings_group = createWidgetOutline<WidgetGroupBox>("Chain Settings");
	grid_box->addChild(chain_settings_group, Gui::ALIGN_EXPAND);

	chain_enabled_check_box = createWidgetOutline<WidgetCheckBox>("Enabled");
	chain_enabled_check_box->setChecked(true);
	chain_settings_group->addChild(chain_enabled_check_box, Gui::ALIGN_LEFT);
	chain_enabled_check_box->getEventClicked().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setLookAtChainEnabled(chain_enabled_check_box->isChecked(), id);
	});

	chain_constraint_combo_box = createWidgetOutline<WidgetComboBox>();
	chain_constraint_combo_box->addItem("NONE");
	chain_constraint_combo_box->addItem("POLE_VECTOR");
	chain_constraint_combo_box->addItem("BONE_ROTATIONS");
	chain_settings_group->addChild(createNamedField("Constraint: ", chain_constraint_combo_box), Gui::ALIGN_LEFT);
	chain_constraint_combo_box->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setLookAtChainConstraint(static_cast<ObjectMeshSkinned::CHAIN_CONSTRAINT>(chain_constraint_combo_box->getCurrentItem()), id);
	});

	chain_weight_slider = WidgetSlider::create(0, 1000, 1000);
	chain_settings_group->addChild(createNamedField("Weight: ", chain_weight_slider, Gui::ALIGN_EXPAND));
	chain_weight_slider->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		float weight = chain_weight_slider->getValue() / 1000.0f;
		skinned->setLookAtChainWeight(weight, id);
	});

	target_widget.init();
	chain_settings_group->addChild(createNamedField("Target: ", target_widget.getWidget(), Gui::ALIGN_RIGHT));
	target_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setLookAtChainTargetWorldPosition(target_widget.getValue(), id);
	});

	pole_widget.init();
	chain_settings_group->addChild(createNamedField("Pole: ", pole_widget.getWidget(), Gui::ALIGN_RIGHT));
	pole_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setLookAtChainPoleWorldPosition(pole_widget.getValue(), id);
	});

	// bones
	bones_group = createWidgetOutline<WidgetGroupBox>("Bones In Chain");
	grid_box->addChild(bones_group, Gui::ALIGN_EXPAND);

	add_bone_button = createWidgetOutline<WidgetButton>("Add Bone From Selection");
	bones_group->addChild(add_bone_button, Gui::ALIGN_LEFT);
	add_bone_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (bone_selection == nullptr)
			return;

		int id = getSelectedChainID();
		if (id == -1)
			return;

		int bone = bone_selection->getSelectedBone();
		if (bone == -1)
			return;

		skinned->addLookAtChainBone(bone, id);
		update_bones_list();
	});

	remove_bone_button = createWidgetOutline<WidgetButton>("Remove Bone");
	bones_group->addChild(remove_bone_button, Gui::ALIGN_LEFT);
	remove_bone_button->getEventClicked().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		int index = bones_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->removeLookAtChainBone(index, id);
		update_bones_list();
	});

	bones_list_box = createWidgetOutline<WidgetListBox>();
	bones_list_box->setMultiSelection(false);
	bones_group->addChild(bones_list_box, Gui::ALIGN_LEFT);
	bones_list_box->getEventChanged().connect(widget_connections, [this]()
	{
		bone_changed();
	});

	// bone settings
	bone_settings_group = createWidgetOutline<WidgetGroupBox>("Bone Settings");
	grid_box->addChild(bone_settings_group, Gui::ALIGN_EXPAND);

	bone_weight_slider = WidgetSlider::create(0, 1000, 1000);
	bone_settings_group->addChild(createNamedField("Weight: ", bone_weight_slider, Gui::ALIGN_EXPAND));
	bone_weight_slider->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		int index = bones_list_box->getCurrentItem();
		if (index == -1)
			return;

		float weight = bone_weight_slider->getValue() / 1000.0f;
		skinned->setLookAtChainBoneWeight(weight, index, id);
	});

	bone_up_widget.init();
	bone_settings_group->addChild(createNamedField("Up: ", bone_up_widget.getWidget(), Gui::ALIGN_RIGHT));
	bone_up_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		int index = bones_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setLookAtChainBoneUp(bone_up_widget.getValue(), index, id);
	});

	bone_axis_widget.init();
	bone_settings_group->addChild(createNamedField("Axis: ", bone_axis_widget.getWidget(), Gui::ALIGN_RIGHT));
	bone_axis_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		int index = bones_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setLookAtChainBoneAxis(bone_axis_widget.getValue(), index, id);
	});
}

void LookAtEditor::update_chains_list()
{
	chains_list_box->clear();
	if (skinned.isValid() == false)
	{
		chain_changed();
		return;
	}

	int num = skinned->getNumLookAtChains();
	for (int i = 0; i < num; i++)
	{
		int id = skinned->getLookAtChainID(i);
		chains_list_box->addItem(String::format("%d) chain ID %d", i + 1, id));
	}
	chain_changed();
}

void LookAtEditor::update_bones_list()
{
	bones_list_box->clear();
	int id = getSelectedChainID();
	if (id == -1)
	{
		bone_changed();
		return;
	}

	int num = skinned->getLookAtChainNumBones(id);
	for (int i = 0; i < num; i++)
	{
		int bone = skinned->getLookAtChainBone(i, id);
		const char *name = skinned->getBoneName(bone);
		bones_list_box->addItem(String::format("%d) %s (%d)", i + 1, name, bone));
	}
	bone_changed();
}

void LookAtEditor::chain_changed()
{
	skinned->clearVisualizeLookAtChain();

	int id = getSelectedChainID();
	if (id == -1)
	{
		chain_settings_group->setEnabled(false);
		chain_enabled_check_box->setChecked(false);
		chain_constraint_combo_box->setCurrentItem(0);
		chain_weight_slider->setValue(1000);
		target_widget.setValue(Vec3_zero);
		pole_widget.setValue(Vec3_zero);

		bones_group->setEnabled(false);
	} else
	{
		chain_settings_group->setEnabled(true);
		chain_enabled_check_box->setChecked(skinned->isLookAtChainEnabled(id));
		chain_constraint_combo_box->setCurrentItem(skinned->getLookAtChainConstraint(id));
		chain_weight_slider->setValue(ftoi(1000 * skinned->getLookAtChainWeight(id)));
		target_widget.setValue(skinned->getLookAtChainTargetWorldPosition(id));
		pole_widget.setValue(skinned->getLookAtChainPoleWorldPosition(id));

		bones_group->setEnabled(true);

		skinned->addVisualizeLookAtChain(id);
	}

	update_bones_list();
}

void LookAtEditor::bone_changed()
{
	int id = getSelectedChainID();
	int bone_index = -1;
	if (id != -1)
		bone_index = bones_list_box->getCurrentItem();

	if (bone_index == -1)
	{
		bone_settings_group->setEnabled(false);
		bone_weight_slider->setValue(1000);
		bone_up_widget.setValue(Vec3_up);
		bone_axis_widget.setValue(Vec3_forward);

		if (last_visualized_bone != -1)
			skinned->removeVisualizeBone(last_visualized_bone);
	} else
	{
		bone_settings_group->setEnabled(true);
		bone_weight_slider->setValue(ftoi(1000 * skinned->getLookAtChainBoneWeight(bone_index, id)));
		bone_up_widget.setValue(skinned->getLookAtChainBoneUp(bone_index, id));
		bone_axis_widget.setValue(skinned->getLookAtChainBoneAxis(bone_index, id));

		int bone = skinned->getLookAtChainBone(bone_index, id);

		if (last_visualized_bone != -1)
			skinned->removeVisualizeBone(last_visualized_bone);
		skinned->addVisualizeBone(bone);
		last_visualized_bone = bone;
	}
}

// IK Editor

void IKEditor::init(ObjectMeshSkinnedPtr &obj, const BoneSelection *selection)
{
	if (main_group == nullptr)
		init_widgets();

	skinned = obj;
	bone_selection = selection;

	update_chains_list();
}

int IKEditor::getSelectedChainID() const
{
	if (chains_list_box == nullptr)
		return 1;

	int index = chains_list_box->getCurrentItem();
	if (index == -1)
		return -1;

	return skinned->getIKChainID(index);
}

void IKEditor::init_widgets()
{
	// groups
	main_group = createWidgetOutline<WidgetGroupBox>("<b>IK Editor</b>");
	main_group->setFontRich(1);
	main_group->setFontSize(14);

	grid_box = WidgetGridBox::create();
	main_group->addChild(grid_box, Gui::ALIGN_EXPAND);

	// chains
	chains_group = createWidgetOutline<WidgetGroupBox>("Chains");
	grid_box->addChild(chains_group, Gui::ALIGN_EXPAND);

	add_chain_button = createWidgetOutline<WidgetButton>("Add IK Chain");
	chains_group->addChild(add_chain_button, Gui::ALIGN_LEFT);
	add_chain_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (skinned.isValid() == false)
			return;

		skinned->addIKChain();
		update_chains_list();
	});

	remove_chain_button = createWidgetOutline<WidgetButton>("Remove IK Chain");
	chains_group->addChild(remove_chain_button, Gui::ALIGN_LEFT);
	remove_chain_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (skinned.isValid() == false)
			return;

		int id = getSelectedChainID();
		if (id != -1)
		{
			skinned->removeIKChain(id);
			update_chains_list();
		}
	});

	chains_list_box = createWidgetOutline<WidgetListBox>();
	chains_list_box->setMultiSelection(false);
	chains_group->addChild(chains_list_box, Gui::ALIGN_LEFT);
	chains_list_box->getEventChanged().connect(widget_connections, [this]()
	{
		chain_changed();
	});

	// chain settings
	chain_settings_group = createWidgetOutline<WidgetGroupBox>("Chain Settings");
	grid_box->addChild(chain_settings_group, Gui::ALIGN_EXPAND);

	chain_enabled_check_box = createWidgetOutline<WidgetCheckBox>("Enabled");
	chain_enabled_check_box->setChecked(true);
	chain_settings_group->addChild(chain_enabled_check_box, Gui::ALIGN_LEFT);
	chain_enabled_check_box->getEventClicked().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainEnabled(chain_enabled_check_box->isChecked(), id);
	});

	chain_constraint_combo_box = createWidgetOutline<WidgetComboBox>();
	chain_constraint_combo_box->addItem("NONE");
	chain_constraint_combo_box->addItem("POLE_VECTOR");
	chain_constraint_combo_box->addItem("BONE_ROTATIONS");
	chain_settings_group->addChild(createNamedField("Constraint: ", chain_constraint_combo_box), Gui::ALIGN_LEFT);
	chain_constraint_combo_box->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainConstraint(static_cast<ObjectMeshSkinned::CHAIN_CONSTRAINT>(chain_constraint_combo_box->getCurrentItem()), id);
	});

	chain_weight_slider = WidgetSlider::create(0, 1000, 1000);
	chain_settings_group->addChild(createNamedField("Weight: ", chain_weight_slider, Gui::ALIGN_EXPAND));
	chain_weight_slider->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		float weight = chain_weight_slider->getValue() / 1000.0f;
		skinned->setIKChainWeight(weight, id);
	});

	target_widget.init();
	chain_settings_group->addChild(createNamedField("Target: ", target_widget.getWidget(), Gui::ALIGN_RIGHT));
	target_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainTargetWorldPosition(target_widget.getValue(), id);
	});

	pole_widget.init();
	chain_settings_group->addChild(createNamedField("Pole: ", pole_widget.getWidget(), Gui::ALIGN_RIGHT));
	pole_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainPoleWorldPosition(pole_widget.getValue(), id);
	});

	chain_effector_rotation_check_box = createWidgetOutline<WidgetCheckBox>("Use Effector Rotation");
	chain_effector_rotation_check_box->setChecked(true);
	chain_settings_group->addChild(chain_effector_rotation_check_box, Gui::ALIGN_LEFT);
	chain_effector_rotation_check_box->getEventClicked().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainUseEffectorRotation(chain_effector_rotation_check_box->isChecked(), id);
	});

	rotation_widget.init();
	chain_settings_group->addChild(createNamedField("Effector Rotation: ", rotation_widget.getWidget(), Gui::ALIGN_RIGHT));
	rotation_widget.getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		quat rot(composeRotationZXY(vec3(rotation_widget.getValue())));
		skinned->setIKChainEffectorWorldRotation(rot, id);
	});

	chain_iterations_slider = WidgetSlider::create(0, 32, 8);
	chain_settings_group->addChild(createNamedField("Iterations: ", chain_iterations_slider, Gui::ALIGN_EXPAND));
	chain_iterations_slider->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainNumIterations(chain_iterations_slider->getValue(), id);
	});

	chain_tolerance_line = createWidgetOutline<WidgetEditLine>();
	chain_tolerance_line->setValidator(Gui::VALIDATOR_FLOAT);
	chain_tolerance_spin_box = WidgetSpinBoxDouble::create(0.0, 1.0, 0.0, 0.005);
	chain_tolerance_spin_box->addAttach(chain_tolerance_line);
	chain_settings_group->addChild(createNamedField("Tolerance: ", chain_tolerance_line, chain_tolerance_spin_box));
	chain_tolerance_line->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainTolerance(String::atof(chain_tolerance_line->getText()), id);
	});
	chain_tolerance_spin_box->getEventChanged().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		skinned->setIKChainTolerance(toFloat(chain_tolerance_spin_box->getValue()), id);
	});

	// bones
	bones_group = createWidgetOutline<WidgetGroupBox>("Bones In Chain");
	grid_box->addChild(bones_group, Gui::ALIGN_EXPAND);

	add_bone_button = createWidgetOutline<WidgetButton>("Add Bone From Selection");
	bones_group->addChild(add_bone_button, Gui::ALIGN_LEFT);
	add_bone_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (bone_selection == nullptr)
			return;

		int id = getSelectedChainID();
		if (id == -1)
			return;

		int bone = bone_selection->getSelectedBone();
		if (bone == -1)
			return;

		skinned->addIKChainBone(bone, id);
		update_bones_list();
	});

	remove_bone_button = createWidgetOutline<WidgetButton>("Remove Bone");
	bones_group->addChild(remove_bone_button, Gui::ALIGN_LEFT);
	remove_bone_button->getEventClicked().connect(widget_connections, [this]()
	{
		int id = getSelectedChainID();
		if (id == -1)
			return;

		int index = bones_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->removeIKChainBone(index, id);
		update_bones_list();
	});

	bones_list_box = createWidgetOutline<WidgetListBox>();
	bones_list_box->setMultiSelection(false);
	bones_group->addChild(bones_list_box, Gui::ALIGN_LEFT);
	bones_list_box->getEventChanged().connect(widget_connections, [this]()
	{
		bone_changed();
	});
}

void IKEditor::update_chains_list()
{
	chains_list_box->clear();
	if (skinned.isValid() == false)
	{
		chain_changed();
		return;
	}

	int num = skinned->getNumIKChains();
	for (int i = 0; i < num; i++)
	{
		int id = skinned->getIKChainID(i);
		chains_list_box->addItem(String::format("%d) chain ID %d", i + 1, id));
	}
	chain_changed();
}

void IKEditor::update_bones_list()
{
	bones_list_box->clear();
	int id = getSelectedChainID();
	if (id == -1)
	{
		bone_changed();
		return;
	}

	int num = skinned->getIKChainNumBones(id);
	for (int i = 0; i < num; i++)
	{
		int bone = skinned->getIKChainBone(i, id);
		const char *name = skinned->getBoneName(bone);
		bones_list_box->addItem(String::format("%d) %s (%d)", i + 1, name, bone));
	}
	bone_changed();
}

void IKEditor::chain_changed()
{
	skinned->clearVisualizeIKChain();

	int id = getSelectedChainID();
	if (id == -1)
	{
		chain_settings_group->setEnabled(false);
		chain_enabled_check_box->setChecked(false);
		chain_constraint_combo_box->setCurrentItem(0);
		chain_weight_slider->setValue(1000);
		target_widget.setValue(Vec3_zero);
		pole_widget.setValue(Vec3_zero);
		chain_effector_rotation_check_box->setChecked(false);
		rotation_widget.setValue(Vec3(decomposeRotationZXY(mat3(quat_identity))));
		chain_iterations_slider->setValue(0);
		chain_tolerance_spin_box->setValue(0.0);

		bones_group->setEnabled(false);
	} else
	{
		chain_settings_group->setEnabled(true);
		chain_enabled_check_box->setChecked(skinned->isIKChainEnabled(id));
		chain_constraint_combo_box->setCurrentItem(skinned->getIKChainConstraint(id));
		chain_weight_slider->setValue(ftoi(1000 * skinned->getIKChainWeight(id)));
		target_widget.setValue(skinned->getIKChainTargetWorldPosition(id));
		pole_widget.setValue(skinned->getIKChainPoleWorldPosition(id));
		chain_effector_rotation_check_box->setChecked(skinned->isIKChainUseEffectorRotation(id));
		rotation_widget.setValue(Vec3(decomposeRotationZXY(mat3(skinned->getIKChainEffectorWorldRotation(id)))));
		chain_iterations_slider->setValue(skinned->getIKChainNumIterations(id));
		chain_tolerance_spin_box->setValue(toDouble(skinned->getIKChainTolerance(id)));

		bones_group->setEnabled(true);

		skinned->addVisualizeIKChain(id);
	}

	update_bones_list();
}

void IKEditor::bone_changed()
{
	int id = getSelectedChainID();
	int bone_index = -1;
	if (id != -1)
		bone_index = bones_list_box->getCurrentItem();

	if (bone_index != -1)
	{
		int bone = skinned->getIKChainBone(bone_index, id);

		if (last_visualized_bone != -1)
			skinned->removeVisualizeBone(last_visualized_bone);
		skinned->addVisualizeBone(bone);
		last_visualized_bone = bone;
	}
}

// Constraint Editor

void ConstraintEditor::init(ObjectMeshSkinnedPtr &obj, const BoneSelection *selection)
{
	if (main_group == nullptr)
		init_widgets();

	skinned = obj;
	bone_selection = selection;

	update_constraints_list();
}

void ConstraintEditor::init_widgets()
{
	// groups
	main_group = createWidgetOutline<WidgetGroupBox>("<b>Constraint Editor</b>");
	main_group->setFontRich(1);
	main_group->setFontSize(14);

	grid_box = WidgetGridBox::create();
	main_group->addChild(grid_box, Gui::ALIGN_EXPAND);

	// constraints
	constraints_group = createWidgetOutline<WidgetGroupBox>("Constraints");
	grid_box->addChild(constraints_group, Gui::ALIGN_EXPAND);

	add_constraint_button = createWidgetOutline<WidgetButton>("Add Bone From Selection");
	constraints_group->addChild(add_constraint_button, Gui::ALIGN_LEFT);
	add_constraint_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (bone_selection == nullptr)
			return;

		if (skinned == nullptr)
			return;

		int bone = bone_selection->getSelectedBone();
		if (bone == -1)
			return;

		int num = skinned->getNumBoneConstraints();
		for (int i = 0; i < num; i++)
		{
			if (skinned->getBoneConstraintBoneIndex(i) == bone)
				return;
		}

		skinned->addBoneConstraint(bone);
		update_constraints_list();
	});

	remove_constraint_button = createWidgetOutline<WidgetButton>("Remove Bone");
	constraints_group->addChild(remove_constraint_button, Gui::ALIGN_LEFT);
	remove_constraint_button->getEventClicked().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->removeBoneConstraint(index);
		update_constraints_list();
	});

	constraints_list_box = createWidgetOutline<WidgetListBox>();
	constraints_list_box->setMultiSelection(false);
	constraints_group->addChild(constraints_list_box, Gui::ALIGN_LEFT);
	constraints_list_box->getEventChanged().connect(widget_connections, [this]()
	{
		constraint_changed();
	});

	// constraint settings
	constraint_settings_group = createWidgetOutline<WidgetGroupBox>("Constraint Settings");
	grid_box->addChild(constraint_settings_group, Gui::ALIGN_EXPAND);

	enabled_check_box = createWidgetOutline<WidgetCheckBox>("Enabled");
	constraint_settings_group->addChild(enabled_check_box, Gui::ALIGN_LEFT);
	enabled_check_box->getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setBoneConstraintEnabled(enabled_check_box->isChecked(), index);
	});

	yaw_axis_widget.init();
	constraint_settings_group->addChild(createNamedField("Yaw Axis: ", yaw_axis_widget.getWidget(), Gui::ALIGN_RIGHT));
	yaw_axis_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setBoneConstraintYawAxis(vec3(yaw_axis_widget.getValue()), index);
	});

	pitch_axis_widget.init();
	constraint_settings_group->addChild(createNamedField("Pitch Axis: ", pitch_axis_widget.getWidget(), Gui::ALIGN_RIGHT));
	pitch_axis_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setBoneConstraintPitchAxis(vec3(pitch_axis_widget.getValue()), index);
	});

	roll_axis_widget.init();
	constraint_settings_group->addChild(createNamedField("Roll Axis: ", roll_axis_widget.getWidget(), Gui::ALIGN_RIGHT));
	roll_axis_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		skinned->setBoneConstraintRollAxis(vec3(roll_axis_widget.getValue()), index);
	});

	yaw_angles_widget.init();
	constraint_settings_group->addChild(createNamedField("Yaw Angles: ", yaw_angles_widget.getWidget(), Gui::ALIGN_RIGHT));
	yaw_angles_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		vec2 angles(yaw_angles_widget.getValue());
		skinned->setBoneConstraintYawAngles(angles.x, angles.y, index);
	});

	pitch_angles_widget.init();
	constraint_settings_group->addChild(createNamedField("Pitch Angles: ", pitch_angles_widget.getWidget(), Gui::ALIGN_RIGHT));
	pitch_angles_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		vec2 angles(pitch_angles_widget.getValue());
		skinned->setBoneConstraintPitchAngles(angles.x, angles.y, index);
	});

	roll_angles_widget.init();
	constraint_settings_group->addChild(createNamedField("Roll Angles: ", roll_angles_widget.getWidget(), Gui::ALIGN_RIGHT));
	roll_angles_widget.getEventChanged().connect(widget_connections, [this]()
	{
		if (skinned == nullptr)
			return;

		int index = constraints_list_box->getCurrentItem();
		if (index == -1)
			return;

		vec2 angles(roll_angles_widget.getValue());
		skinned->setBoneConstraintRollAngles(angles.x, angles.y, index);
	});
}

void ConstraintEditor::update_constraints_list()
{
	constraints_list_box->clear();
	if (skinned.isValid() == false)
	{
		constraint_changed();
		return;
	}

	int num = skinned->getNumBoneConstraints();
	for (int i = 0; i < num; i++)
	{
		int bone = skinned->getBoneConstraintBoneIndex(i);
		const char *name = skinned->getBoneName(bone);

		constraints_list_box->addItem(String::format("%d) %s (%d)", i + 1, name, bone));
	}
	constraint_changed();
}

void ConstraintEditor::constraint_changed()
{
	if (skinned == nullptr)
		return;

	skinned->clearVisualizeConstraint();

	int index = constraints_list_box->getCurrentItem();
	if (index == -1)
	{
		constraint_settings_group->setEnabled(false);
		enabled_check_box->setChecked(false);
		yaw_axis_widget.setValue(Vec3_zero);
		pitch_axis_widget.setValue(Vec3_zero);
		roll_axis_widget.setValue(Vec3_zero);
		yaw_angles_widget.setValue(Vec2(-180.0f, 180.0f));
		pitch_angles_widget.setValue(Vec2(-180.0f, 180.0f));
		roll_angles_widget.setValue(Vec2(-180.0f, 180.0f));
	} else
	{
		constraint_settings_group->setEnabled(true);
		enabled_check_box->setChecked(skinned->isBoneConstraintEnabled(index));
		yaw_axis_widget.setValue(Vec3(skinned->getBoneConstraintYawAxis(index)));
		pitch_axis_widget.setValue(Vec3(skinned->getBoneConstraintPitchAxis(index)));
		roll_axis_widget.setValue(Vec3(skinned->getBoneConstraintRollAxis(index)));
		yaw_angles_widget.setValue(Vec2(skinned->getBoneConstraintYawMinAngle(index), skinned->getBoneConstraintYawMaxAngle(index)));
		pitch_angles_widget.setValue(Vec2(skinned->getBoneConstraintPitchMinAngle(index), skinned->getBoneConstraintPitchMaxAngle(index)));
		roll_angles_widget.setValue(Vec2(skinned->getBoneConstraintRollMinAngle(index), skinned->getBoneConstraintRollMaxAngle(index)));

		skinned->addVisualizeConstraint(index);
	}
}

```

## BoundIntersection.cpp

```cpp
#include "BoundIntersection.h"
#include "UnigineComponentSystem.h"
#include "UnigineMaterial.h"
#include "UnigineMathLib.h"
#include "UnigineMathLibBounds.h"
#include "UnigineMathLibMat4.h"
#include "UnigineMathLibVec4.h"
#include "UnigineObjects.h"
#include "UniginePtr.h"
#include "UnigineVisualizer.h"
#include "UnigineWidgets.h"
#include "../../utils/Rotator.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(BoundIntersection)

void BoundIntersection::init()
{
	Visualizer::setEnabled(true);
	// initializing bound objects
	frustum_view_matrix =
		Mat4(lookAt(bound_frustum->eye_position, bound_frustum->target_position, bound_frustum->up_direction, bound_frustum->forward_axis));
	float view_aspect = static_cast<float>(bound_frustum->view_width) / bound_frustum->view_height;
	frustum_projection_matrix =
		perspective(bound_frustum->view_fov, view_aspect, bound_frustum->view_distance_min, bound_frustum->view_distance_max);

	// Using WorldBound types to support both single- and double-precision builds.
	// For float builds, regular Bound types can be used.
	frustum = WorldBoundFrustum(frustum_projection_matrix, frustum_view_matrix);
	sphere = WorldBoundSphere(Vec3(bound_sphere->position), bound_sphere->radius);
	box = WorldBoundBox(Vec3(bound_box->minimum), Vec3(bound_box->maximum));

	init_ui();
	rotator_component = ComponentSystem::get()->getComponentInWorld<Rotator>();
}

void BoundIntersection::update()
{
	// Vector of nodes where intersected ones will be stored.
	Vector<NodePtr> found;

	// The function World::getIntersection() clears the passed vector automatically,
	// so there's no need to clear it manually.
	World::getIntersection(frustum, found);
	change_color(found, bound_frustum->intersection_material);

	World::getIntersection(sphere, found);
	change_color(found, bound_sphere->intersection_material);

	World::getIntersection(box, found);
	change_color(found, bound_box->intersection_material);

	render_all_bounds();
}

void BoundIntersection::shutdown()
{
	window.shutdown();
	Visualizer::setEnabled(false);
}

void BoundIntersection::swap()
{
	for (auto &it : changed)
	{
		it.key->setMaterial(it.data, 0);
	}
	changed.clear();
}

// This function is used for demonstration purposes.
// It saves the previous material to the "changed" map
// and changes the material of all nodes of type ObjectMeshStatic.
void BoundIntersection::change_color(const Vector<NodePtr> &found, const MaterialPtr &new_material)
{
	for (int i = 0, found_size = found.size(); i < found_size; ++i)
	{
		if (found[i].isDeleted())
			continue;

		if (ObjectMeshStaticPtr mesh = checked_ptr_cast<ObjectMeshStatic>(found[i]))
		{
			changed.append(mesh, mesh->getMaterial(0));
			mesh->setMaterial(new_material, 0);
		}
	}
}

void BoundIntersection::render_all_bounds() const
{
	Visualizer::renderFrustum(frustum_projection_matrix, inverse(frustum_view_matrix), vec4_green);
	Visualizer::renderBoundSphere(sphere, Mat4_identity, vec4_red);
	Visualizer::renderBoundBox(box, Mat4_identity, vec4_blue);

	NodePtr primitives = World::getNodeByName("primitives");

	for (int i = 0; i < primitives->getNumChildren(); ++i)
	{
		if (primitives->getChild(i).isDeleted())
			return;

		Visualizer::renderNodeBoundBox(primitives->getChild(i), vec4_white);
	}
}

void BoundIntersection::init_ui()
{
	window.createWindow();

	auto parameters = window.getParameterGroupBox();
	WidgetVBoxPtr vbox = WidgetVBox::create();
	window.addFloatParameter("Rotation Speed", "Adjusts the rotation speed of the figures", 25.0f, 0.0f, 50.0f,
		[this](float new_z) { rotator_component->angular_velocity = vec3(0, 0, new_z); });
}

```

## BuoyComponent.cpp

```cpp
#include "BuoyComponent.h"
#include "BuoySample.h"

#include <UnigineGame.h>
#include <UnigineConsole.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(BuoyComponent);

using namespace Unigine;
using namespace Math;

void BuoyComponent::init()
{
	water = checked_ptr_cast<ObjectWaterGlobal>(World::getNodeByType(Node::OBJECT_WATER_GLOBAL));
	if (!water)
		Log::error("BuoyComponent::init(): can't find ObjectWaterGlobal on scene!\n");
}

void BuoyComponent::update()
{
	float mass_lerp_c = mass * 0.01f;
	if (mass == 0.0f)
		mass_lerp_c = 0.00001;

	if (water)
	{
		auto node_transform = node->getWorldTransform();

		// get water height in entity position
		Vec3 point0 = point_front_center->getWorldPosition();
		Vec3 point1 = point_back_left->getWorldPosition();
		Vec3 point2 = point_back_right->getWorldPosition();

		//create basis by 3 point
		Vec3 tmp_z = normalize(cross(normalize(point1 - point0), normalize(point2 - point0)));
		if (getAngle(vec3(tmp_z), vec3_up) > 90)
			tmp_z = -tmp_z;
		Vec3 tmp_y = normalize(point1 - point0);
		Vec3 tmp_x = tmp_y;
		cross(tmp_x, tmp_y, tmp_z).normalize();
		cross(tmp_y, tmp_z, tmp_x).normalize();
		Mat4 old_basis;
		old_basis.setTranslate(point0);
		old_basis.setColumn3(0, tmp_x);
		old_basis.setColumn3(1, tmp_y);
		old_basis.setColumn3(2, tmp_z);


		// find height of each point
		Scalar h0 = water->fetchHeight(Vec3(point0.x, point0.y, 0.0f));
		Scalar h1 = water->fetchHeight(Vec3(point1.x, point1.y, 0.0f));
		Scalar h2 = water->fetchHeight(Vec3(point2.x, point2.y, 0.0f));

		Scalar lerp_k = Game::getIFps() * Console::getFloat("global_buoyancy") / mass_lerp_c;
		Scalar diff = Math::max(Math::abs((h0 - point0.z) + (h1 - point1.z) + (h2 - point2.z)), Scalar(1.0f));
		lerp_k = clamp(lerp_k * diff, Scalar(0.0f), Scalar(1.0f));

		point0.z = lerp(point0.z, h0, lerp_k);
		point1.z = lerp(point1.z, h1, lerp_k);
		point2.z = lerp(point2.z, h2, lerp_k);

		// calculate new basis for changed point
		tmp_z = normalize(cross(normalize(point1 - point0), normalize(point2 - point0)));
		tmp_y = normalize(point1 - point0);
		cross(tmp_x, tmp_y, tmp_z).normalize();
		cross(tmp_y, tmp_z, tmp_x).normalize();
		Mat4 new_basis;
		new_basis.setTranslate(point0);
		new_basis.setColumn3(0, tmp_x);
		new_basis.setColumn3(1, tmp_y);
		new_basis.setColumn3(2, tmp_z);

		// calculate translation from old_basis to new_basis
		Mat4 translation_basis, new_transform;
		mul(translation_basis, new_basis, inverse(old_basis));

		// apply transformation to node_transform
		mul(new_transform, translation_basis, node_transform);

		node->setWorldTransform(new_transform);
	}
}

```

## BuoySample.cpp

```cpp
#include "BuoySample.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(BuoySample);

using namespace Unigine;
using namespace Math;


ConsoleVariableFloat global_buoyancy("global_buoyancy", "global_buoyancy", 0, 1.0f, 0.0f, 100.0f);

void BuoySample::init()
{
	auto water_object = checked_ptr_cast<ObjectWaterGlobal>(water.get());
	if (water_object)
	{
		water_object->setFetchSteepnessQuality(ObjectWaterGlobal::STEEPNESS_QUALITY_HIGH);
		water_object->setFetchAmplitudeThreshold(0.001f);
	}

	sample_description_window.createWindow();

	std::function<void(float)> callback_ = [this](float new_value) {
		Console::setFloat("global_buoyancy", new_value);
	};

	sample_description_window.addFloatParameter("Buoyancy", "Change buoyancy", 0.4f, 0.f, 1.0f, callback_);

	water_object->setBeaufort(0.4f);

	callback_ = [this](float new_value) {
		auto water_object = checked_ptr_cast<ObjectWaterGlobal>(water.get());
		if (water_object)
			water_object->setBeaufort(new_value);
	};

	sample_description_window.addFloatParameter("Beaufort", "Change beaufort", 0.f, 0.f, 12.f, callback_);
}

void BuoySample::shutdown()
{
	sample_description_window.shutdown();
}

```

## BuoyancyPhysics.cpp

```cpp
#include "BuoyancyPhysics.h"

#include <UnigineNode.h>
#include <UnigineVisualizer.h>
#include <UnigineWorld.h>

REGISTER_COMPONENT(BuoyancyPhysics);

using namespace Unigine;
using namespace Math;

void BuoyancyPhysics::init()
{
	water = checked_ptr_cast<ObjectWaterGlobal>(
		World::getNodeByType(Node::TYPE::OBJECT_WATER_GLOBAL));
	if (!water)
	{
		Log::error("BuoyComponent::init: can't find ObjectWaterGlobal in world");
	}

	body_rigid = node->getObjectBodyRigid();
	if (!body_rigid)
	{
		Log::error("BuoyComponent::init: body_rigid is null");
	}

	for (int i = 0; i < body_rigid->getNumShapes(); ++i)
	{
		ShapePtr s = body_rigid->getShape(i);

		if (s->getType() == Shape::TYPE::SHAPE_BOX && String::equal(s->getName(), "volume"))
		{
			auto tmp_shape_box = checked_ptr_cast<ShapeBox>(s);
			volume_shape_box = tmp_shape_box;
			break;
		}
	}

	if (!volume_shape_box)
	{
		Log::error("BuoyComponent::init: volume_shape_box is null");
	}

	volume_parts.resize(volume_grid_size.get().x * volume_grid_size.get().y);

	if (center_of_mass_node.get() != nullptr)
	{
		body_rigid->setShapeBased(false);
		body_rigid->setCenterOfMass(static_cast<vec3>(center_of_mass_node->getPosition()));
	}
	else
	{
		Log::warning("BuoyPhysics::init : center of mass node is null");
	}

	if (debug)
	{
		Visualizer::setEnabled(true);
		Visualizer::setMode(Visualizer::MODE::MODE_ENABLED_DEPTH_TEST_DISABLED);
	}
	else
	{
		Visualizer::setEnabled(false);
	}
};

void BuoyancyPhysics::update()
{

	if (water == nullptr || body_rigid == nullptr || volume_shape_box == nullptr)
	{
		return;
	}

	size = Vec3(volume_shape_box->getSize().x / static_cast<float>(volume_grid_size.get().x),
		volume_shape_box->getSize().y / static_cast<float>(volume_grid_size.get().y),
		volume_shape_box->getSize().z);

	rotation = mat3(volume_shape_box->getTransform());

	Mat4 t = volume_shape_box->getTransform();
	Vec3 shape_size = Vec3(volume_shape_box->getSize());

	Vec3 start = t.getTranslate() - t.getAxisX() * shape_size.x * 0.5f
		- t.getAxisY() * shape_size.y * 0.5f;

	for (int i = 0; i < volume_parts.size(); ++i)
	{
		int y = i / volume_grid_size.get().x;
		int x = i % volume_grid_size.get().x;

		volume_parts[i].center = start
			+ static_cast<Vec3>(rotation.getAxisX())
				* (static_cast<float>(x) * size.x + getHalfWidth())
			+ static_cast<Vec3>(rotation.getAxisY())
				* (static_cast<float>(y) * size.y + getHalfDepth());
	}

	for (int i = 0; i < volume_parts.size(); ++i)
	{
		float h = water->fetchHeight(Vec3(getAnchorPoint(volume_parts[i].center).x,
			getAnchorPoint(volume_parts[i].center).y, 0.0f));

		if (getAnchorPoint(volume_parts[i].center).z < h)
		{
			volume_parts[i].water_height
				= Math::clamp(h - static_cast<float>(getAnchorPoint(volume_parts[i].center).z),
					0.0f, static_cast<float>(size.z));
		}
		else
		{
			volume_parts[i].water_height = 0.0f;
		}
	}
	if (debug)
	{
		for (int i = 0; i < volume_parts.size(); ++i)
		{
			Mat4 transform;
			transform.set(rotation, volume_parts[i].center);
			Visualizer::renderPoint3D(getAnchorPoint(volume_parts[i].center), 0.3f, vec4_white);
			Vec3 volume_size = Vec3(size.x, size.y, volume_parts[i].water_height);
			Mat4 volume_transform = Mat4(rotation,
				getAnchorPoint(volume_parts[i].center)
					+ static_cast<Vec3>(rotation.getAxisZ()) * volume_size.z * 0.5f);
			if (isUnderWater(volume_parts[i].water_height))
			{
				Visualizer::renderVector(getAnchorPoint(volume_parts[i].center),
					static_cast<Vec3>(getAnchorPoint(volume_parts[i].center)
						+ static_cast<Vec3>(rotation.getAxisZ()) * volume_size.z),
					vec4_red);
				Visualizer::renderBox(static_cast<vec3>(volume_size), volume_transform,
					vec4(0.0f, 0.0f, 1.f, 1.f));
			}
		}
	}
}

void BuoyancyPhysics::update_physics()
{
	if (!water || !body_rigid || !volume_shape_box)
	{
		return;
	}

	float water_volume = 0.0f;
	float all_volume = volume_shape_box->getSize().x * volume_shape_box->getSize().y
		* volume_shape_box->getSize().z;

	for (int i = 0; i < volume_parts.size(); ++i)
	{
		if (!isUnderWater(volume_parts[i].water_height))
		{
			continue;
		}

		Vec3 force = -static_cast<Vec3>(Unigine::Physics::getGravity())
			* getWaterVolume(volume_parts[i].water_height) * buoyancy;

		force /= static_cast<float>(volume_parts.size());

		body_rigid->addForce(static_cast<vec3>(force));

		Vec3 radius = Vec3(getAnchorPoint(volume_parts[i].center)
			+ static_cast<Vec3>(rotation.getAxisZ()) * volume_parts[i].water_height
			- body_rigid->getWorldCenterOfMass());

		Vec3 torque = cross(radius, force);
		body_rigid->addTorque(static_cast<vec3>(torque));

		water_volume += static_cast<float>(getWaterVolume(volume_parts[i].water_height));
	}

	float coeff = 0.0f;
	if (all_volume > 0.0f)
	{
		coeff = water_volume / all_volume;
	}

	body_rigid->addLinearImpulse(
		(-body_rigid->getLinearVelocity() * water_linear_damping * coeff * body_rigid->getMass()));

	body_rigid->addAngularImpulse(
		(-body_rigid->getAngularVelocity() * water_angular_damping * coeff)
		* inverse(body_rigid->getIWorldInertia()));
}

void BuoyancyPhysics::shutdown()
{
	Visualizer::setEnabled(false);
}

Scalar BuoyancyPhysics::getHalfWidth()
{
	return size.x * static_cast<Scalar>(0.5);
}

Scalar BuoyancyPhysics::getHalfDepth()
{
	return size.y * static_cast<Scalar>(0.5);
}

Scalar BuoyancyPhysics::getHalfHeight()
{
	return size.z * static_cast<Scalar>(0.5);
}

Unigine::Math::Vec3 BuoyancyPhysics::getAnchorPoint(Unigine::Math::Vec3 center)
{
	return center - static_cast<Vec3>(rotation.getAxisZ()) * getHalfHeight();
}

bool BuoyancyPhysics::isUnderWater(float water_height)
{
	return water_height != 0.0f;
}

Scalar BuoyancyPhysics::getWaterVolume(float water_height)
{
	return size.x * size.y * water_height;
}

```

## BuoyancyPhysicsSample.cpp

```cpp
#include "BuoyancyPhysicsSample.h"

REGISTER_COMPONENT(BuoyancyPhysicsSample);

using namespace Unigine;

void BuoyancyPhysicsSample::init()
{
	sample_description_window.createWindow();

	waves = getComponent<Waves>(waves_node.get());
	sample_description_window.addFloatParameter("Beaufort", "beaufort", 0.f, 0.f, 8.f,
		[this](float v) { waves->setBeaufort(v); });
}

void BuoyancyPhysicsSample::shutdown()
{
	sample_description_window.shutdown();
}

```

## Button.cpp

```cpp
#include "Button.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(Button);

using namespace Unigine;
using namespace Math;

void Button::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_button = WidgetButton::create(gui, text.get());

	gui->addChild(widget_button, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_button->setPosition(position.get().x, position.get().y);
	widget_button->setWidth(size.get().x);
	widget_button->setHeight(size.get().y);
	widget_button->setFontSize(font_size.get());

	widget_button->getEventClicked().connect(*this, []() {
		Console::onscreenMessageLine("Button Clicked!");
		});

	Console::setOnscreen(true);
}

void Button::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_button);

		widget_button.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## ButtonReactionSample.cpp

```cpp
#include "ButtonReactionSample.h"

REGISTER_COMPONENT(ButtonReactionSample);

using namespace Unigine;
using namespace Math;

void ButtonReactionSample::init()
{
	interactable_comp = ComponentSystem::get()->getComponent<Interactable>(interatable_node);

	initial_position = node->getPosition();
	initial_rotation = node->getRotation();

	final_rotation = initial_rotation * quat(rotation.get().x, rotation.get().y, rotation.get().z);
}

void ButtonReactionSample::update()
{
	if (!interactable_comp) return;

	float value = interactable_comp->getValue();

	quat new_rotation = slerp(initial_rotation, final_rotation, value);
	Vec3 new_position = lerp(initial_position, initial_position + (Vec3)position, value);

	node->setTransform(translate(new_position) * (Mat4)rotate(new_rotation));
}

```

## CADLikeView.cpp

```cpp
#include "CADLikeView.h"

#include "ViewportCube.h"

#include <UnigineConsole.h>
#include <UniginePlayers.h>
#include <UnigineViewport.h>
#include <UnigineWindowManager.h>

REGISTER_COMPONENT(CADLikeView);

using namespace Unigine;
using namespace Math;

void CADLikeView::init()
{
	Render::setEnabled(false);

	camera_top = checked_ptr_cast<Player>(player_top.get())->getCamera();
	camera_perspective = checked_ptr_cast<Player>(player_perspective.get())->getCamera();
	camera_side = checked_ptr_cast<Player>(player_side.get())->getCamera();
	camera_front = checked_ptr_cast<Player>(player_front.get())->getCamera();

	set_ortho_projection(ortho_width.get(), ortho_height.get());
	Input::setMouseHandle(Input::MOUSE_HANDLE_USER);

	create_viewports();
	create_viewcubes();
	update_viewcubes_position();
}

void CADLikeView::create_viewports()
{
	const ivec2 window_size = WindowManager::getMainWindow()->getSize();

	current_width = window_size.x;
	current_height = window_size.y;

	const int viewport_width = current_width / 2;
	const int viewport_height = current_height / 2;

	const auto gui = Gui::getCurrent();

	viewport_top = WidgetSpriteViewport::create(gui, viewport_width, viewport_height);
	viewport_perspective = WidgetSpriteViewport::create(gui, viewport_width, viewport_height);
	viewport_side = WidgetSpriteViewport::create(gui, viewport_width, viewport_height);
	viewport_front = WidgetSpriteViewport::create(gui, viewport_width, viewport_height);

	lay = WidgetGridBox::create(gui, 2);
	gui->addChild(lay, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND | Gui::ALIGN_EXPAND);

	lay->addChild(viewport_top);
	lay->addChild(viewport_perspective);
	lay->addChild(viewport_side);
	lay->addChild(viewport_front);
}

void CADLikeView::set_ortho_projection(const float width, const float height)
{
	constexpr float z_near = 0.001f;
	constexpr float z_far = 1000.f;
	const mat4 ortho_projection = ortho(-width / 2, width / 2, -height / 2, height / 2, z_near,
		z_far);
	camera_top->setProjection(ortho_projection);
	camera_side->setProjection(ortho_projection);
	camera_front->setProjection(ortho_projection);
}

void CADLikeView::create_viewcubes()
{
	viewcube_top = std::make_unique<ViewportCube>(checked_ptr_cast<Player>(player_top.get()),
		ortho_width, ortho_height);
	viewcube_perspective = std::make_unique<ViewportCube>(
		checked_ptr_cast<Player>(player_perspective.get()), ortho_width, ortho_height);
	viewcube_side = std::make_unique<ViewportCube>(checked_ptr_cast<Player>(player_side.get()),
		ortho_width, ortho_height);
	viewcube_front = std::make_unique<ViewportCube>(checked_ptr_cast<Player>(player_front.get()),
		ortho_width, ortho_height);

	viewcube_top->setChangeProjectionEnabled(false);
	viewcube_side->setChangeProjectionEnabled(false);
	viewcube_front->setChangeProjectionEnabled(false);

	const Vec3 centering_position = figure.get()->getHierarchyWorldBoundSphere().center;
	viewcube_top->setCenteringPosition(centering_position);
	viewcube_perspective->setCenteringPosition(centering_position);
	viewcube_side->setCenteringPosition(centering_position);
	viewcube_front->setCenteringPosition(centering_position);

	const Scalar min_distance_multiplier = 2.0f;
	const Scalar min_distance = figure.get()->getHierarchyWorldBoundSphere().radius
		* min_distance_multiplier;
	viewcube_top->setMinimalDistance(min_distance);
	viewcube_perspective->setMinimalDistance(min_distance);
	viewcube_side->setMinimalDistance(min_distance);
	viewcube_front->setMinimalDistance(min_distance);
}

void CADLikeView::update_viewcubes_position()
{
	const ivec2 cube_offset(-130, 10);

	viewcube_top->setViewcubePosition(ivec2(current_width / 2, 0) + cube_offset);
	viewcube_perspective->setViewcubePosition(ivec2(current_width, 0) + cube_offset);
	viewcube_side->setViewcubePosition(ivec2(current_width / 2, current_height / 2) + cube_offset);
	viewcube_front->setViewcubePosition(ivec2(current_width, current_height / 2) + cube_offset);
}

void CADLikeView::update()
{
	if (!WindowManager::getMainWindow())
		return;

	update_screen_size();
	update_input();

	viewport_top->setCamera(camera_top);
	viewport_perspective->setCamera(camera_perspective);
	viewport_side->setCamera(camera_side);
	viewport_front->setCamera(camera_front);

	viewcube_top->update();
	viewcube_perspective->update();
	viewcube_side->update();
	viewcube_front->update();
}

void CADLikeView::update_screen_size()
{
	const ivec2 window_size = WindowManager::getMainWindow()->getSize();

	bool need_update_viewcubes = false;

	const int window_width = window_size.x;
	if (window_width != current_width)
	{
		need_update_viewcubes = true;
		current_width = window_width;
		const int viewport_width = current_width / 2;
		viewport_top->setTextureWidth(viewport_width);
		viewport_perspective->setTextureWidth(viewport_width);
		viewport_side->setTextureWidth(viewport_width);
		viewport_front->setTextureWidth(viewport_width);
	}

	const int window_height = window_size.y;
	if (window_height != current_height)
	{
		need_update_viewcubes = true;
		current_height = window_height;
		const int viewport_height = window_height / 2;
		viewport_top->setTextureHeight(viewport_height);
		viewport_perspective->setTextureHeight(viewport_height);
		viewport_side->setTextureHeight(viewport_height);
		viewport_front->setTextureHeight(viewport_height);
	}

	if (need_update_viewcubes)
	{
		update_viewcubes_position();
	}
}

void CADLikeView::update_input()
{
	if (Console::isActive())
		return;

	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT))
	{
		set_dragged_player();
	}

	if (Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT))
	{
		checked_ptr_cast<Player>(player_perspective.get())->setControlled(false);
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
		dragged_player = PlayerPtr();
	}

	if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON_LEFT))
	{
		if (dragged_player)
		{
			const int viewport_width = current_width / 2;
			const int viewport_height = current_height / 2;

			const Vec2 normalized_delta = Vec2(Input::getMouseDeltaPosition())
				/ Vec2((float)viewport_width, (float)viewport_height);
			Vec2 delta_pos = normalized_delta
				* Vec2((itof(current_width) / current_height) * ortho_width, ortho_height);
			delta_pos.x *= -1;
			dragged_player->translate({delta_pos, 0});
		}
	}
}

void CADLikeView::set_dragged_player()
{
	if (viewcube_top->isHovered() || viewcube_perspective->isHovered() || viewcube_side->isHovered()
		|| viewcube_front->isHovered())
	{
		return;
	}

	const int viewport_width = current_width / 2;
	const int viewport_height = current_height / 2;

	const ivec2 mouse_pos = Input::getMousePosition()
		- WindowManager::getMainWindow()->getClientPosition();

	if (checkRange(mouse_pos.x, 0, viewport_width))
	{
		if (checkRange(mouse_pos.y, 0, viewport_height))
		{
			dragged_player = checked_ptr_cast<Player>(player_top.get());
		}
		else if (checkRange(mouse_pos.y, viewport_height, current_height))
		{
			dragged_player = checked_ptr_cast<Player>(player_side.get());
		}
	}
	else if (checkRange(mouse_pos.x, viewport_width, current_width))
	{
		if (checkRange(mouse_pos.y, 0, viewport_height))
		{
			Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);
			checked_ptr_cast<Player>(player_perspective.get())->setControlled(true);
		}
		else if (checkRange(mouse_pos.y, viewport_height, current_height))
		{
			dragged_player = checked_ptr_cast<Player>(player_front.get());
		}
	}
}

void CADLikeView::shutdown()
{
	Render::setEnabled(true);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	viewcube_top.reset();
	viewcube_perspective.reset();
	viewcube_side.reset();
	viewcube_front.reset();

	lay.deleteLater();
	viewport_top.deleteLater();
	viewport_perspective.deleteLater();
	viewport_side.deleteLater();
	viewport_front.deleteLater();
}

```

## CPUShaderSample.cpp

```cpp
#include "CPUShaderSample.h"

#include <UnigineGame.h>
#include <UnigineProfiler.h>

REGISTER_COMPONENT(CPUShaderSample)

using namespace Unigine;
using namespace Math;


constexpr int SIZE{30};

void CPUShaderSample::AsyncCluster::update(const ObjectMeshClusterPtr &cluster_)
{
	UNIGINE_PROFILER_FUNCTION;

	random.setSeed(seed);
	int num = 0;

	for (int y = -SIZE; y <= SIZE; y++)
	{
		for (int x = -SIZE; x <= SIZE; x++)
		{
			const Scalar rand_timer = timer + random.getFloat(0, 100.0);
			auto pos = Vec3(static_cast<Scalar>(x), static_cast<Scalar>(y),
						   Math::cos(rand_timer) * 50.f)
				+ offset;
			transforms[num] = translate(pos) * rotateZ(rand_timer * 360.f)
				* scale(static_cast<Scalar>(5.0f));
			num++;
		}
	}

	cluster_->createMeshes(transforms);
}

void CPUShaderSample::AsyncCluster::swap()
{
	UNIGINE_PROFILER_FUNCTION;

	timer += Game::getIFps();

	// TODO fix workaround (streaming issue)
	is_need_update = cluster->isVisibleCamera() || cluster->isVisibleShadow() || frames < 60;
	if (frames < 60)
	{
		frames++;
	}


	if (!is_need_update)
	{
		return;
	}

	cluster->swap(cluster_async);

	cluster->setEnabled(true);
	cluster_async->setEnabled(false);
}

void CPUShaderSample::AsyncCluster::update()
{
	UNIGINE_PROFILER_FUNCTION;
	if (is_need_update)
	{
		update(cluster_async);
	}
}

void CPUShaderSample::UpdateClusterCPUShader::process(int thread_num, int threads_count)
{
	UNIGINE_PROFILER_FUNCTION;

	while (true)
	{
		const int num = counter.fetch_add(1);
		if (num >= clusters.size())
		{
			break;
		}
		clusters[num].update();
	}
}


// we call this method ourselves
// runAsync will wait in Engine::swap()
// runSync will wait here and stop execution
void CPUShaderSample::UpdateClusterCPUShader::run()
{
	UNIGINE_PROFILER_FUNCTION;

	for (auto &c : clusters)
	{
		c.swap();
	}

	counter = 0;
	runAsync();
}

void CPUShaderSample::init()
{
	shader = std::make_unique<UpdateClusterCPUShader>();
	Vector<AsyncCluster> &clusters = shader->clusters;
	clusters.resize(64);

	const int num_objects = pow2(static_cast<int>(SIZE * 2 + 1));

	for (int i = 0; i < shader->clusters.size(); i++)
	{
		AsyncCluster &c = clusters[i];

		const String mesh_path = mesh.get();
		c.cluster = ObjectMeshCluster::create(mesh_path);
		c.cluster->setMaterialParameterFloat4("albedo_color", Game::getRandomColor(), 0);
		c.cluster_async = static_ptr_cast<ObjectMeshCluster>(c.cluster->clone());

		c.cluster->setEnabled(true);
		c.cluster_async->setEnabled(false);

		c.is_need_update = true;

		const float x = SIZE * 3.0f * getBit(i, 0) + SIZE * 6.0f * getBit(i, 2)
			+ SIZE * 12.0f * getBit(i, 4);
		const float y = SIZE * 3.0f * getBit(i, 1) + SIZE * 6.0f * getBit(i, 3)
			+ SIZE * 12.0f * getBit(i, 5);

		c.offset = Vec3(x, y, 0);
		c.seed = i;

		c.transforms.resize(num_objects);

		c.update(c.cluster);

		clusters[i] = c;
	};
	Log::message("Num objects %d", num_objects * shader->clusters.size());
}

void CPUShaderSample::swap() const
{
	// function will stop its execution only in next swap
	shader->run();
}

```

## Callbacks.cpp

```cpp
#include "Callbacks.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(Callbacks)

using namespace Unigine;
using namespace Unigine::Math;

namespace
{
static void function_0()
{
	Log::message("function_0(): called\n");
}

static void function_1(int a)
{
	Log::message("function_1(%d): called\n", a);
}

static void function_2(int a, int b)
{
	Log::message("function_2(%d,%d): called\n", a, b);
}

static void function_3(int a, int b, int c)
{
	Log::message("function_3(%d,%d,%d): called\n", a, b, c);
}

static void function_4(int a, int b, int c, int d)
{
	Log::message("function_4(%d,%d,%d,%d): called\n", a, b, c, d);
}
} // namespace

void Callbacks::init()
{
	Console::setOnscreen(true);

	// create callbacks and bind some default values
	CallbackBase *callback_func_0 = MakeCallback(function_0);
	CallbackBase *callback_method_0 = MakeCallback(this, &Callbacks::method_0);
	CallbackBase *callback_func_1 = MakeCallback(function_1, 1);
	CallbackBase *callback_method_1 = MakeCallback(this, &Callbacks::method_1, 1);
	CallbackBase *callback_func_2 = MakeCallback(function_2, 1, 2);
	CallbackBase *callback_method_2 = MakeCallback(this, &Callbacks::method_2, 1, 2);
	CallbackBase *callback_func_3 = MakeCallback(function_3, 1, 2, 3);
	CallbackBase *callback_method_3 = MakeCallback(this, &Callbacks::method_3, 1, 2, 3);
	CallbackBase *callback_func_4 = MakeCallback(function_4, 1, 2, 3, 4);
	CallbackBase *callback_method_4 = MakeCallback(this, &Callbacks::method_4, 1, 2, 3, 4);

	// run callbacks
	Log::message("\n");
	callback_func_0->run();
	callback_method_0->run();

	Log::message("\n");
	callback_func_1->run();
	callback_func_1->run(-1);
	callback_method_1->run();
	callback_method_1->run(-1);

	Log::message("\n");
	callback_func_2->run();
	callback_func_2->run(-1);
	callback_func_2->run(-1, -2);
	callback_method_2->run();
	callback_method_2->run(-1);
	callback_method_2->run(-1, -2);

	Log::message("\n");
	callback_func_3->run();
	callback_func_3->run(-1);
	callback_func_3->run(-1, -2);
	callback_func_3->run(-1, -2, -3);
	callback_method_3->run();
	callback_method_3->run(-1);
	callback_method_3->run(-1, -2);
	callback_method_3->run(-1, -2, -3);

	Log::message("\n");
	callback_func_4->run();
	callback_func_4->run(-1);
	callback_func_4->run(-1, -2);
	callback_func_4->run(-1, -2, -3);
	callback_func_4->run(-1, -2, -3, -4);
	callback_method_4->run();
	callback_method_4->run(-1);
	callback_method_4->run(-1, -2);
	callback_method_4->run(-1, -2, -3);
	callback_method_4->run(-1, -2, -3, -4);

	Log::message("\n");
}

void Callbacks::shutdown()
{
	Console::setOnscreen(false);
}

void Callbacks::method_0()
{
	Log::message("Callbacks::method_0(): called\n");
}

void Callbacks::method_1(int a)
{
	Log::message("Callbacks::method_1(%d): called\n", a);
}

void Callbacks::method_2(int a, int b)
{
	Log::message("Callbacks::method_2(%d,%d): called\n", a, b);
}

void Callbacks::method_3(int a, int b, int c)
{
	Log::message("Callbacks::method_3(%d,%d,%d): called\n", a, b, c);
}

void Callbacks::method_4(int a, int b, int c, int d)
{
	Log::message("Callbacks::method_4(%d,%d,%d,%d): called\n", a, b, c, d);
}

```

## CameraShiftController.cpp

```cpp
#include "CameraShiftController.h"

#include <UnigineEngine.h>
#include <UnigineGame.h>
#include <UnigineObjects.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(CameraShiftController);

using namespace Unigine;
using namespace Math;

void CameraShiftController::init()
{
	player = checked_ptr_cast<PlayerSpectator>(node);
	if (!player)
		Log::error("CameraShiftController::init(): component node is not a PlayerSpectator!\n");

	float fov = player->getFov();

	// limit up/down camera angles to prevent two-point perspective viewing frustum eversion
	player->setMaxThetaAngle(89.0f - fov / 2.0f);
	player->setMinThetaAngle(-89.0f + fov / 2.0f);

	//	use original player for controlling and moving camera
	//	create dummy player for modifying projection matrix
	dummy_player = PlayerDummy::create();
	dummy_player->setCamera(player->getCamera()->clone());

	Engine::get()->getEventBeginRender().connect(this, &CameraShiftController::pre_render_callback);
	Engine::get()->getEventBeginSwap().connect(this, &CameraShiftController::post_render_callback);
}

void CameraShiftController::update()
{
	if (!shift_enabled || Game::getPlayer() != player)
		return;

	auto projection = player->getProjection();
	float znear = player->getZNear();

	auto dir = player->getViewDirection();

	float beta = Math::asin(dir.z);
	float bottom = znear * Math::tan(-player->getFov() * 0.5f * Consts::DEG2RAD + beta);
	float top = znear * Math::tan(player->getFov() * 0.5f * Consts::DEG2RAD + beta);

	projection.m12 = (top + bottom) / (top - bottom);
	projection.m11 = 2 * znear / (top - bottom);

	dummy_player->setProjection(projection);

	dir.z = 0;
	dummy_player->setViewDirection(dir);
	dummy_player->setWorldPosition(player->getWorldPosition());
}

void CameraShiftController::shutdown()
{
	dummy_player.deleteLater();
}

void CameraShiftController::pre_render_callback()
{
	if (shift_enabled && Game::getPlayer() == player)
	{
		Game::setPlayer(dummy_player);
		need_reset_player = true;
	}
}

void CameraShiftController::post_render_callback()
{
	if (need_reset_player)
	{
		Game::setPlayer(player);
		need_reset_player = false;
	}
}

```

## CameraTerrainFetchSample.cpp

```cpp
#include "CameraTerrainFetchSample.h"

#include <UnigineVisualizer.h>
#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(CameraTerrainFetchSample)

void CameraTerrainFetchSample::init()
{
	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);

	main_player = checked_ptr_cast<Player>(node);
	if (!main_player)
		Log::error("CameraTerrainFetchSample::init(): CameraTerrainFetchSample must be assigned to a player node!\n");
}

void CameraTerrainFetchSample::update()
{
	if (!main_player)
		return;

	Vec3 a, b;
	auto main_window = WindowManager::getMainWindow();
	auto mouse = Input::getMousePosition();

	main_player->getDirectionFromMainWindow(a, b, mouse.x, mouse.y);

	if (!fetch)
	{
		fetch = LandscapeFetch::create();

		fetch->setUsesHeight(true);
		fetch->setUsesNormal(true);
		fetch->setUsesAlbedo(true);

		for (int i = 0; i < num_masks; i += 1)
			fetch->setUsesMask(i, true);

		fetch->intersectionAsync(a, a + ((b - a) * Game::getPlayer()->getZFar()));
	}

	else
	{
		if (fetch->isAsyncCompleted())
		{
			if (fetch->isIntersection())
			{
				auto terrain = Landscape::getActiveTerrain();
				auto point = fetch->getPosition();
				auto height = fetch->getHeight();
				auto vector_length = 10.f;
				StringStack<> info;

				info += String::format("height : %.3f\n", height);
				info += "masks: \n";

				for (int i = 0; i < num_masks; i++)
					info += String::format("    %s: %.2f\n", terrain->getDetailMask(i)->getName(), fetch->getMask(i));

				Visualizer::renderVector(point, point + Vec3(fetch->getNormal() * vector_length), vec4_white, .25f);
				Visualizer::renderSolidSphere(1.f, translate(point), vec4_white);
				Visualizer::renderMessage3D(point, vec3(1.f, 1.f, 0.f), info.get(), vec4_green, 1);
			}

			else
				Visualizer::renderMessage3D(b, vec3(1.f, 1.f, 0), "Out of terrain.", vec4_red, 1);

			fetch->intersectionAsync(a, a + ((b - a) * Game::getPlayer()->getZFar()));
		}
	}
}

void CameraTerrainFetchSample::shutdown()
{
	Visualizer::setEnabled(visualizer_enabled);
	fetch = nullptr;
}

```

## CameraToTexture.cpp

```cpp
#include "CameraToTexture.h"

#include <UnigineTextures.h>
#include <UnigineViewport.h>

REGISTER_COMPONENT(CameraToTexture);

using namespace Unigine;
using namespace Math;

void CameraToTexture::init()
{
	player = checked_ptr_cast<Player>(player_camera.get());
	texture = Texture::create();
	texture->create2D(256, 256, Texture::FORMAT_RG11B10F,
		Texture::SAMPLER_FILTER_LINEAR | Texture::SAMPLER_ANISOTROPY_16
			| Texture::FORMAT_USAGE_RENDER);
	viewport = Viewport::create();
	auto obj = checked_ptr_cast<Object>(node);
	auto mat = obj->getMaterial(0);
	mat = mat->inherit();
	mat->setTexture(mat->findTexture("albedo"), texture);
	mat->setParameterFloat4("uv_transform", vec4(-1.f, Render::isFlipped() ? -1.f : 1.f, 0.f, 0.f));
	obj->setMaterial(mat, 0);
}

void CameraToTexture::update()
{
	viewport->renderTexture2D(player->getCamera(), texture);
}

```

## Canvas.cpp

```cpp
#include "Canvas.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(Canvas);

using namespace Unigine;
using namespace Math;

void Canvas::init()
{
	// get main window
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();

	// get main window gui
	GuiPtr gui = main_window->getGui();

	// create canvas
	canvas = WidgetCanvas::create(gui);

	canvas->setLineColor(create_line(0, 200.0f, 200.0f, 100.0f, 3, 360.0f), vec4(0.0f, 0.0f, 1.0f, 1.0f));
	canvas->setLineColor(create_line(0, 200.0f, 200.0f, 100.0f, 4, 360.0f), vec4(0.0f, 1.0f, 0.0f, 1.0f));
	canvas->setLineColor(create_line(0, 200.0f, 200.0f, 100.0f, 5, 360.0f), vec4(1.0f, 0.0f, 0.0f, 1.0f));

	canvas->setLineColor(create_line(0, 800.0f, 400.0f, 100.0f, 16, 360.0f * 9.0f), vec4(1.0f, 1.0f, 1.0f, 1.0f));

	canvas->setPolygonColor(create_polygon(0, 600.0f, 200.0f, 100.0f, 6, 360.0f), vec4(1.0f, 0.0f, 0.0f, 1.0f));
	canvas->setPolygonColor(create_polygon(1, 600.0f, 200.0f, 100.0f, 3, 360.0f), vec4(0.0f, 0.0f, 1.0f, 1.0f));

	canvas->setPolygonColor(create_polygon(0, 400.0f, 400.0f, 100.0f, 8, 360.0f), vec4(0.0f, 1.0f, 0.0f, 1.0f));
	canvas->setPolygonColor(create_polygon(1, 400.0f, 400.0f, 100.0f, 4, 360.0f), vec4(1.0f, 0.0f, 0.0f, 1.0f));

	create_text(0, 200.0f - 64.0f, 200.0f - 30.0f, "This is C++ canvas text");

	main_window->addChild(canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);
}

void Canvas::update()
{
	GuiPtr gui = WindowManager::getMainWindow()->getGui();

	float fov = 2.0f;
	float time = Game::getTime();
	float x = gui->getWidth() / 2.0f;
	float y = gui->getHeight() / 2.0f;
	canvas->setTransform(translate(vec3(x, y, 0.0f)) * perspective(fov, 1.0f, 0.01f, 100.0f) * rotateY(sinf(time)) * rotateX(cosf(time * 0.5f)) * translate(vec3(-x, -y, -1.0f / tanf(fov * Consts::DEG2RAD * 0.5f))));
}

void Canvas::shutdown()
{
	canvas.deleteLater();
}

int Canvas::create_line(int order, float x, float y, float radius, int num, float angle)
{
	int line = canvas->addLine(order);
	for (int i = 0; i <= num; i++)
	{
		float s = Unigine::Math::sin(angle / num * Consts::DEG2RAD * i) * radius + x;
		float c = Unigine::Math::cos(angle / num * Consts::DEG2RAD * i) * radius + y;
		canvas->addLinePoint(line, vec3(s, c, 0.0f));
	}
	return line;
}

int Canvas::create_polygon(int order, float x, float y, float radius, int num, float angle)
{
	int polygon = canvas->addPolygon(order);
	for (int i = 0; i < num; i++)
	{
		float s = Unigine::Math::sin(angle / num * Consts::DEG2RAD * i) * radius + x;
		float c = Unigine::Math::cos(angle / num * Consts::DEG2RAD * i) * radius + y;
		canvas->addPolygonPoint(polygon, vec3(s, c, 0.0f));
	}
	return polygon;
}

int Canvas::create_text(int order, float x, float y, Unigine::String string)
{
	int text = canvas->addText(order);
	canvas->setTextPosition(text, vec2(x, y));
	canvas->setTextText(text, string.getRaw());
	return text;
}

```

## Car.cpp

```cpp
#include "Car.h"
#include <UnigineGame.h>

REGISTER_COMPONENT(Car);

using namespace Unigine;
using namespace Math;

void Car::setVelocity(float v)
{
	if (v > 0.1)
	{
		current_torque = defaultTorque;
		current_velocity = v * maxVelocity;
	}
	else
	{
		current_velocity = 0;
		current_torque = 0;
	}
}

void Car::setAngle(float a)
{
	if (Math::abs(a) > 0.2)
	{
		current_turn_angle = -1 * a * max_turn_angle;
	}
	else
	{
		current_turn_angle = 0.0f;
	}
}

void Car::setBrake(float b)
{
	if (b > 0.1)
	{
		joint_wheel_bl->setAngularDamping(10000.0f);
		joint_wheel_br->setAngularDamping(10000.0f);
	}
	else
	{
		joint_wheel_bl->setAngularDamping(0.0f);
		joint_wheel_br->setAngularDamping(0.0f);
	}
}

void Car::respawn()
{
	node->setTransform(translate(Vec3_up * 1.0) * rotate(Vec3_up, 90.0));
}

void Car::init()
{
	if (wheelBl)
		joint_wheel_bl = checked_ptr_cast<JointWheel>(wheelBl->getObjectBody()->getJoint(0));

	if (wheelBr)
		joint_wheel_br = checked_ptr_cast<JointWheel>(wheelBr->getObjectBody()->getJoint(0));

	if (wheelFl)
		joint_wheel_fl = checked_ptr_cast<JointWheel>(wheelFl->getObjectBody()->getJoint(0));

	if (wheelFr)
		joint_wheel_fr = checked_ptr_cast<JointWheel>(wheelFr->getObjectBody()->getJoint(0));

	auto player = checked_ptr_cast<PlayerPersecutor>(Game::getPlayer());
	player->setFixed(1);
	player->setTarget(node);
	player->setMinDistance(8.0f);
	player->setMaxDistance(12.0f);
	player->setPosition(Vec3(10.0f, 0.0f, 6.0f));
}

void Car::update()
{
	current_velocity = clamp(current_velocity, 0.0f, maxVelocity);
	current_turn_angle = clamp(current_turn_angle, -max_turn_angle, max_turn_angle);

	float angle_0 = current_turn_angle;
	float angle_1 = current_turn_angle;
	if (Math::abs(current_turn_angle) > Consts::EPS)
	{
		float radius = carBase / Math::tan(current_turn_angle * Consts::DEG2RAD);
		float radius_0 = radius - carWidth * 0.5f;
		float radius_1 = radius + carWidth * 0.5f;

		angle_0 = Math::atan(carBase / radius_0) * Consts::RAD2DEG;
		angle_1 = Math::atan(carBase / radius_1) * Consts::RAD2DEG;
	}

	joint_wheel_fr->setAxis10(Math::rotateZ(angle_1).getColumn3(0));
	joint_wheel_fl->setAxis10(Math::rotateZ(angle_0).getColumn3(0));
}

void Car::updatePhysics()
{
	joint_wheel_fl->setAngularVelocity(current_velocity);
	joint_wheel_fr->setAngularVelocity(current_velocity);

	joint_wheel_fl->setAngularTorque(current_torque);
	joint_wheel_fr->setAngularTorque(current_torque);
}

```

## CarControl.cpp

```cpp
#include "CarControl.h"
#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineInput.h>

REGISTER_COMPONENT(CarControl);

using namespace Unigine;
using namespace Math;

void CarControl::init()
{
	init_input_keys();
}


void CarControl::init_input_keys()
{
	if (!use_arrows.get())
	{
		key_forward = Input::KEY_W;
		key_back = Input::KEY_S;
		key_left = Input::KEY_A;
		key_right = Input::KEY_D;

	} else
	{
		key_forward = Input::KEY_UP;
		key_back = Input::KEY_DOWN;
		key_left = Input::KEY_LEFT;
		key_right = Input::KEY_RIGHT;
	}
}

void CarControl::update()
{
	if (Console::isActive())
		return;
	int fb = get_movement_command();

	int rl = get_rotate_command();

	float ifps = Game::getIFps();
	forward = lerp(forward, Scalar(max_speed.get() * fb), Scalar(ifps * acceleration_factor.get()));
	rotation = lerp(rotation, float(max_rotation.get() * rl), ifps);

	node->rotate(0, 0, rotation * ifps);
	node->translate(0, forward * ifps, 0);
}

int CarControl::get_movement_command() const
{
	int fb = 0;
	if (Input::isKeyPressed(key_forward))
	{
		fb = 1;
	} else if (Input::isKeyPressed(key_back))
	{
		fb = -1;
	}
	return fb;
}

int CarControl::get_rotate_command() const
{
	int rl = 0;
	if (Input::isKeyPressed(key_left))
	{
		rl = 1;
	} else if (Input::isKeyPressed(key_right))
	{
		rl = -1;
	}
	return rl;
}

void CarControl::shutdown()
{
}
```

## CatDemo.cpp

```cpp
#include "CatDemo.h"

#include "MotionMode.h"
#include "SpringRegular.h"

#include <UnigineWidgets.h>

REGISTER_COMPONENT(CatDemo);

using namespace Unigine;
using namespace Math;

void CatDemo::initGUI(const WidgetWindowPtr &window)
{
	demo_box = WidgetGroupBox::create("Demo", 8, 4);
	auto demo_label = WidgetLabel::create("Choose animation type for the cat:");
	demo_box->addChild(demo_label, Gui::ALIGN_LEFT);

	// adding cat's movement modes to the demo combobox
	for (const auto &c : cat_components)
		demo_combo->addItem(c->getNode()->getName());
	demo_combo->setCurrentItem(mode);
	demo_combo->getEventChanged().connect(this, &CatDemo::update_cat_mode);
	demo_combo->setEnabled(0);
	demo_combo->arrange();
	demo_box->addChild(demo_combo, Gui::ALIGN_LEFT);

	window->addChild(demo_box, Gui::ALIGN_LEFT);
}

void CatDemo::init()
{
	if (!laserNode)
		Log::error("CatGame::init(): cannot find laserNode!\n");
	if (!catNode)
		Log::error("CatGame::init(): cannot find catNode!\n");

	if (!demo_combo)
		demo_combo = WidgetComboBox::create();

	// collect cat's movement modes to a vector
	int num_demo_modes = node->getNumChildren();
	cat_components.allocate(num_demo_modes);

	for (int i = 0; i < num_demo_modes; i++)
	{
		NodePtr mode = node->getChild(i);
		auto comp = ComponentSystem::get()->getComponent<MotionMode>(mode);
		if (!comp)
			continue;
		comp->targetNode = laserNode;
		comp->persecutorNode = catNode;
		comp->setEnabled(false);
		cat_components.emplace_back(comp);
	}
}

void CatDemo::on_enable()
{
	demo_combo->setEnabled(1);
	update_cat_mode();
	demo_box->setHidden(false);
}

void CatDemo::on_disable()
{
	cat_components[mode]->setEnabled(0);
	demo_combo->setEnabled(0);
	demo_box->setHidden(true);
}

void CatDemo::update_cat_mode()
{
	auto new_mode = demo_combo->getCurrentItem();
	switch_cat_mode(new_mode);
}

void CatDemo::switch_cat_mode(int new_mode)
{
	cat_components[mode]->setEnabled(false);
	mode = new_mode;
	cat_components[mode]->setEnabled(true);
}

void CatDemo::shutdown()
{
	shutdown_gui();
}

void CatDemo::shutdown_gui()
{
	demo_box.deleteLater();
	demo_combo.deleteLater();
}

```

## CatGame.cpp

```cpp
#include "CatGame.h"

#include "Laser.h"
#include "SpringRegular.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(CatGame);

using namespace Unigine;
using namespace Math;

void CatGame::initGUI(const Unigine::WidgetWindowPtr &window)
{
	game_box = WidgetGroupBox::create("Game", 8, 4);
	game_label = WidgetLabel::create(
		String::format("Don't let the cat catch the laser pointer!\nTime: %.2f", timer));
	game_label->setFontVSpacing(4);
	game_box->addChild(game_label, Gui::ALIGN_LEFT);
	window->addChild(game_box, Gui::ALIGN_LEFT);
}

void CatGame::init()
{
	laser_component = ComponentSystem::get()->getComponent<Laser>(laserNode.get());
	if (!laser_component)
		Log::error("CatGame::init(): cannot find Laser component!\n");
	cat_mode = ComponentSystem::get()->getComponent<SpringRegular>(catMode.get());
	if (!cat_mode)
		Log::error("CatGame::init(): cannot find SpringRegular component!\n");
}

void CatGame::on_enable()
{
	catched = false;
	cat_mode->setEnabled(1);
	timer = 0;
	game_box->setHidden(false);
}

void CatGame::on_disable()
{
	cat_mode->setEnabled(0);
	laser_component->setEnabled(1);
	game_box->setHidden(true);
}

void CatGame::update()
{
	catched ? update_gameover() : update_game();
}

void CatGame::update_game()
{
	timer += Game::getIFps();

	// change cat's movement parametrs with time
	cat_mode->setStiffness(cat_mode->getStiffness() + Game::getIFps() * 2.0f);
	cat_mode->setDamping(cat_mode->getDamping() + Game::getIFps() * 0.25f);

	catched = cat_mode->getFinished();
	if (catched)
		laser_component->setEnabled(0);

	game_label->setText(
		String::format("Don't let the cat catch the laser pointer!\nTime: %.2f", timer));
}

void CatGame::update_gameover()
{
	// restart game
	if (Input::isKeyDown(Input::KEY_ENTER))
	{
		catched = false;
		timer = 0;
		cat_mode->RefreshSpring();
		laser_component->setEnabled(1);
	}

	game_label->setText(String::format("GAME OVER! Press Enter to restart\nTime: %.2f", timer));
}

void CatGame::shutdown()
{
	shutdown_gui();
}

void CatGame::shutdown_gui()
{
	game_label.deleteLater();
	game_box.deleteLater();
}
```

## CatSample.cpp

```cpp
#include "CatSample.h"

#include "CatDemo.h"
#include "CatGame.h"

#include <UnigineWidgets.h>
#include <UnigineWindowManager.h>

#include "../../utils/Utils.h"

REGISTER_COMPONENT(CatSample);

using namespace Unigine;
using namespace Math;

void CatSample::init()
{
	// don't hide mouse cursor when we click on the screen
	mouse_handle = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);

	game_manager = ComponentSystem::get()->getComponent<CatGame>(gameNode.get());
	if (!game_manager)
		Log::error("CatSample::init(): cannot find CatGame component!\n");

	demo_manager = ComponentSystem::get()->getComponent<CatDemo>(demoNode.get());
	if (!demo_manager)
		Log::error("CatSample::init(): cannot find CatDemo component!\n");

	init_gui();
	demo_manager->setEnabled(0);
	game_manager->setEnabled(0);
}

void CatSample::init_gui()
{
	sample_description_window.createWindow();

	auto vbox = sample_description_window.getParameterGroupBox();

	auto hbox = WidgetHBox::create(5);
	vbox->addChild(hbox, Gui::ALIGN_BOTTOM);
	game_button = WidgetButton::create("Start Game");
	game_button->setToggleable(1);
	game_button->getEventClicked().connect(this, &CatSample::switch_to_game);
	hbox->addChild(game_button, Gui::ALIGN_LEFT);
	game_manager->initGUI(sample_description_window.getWindow());

	demo_button = WidgetButton::create("Animations Demo");
	demo_button->getEventClicked().connect(this, &CatSample::switch_to_demo);
	demo_button->setToggleable(1);
	hbox->addChild(demo_button, Gui::ALIGN_LEFT);
	demo_manager->initGUI(sample_description_window.getWindow());
}

void CatSample::switch_to_game()
{
	demo_manager->setEnabled(0);
	game_manager->setEnabled(1);

	// disable demo_button callback while setting its 'toggled' state
	MUTE_EVENT(demo_button->getEventClicked());
	demo_button->setToggled(0);
}

void CatSample::switch_to_demo()
{
	game_manager->setEnabled(0);
	demo_manager->setEnabled(1);

	// disable game_button callback while setting its 'toggled' state
	MUTE_EVENT(game_button->getEventClicked());
	game_button->setToggled(0);
}

void CatSample::shutdown()
{
	Input::setMouseHandle(mouse_handle);
	shutdown_gui();
}

void CatSample::shutdown_gui()
{
	demo_button.deleteLater();
	game_button.deleteLater();
	sample_description_window.shutdown();
}

```

## CheckBox.cpp

```cpp
#include "CheckBox.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(CheckBox);

using namespace Unigine;
using namespace Math;

void CheckBox::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_checkbox = WidgetCheckBox::create(gui, text.get());

	gui->addChild(widget_checkbox, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_checkbox->setPosition(position.get().x, position.get().y);
	widget_checkbox->setFontSize(font_size.get());

	widget_checkbox->getEventChanged().connect(*this, [this]() {
		String msg = String("CheckBox: ") + (widget_checkbox->isChecked() ? "True" : "False");
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void CheckBox::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_checkbox);

		widget_checkbox.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## ClusterSample.cpp

```cpp
#include "ClusterSample.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineWidgets.h>
#include <UnigineWorld.h>

REGISTER_COMPONENT(ClusterSample);

using namespace Unigine;
using namespace Math;

// z-coordinate for meshes
const float OFFSET_Z = 0.5f;

void ClusterSample::init()
{
	cluster = checked_ptr_cast<ObjectMeshCluster>(clusterNode.get());
	if (!cluster)
		Log::error("ClusterSample::init(): can not get clusterNode property\n");

	sample_description_window.createWindow();
	update_gui();
}

void ClusterSample::update()
{
	if (Console::isActive())
		return;

	// remove/add mesh in cluster
	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON::MOUSE_BUTTON_LEFT))
	{
		// select mesh or empty space by mouse
		ivec2 mouse = Input::getMousePosition();
		Vec3 p0 = Game::getPlayer()->getWorldPosition();
		Vec3 p1 = p0 + Vec3(Game::getPlayer()->getDirectionFromMainWindow(mouse.x, mouse.y)) * 100;

		// check intersection with cluster or ground
		ObjectPtr obj = World::getIntersection(p0, p1, intersection_mask.get(), intersection);
		if (obj)
		{
			// if obj is ObjectMeshCluster then remove mesh
			if (obj == cluster)
			{
				int num = intersection->getInstance();
				cluster->removeMeshTransform(num);
			}
			else
			{
				// create transformation matrix for new mesh
				Vec3 point = intersection->getPoint();
				point.z = OFFSET_Z;

				// for add single mesh in local space
				int new_index = cluster->addMeshTransform();
				cluster->setMeshTransform(new_index,
					mat4(cluster->getIWorldTransform() * translate(point)));
				// for add a lot of meshes in global space
				// Vector<Mat4> transforms = Vector<Mat4>(translate(point), 1);
				// cluster->appendMeshes(transforms);
			}
			// Calling updateSpatialTree() is required after modifying a Cluster,
			// as such changes (e.g., position, size, or content) may affect its placement
			// within the spatial partitioning hierarchy.
			// This ensures accurate spatial indexing and enables efficient queries
			// for rendering, culling, and collision detection.
			cluster->updateSpatialTreeDelayed();
		}
		update_gui();
	}
}

void ClusterSample::shutdown()
{
	shutdown_gui();
}

void ClusterSample::init_gui() {}

void ClusterSample::update_gui()
{
	sample_description_window.setStatus(
		String::format("Number of meshes in the cluster: %d", cluster->getNumMeshes()).get());
}

void ClusterSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

```

## ClutterConverter.cpp

```cpp
#include "ClutterConverter.h"

#include <UnigineObjects.h>

REGISTER_COMPONENT(ClutterConverter);

using namespace Unigine;
using namespace Math;

void ClutterConverter::init()
{
	clutter_mesh = checked_ptr_cast<ObjectMeshClutter>(clutterMesh.get());
}

void ClutterConverter::convertToCluster()
{
	remove_cluster();

	cluster_mesh = convert_mesh(clutter_mesh);
	if (cluster_mesh)
	{
		is_converted = true;
		// move cluster to another parent
		cluster_mesh->setParent(clusterParent.get());
	}
}

void ClutterConverter::generateClutter()
{
	clutter_mesh->setSeed(Math::Random::getRandom().get());
}

void ClutterConverter::remove_cluster()
{
	if (!is_converted)
		return;

	cluster_mesh.deleteLater();
	is_converted = false;
}

ObjectMeshClusterPtr ClutterConverter::convert_mesh(const ObjectMeshClutterPtr &clutter)
{
	auto cluster = ObjectMeshCluster::create(clutter->getMeshPath());
	String name(clutter->getName());
	cluster->setName(name.append("_Cluster"));
	// copy the hierarchy
	cluster->setParent(clutter->getParent());
	// copy node transformation
	cluster->setWorldTransform(clutter->getWorldTransform());

	// copy necessary parameters for surfaces
	cluster->setVisibleDistance(clutter->getVisibleDistance());
	cluster->setFadeDistance(clutter->getFadeDistance());

	const int suf_num = clutter->getNumSurfaces();
	for (int suf_index = 0; suf_index < suf_num; ++suf_index)
	{
		cluster->setEnabled(clutter->isEnabled(suf_index), suf_index);
		cluster->setViewportMask(clutter->getViewportMask(suf_index), suf_index);
		cluster->setShadowMask(clutter->getShadowMask(suf_index), suf_index);
		cluster->setCastShadow(clutter->getCastShadow(suf_index), suf_index);
		cluster->setCastWorldShadow(clutter->getCastWorldShadow(suf_index), suf_index);
		cluster->setBakeToEnvProbe(clutter->getBakeToEnvProbe(suf_index), suf_index);
		cluster->setBakeToGI(clutter->getBakeToGI(suf_index), suf_index);
		cluster->setCastEnvProbeShadow(clutter->getCastEnvProbeShadow(suf_index), suf_index);
		cluster->setShadowMode(clutter->getShadowMode(suf_index), suf_index);
		cluster->setMinVisibleDistance(clutter->getMinVisibleDistance(suf_index), suf_index);
		cluster->setMaxVisibleDistance(clutter->getMaxVisibleDistance(suf_index), suf_index);
		cluster->setMinFadeDistance(clutter->getMinFadeDistance(suf_index), suf_index);
		cluster->setMaxFadeDistance(clutter->getMaxFadeDistance(suf_index), suf_index);
		cluster->setMinParent(clutter->getMinParent(suf_index), suf_index);
		cluster->setMaxParent(clutter->getMaxParent(suf_index), suf_index);
		cluster->setIntersection(clutter->getIntersection(suf_index), suf_index);
		cluster->setIntersectionMask(clutter->getIntersectionMask(suf_index), suf_index);
		cluster->setCollision(clutter->getCollision(suf_index), suf_index);
		cluster->setCollisionMask(clutter->getCollisionMask(suf_index), suf_index);
		cluster->setPhysicsIntersection(clutter->getPhysicsIntersection(suf_index), suf_index);
		cluster->setPhysicsIntersectionMask(clutter->getPhysicsIntersectionMask(suf_index),
			suf_index);
		cluster->setSoundOcclusion(clutter->getSoundOcclusion(suf_index), suf_index);
		cluster->setSoundOcclusionMask(clutter->getSoundOcclusionMask(suf_index), suf_index);
		cluster->setPhysicsFriction(clutter->getPhysicsFriction(suf_index), suf_index);
		cluster->setPhysicsRestitution(clutter->getPhysicsRestitution(suf_index), suf_index);
		cluster->setMaterial(clutter->getMaterial(suf_index), suf_index);
		cluster->setSurfaceProperty(clutter->getSurfaceProperty(suf_index), suf_index);
	}

	// copy transforms from the clutter to the cluster
	Vector<Mat4> transforms;
	clutter->createClutterTransforms();
	if (!clutter->getClutterWorldTransforms(transforms))
	{
		Log::warning("ClutterConverter::convert_mesh(): empty set of transforms\n");
		return ObjectMeshClusterPtr{};
	}
	cluster->createMeshes(transforms);
	return cluster;
}

```

## ClutterSample.cpp

```cpp
#include "ClutterSample.h"

#include "ClutterConverter.h"

#include <UnigineWidgets.h>

REGISTER_COMPONENT(ClutterSample);

using namespace Unigine;
using namespace Math;

void ClutterSample::init()
{
	clutter_converter = getComponent<ClutterConverter>(clutterConverter.get());
	if (!clutter_converter)
		Log::error("ClutterSample::init(): cannot find ClutterConverter component!\n");
	init_gui();
}

void ClutterSample::shutdown()
{
	sample_description_window.shutdown();
}

void ClutterSample::init_gui()
{
	sample_description_window.createWindow();

	const WidgetGroupBoxPtr &group_box = sample_description_window.getParameterGroupBox();

	auto hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_CENTER);
	auto button = WidgetButton::create("Generate Clutter");
	button->getEventClicked().connect(this, &ClutterSample::generate_button_callback);
	hbox->addChild(button, Gui::ALIGN_LEFT);
	button = WidgetButton::create("Convert to Cluster");
	button->getEventClicked().connect(this, &ClutterSample::convert_button_callback);
	hbox->addChild(button, Gui::ALIGN_LEFT);
}

void ClutterSample::generate_button_callback()
{
	clutter_converter->generateClutter();
}

void ClutterSample::convert_button_callback()
{
	clutter_converter->convertToCluster();
}

```

## CombinedSample.cpp

```cpp
#include "CombinedSample.h"

#include <UnigineInput.h>

REGISTER_COMPONENT(CombinedSample);

using namespace Unigine;
using namespace Math;

void CombinedSample::init()
{
	init_gui();

	source_lmap = static_ptr_cast<LandscapeLayerMap>(source_lmap_param.get());
	target_lmap = static_ptr_cast<LandscapeLayerMap>(target_lmap_param.get());

	height_slicer = getComponent<HeightSlicer>(height_slicer_param);
	height_slicer->setSourceLmap(source_lmap);
	height_slicer->setTargetLmap(target_lmap);
	height_slicer->enable();

	height_slicer->setSliceHeight(slice_height);
	height_slicer->run();
}

void CombinedSample::shutdown()
{
	shutdown_gui();
	height_slicer->disable();
}

void CombinedSample::init_gui()
{
	sample_description_window.createWindow();

	auto window = sample_description_window.getWindow();

	sample_description_window.addFloatParameter("Slice height", "slice height", 1.f, 0.0f, 1.f,
		[this](float v) {
			height_slicer->setSliceHeight(v);
			height_slicer->run();
		});
}

void CombinedSample::shutdown_gui()
{
	sample_description_window.shutdown();
}
```

## ComboBox.cpp

```cpp
#include "ComboBox.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(ComboBox);

using namespace Unigine;
using namespace Math;

void ComboBox::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_combobox = WidgetComboBox::create(gui);

	gui->addChild(widget_combobox, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_combobox->setPosition(position.get().x, position.get().y);
	widget_combobox->setFontSize(font_size.get());

	widget_combobox->addItem("item 0");
	widget_combobox->addItem("item 1");
	widget_combobox->addItem("item 2");

	widget_combobox->getEventChanged().connect(*this, [this]() {
		String msg = String("ComboBox: ") + widget_combobox->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void ComboBox::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_combobox);

		widget_combobox.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## ComponentSystemSample.cpp

```cpp
#include "ComponentSystemSample.h"

#include "Pawn.h"
#include "Spinner.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(ComponentSystemSample);

using namespace Unigine;
using namespace Math;

void ComponentSystemSample::init()
{
	// create static camera
	//	player = PlayerDummy::create();
	//	Game::setPlayer(player);

	// create invisible ground for Player Actor (Component)
	//	ground = ObjectMeshDynamic::create();
	//	MeshPtr mesh_plane = Mesh::create();
	//	mesh_plane->addPlaneSurface("plane", 60, 60, 10);
	//	ground->setMesh(mesh_plane);
	//	ground->setPosition(Vec3(0, 0, -0.5f));
	//	ground->setViewportMask(0, 0);

	// Note:
	// If you create objects without any components, you have to
	// declare their smart pointers (Ptr) outside of init() method
	// (just like the PlayerDummy and the LightWorld above).
	// Otherwise that kind of objects will be destroyed right after
	// init() method finished.

	// On the other hand, you can create objects in a local scope
	// (like ObjectMeshDynamics below) and they will not be destroyed,
	// but you have to use release() method + adding this node to
	// the Editor

	// create objects
	ObjectMeshDynamicPtr obj[4];
	obj[0] = create_box(translate(Vec3(-16.0f, 0.0f, 0.0f)), vec3(1.0f));
	obj[1] = create_box(translate(Vec3(16.0f, 0.0f, 0.0f)), vec3(1.0f));
	obj[2] = create_box(translate(Vec3(0.0f, -16.0f, 0.0f)), vec3(1.0f));
	obj[3] = create_box(translate(Vec3(0.0f, 16.0f, 0.0f)), vec3(1.0f));

	// there are two ways to create components on nodes:
	// 1) via component system
	ComponentSystem::get()->addComponent<Spinner>(obj[0]);
	ComponentSystem::get()->addComponent<Spinner>(obj[1]);

	// 2) via property
	obj[2]->addProperty("Spinner");
	obj[3]->setProperty(0, "Spinner");

	// set up spinners (set "spawn_node" variable)
	ObjectMeshDynamicPtr projectile_obj = create_box(Mat4_identity, vec3(0.15f));
	projectile_obj->setEnabled(0);
	for (int i = 0; i < 4; i++)
		ComponentSystem::get()->getComponent<Spinner>(obj[i])->spawn_node = projectile_obj;

	// create player
	ObjectMeshDynamicPtr my_pawn_object = create_box(translate(Vec3(1.0f, 1.0f, 0.0f)),
		vec3(1.3f, 1.3f, 0.3f));
	my_pawn = ComponentSystem::get()->addComponent<Pawn>(my_pawn_object);
	my_pawn->setDestroyCallback(MakeCallback(this, &ComponentSystemSample::my_pawn_destroyed));
	time = 0;

	// create info label
	label = WidgetLabel::create(Gui::getCurrent());
	label->setPosition(10, 10);
	label->setFontSize(24);
	label->setFontOutline(1);
	Gui::getCurrent()->addChild(label, Gui::ALIGN_OVERLAP);
}

void ComponentSystemSample::update()
{
	// increase time while player is alive
	if (my_pawn)
		time += Game::getIFps();

	// show info
	label->setText(String::format("Player:\n"
								  "Health Points: %d\n"
								  "Time: %.1f sec\n"
								  "\n"
								  "Statisics:\n"
								  "Components: %d",
		(my_pawn ? my_pawn->health.get() : 0), time, ComponentSystem::get()->getNumComponents())
			.get());
}

void ComponentSystemSample::shutdown()
{
	// nodes will be deleted automatically during world shutdown,
	// but widgets can live outside the world. We need to delete them manually.
	label.deleteLater();
}

Unigine::ObjectMeshDynamicPtr ComponentSystemSample::create_box(
	const Unigine::Math::Mat4 &transform, const Unigine::Math::vec3 &size)
{
	MeshPtr mesh = Mesh::create();
	mesh->addBoxSurface("box", size);

	ObjectMeshDynamicPtr object = ObjectMeshDynamic::create(1);
	object->setMesh(mesh);
	object->setWorldTransform(transform);

	return object;
}

```

## ComputeShader.cpp

```cpp
#include "ComputeShader.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(ComputeShader)

using namespace Unigine;
using namespace Math;

int PARTICLES_SIZE_X = 1024;
int PARTICLES_SIZE_Y = 1024;

void ComputeShader::init()
{
	Render::setMotionBlur(false);
	Render::setScreenSpaceEffects(false);

	dynamic = ObjectDynamic::create();

	dynamic->setInstancing(false);
	dynamic->addSurface("particles");

	// set primitive topology to points
	dynamic->setSurfaceMode(ObjectDynamic::MODE_POINTS, 0);
	dynamic->setSurfaceBegin(0, 0);
	dynamic->setSurfaceEnd(PARTICLES_SIZE_X * PARTICLES_SIZE_Y, 0);
	dynamic->setTransform(translate(Vec3(0.f, 0.f, 0.f)));
	dynamic->setMaterial(gpu_particles_material, "*");

	const VectorStack<ObjectDynamic::Attribute, 1> attributes = {
		{0, ObjectDynamic::TYPE_FLOAT, 1}
	};

	dynamic->setVertexFormat(attributes.get(), attributes.size());
	dynamic->clearVertex();
	dynamic->clearIndices();

	dynamic->addPoints(PARTICLES_SIZE_X * PARTICLES_SIZE_Y);

	for (int i = 0; i < PARTICLES_SIZE_X * PARTICLES_SIZE_Y; ++i)
	{
		float index = static_cast<float>(i);

		// Write particle ID (also for handle particles we can use VERTEX_ID in shaders w/o any vertex/index buffer)
		dynamic->addVertexFloat(0, &index, 1);
	}

	dynamic->flushVertex();
	dynamic->flushIndices();
	dynamic->setBoundBox(BoundBox(-vec3_inf, vec3_inf));

	for (int i = 0; i < meshes.size(); ++i)
	{
		const auto& mesh_path = meshes[i];
		ObjectMeshStaticPtr object = ObjectMeshStatic::create(mesh_path);
		object->setTransform(translate(Vec3(0.f, 0.f, 0.f)));
		object->setMaterial(uv_to_position_material, "*");
		object->setEnabled(false);
		static_meshes.push_back(std::move(object));
	}
}

void ComputeShader::update()
{
	// create resources if invalid
	create_resources();

	float ifps = Game::getIFps();

	int object_index = static_cast<int>(time / 6.f) % static_meshes.size() + 1;

	// Render uv mapped position for object
	if (object_index < static_meshes.size())
	{
		static_meshes[object_index]->setEnabled(true);
	}

	render_target->bindColorTexture(0, uv_position_texture);
	render_target->enable();
	RenderState::clearBuffer(RenderState::BUFFER_COLOR, vec4_zero);
	if (object_index < static_meshes.size())
	{
		static_meshes[object_index]->render(Render::PASS_AMBIENT, 0);
	}

	render_target->disable();
	render_target->unbindColorTextures();

	if (object_index < static_meshes.size())
	{
		static_meshes[object_index]->setEnabled(false);
	}

	// Send ifps to compute material so we can use it in our shader code
	int id = particles_solver_material->findParameter("ifps");
	particles_solver_material->setParameterFloat(id, ifps);

	time += ifps;


	// move attractor by some trajectory
	float attractor_sin = 0.f;
	float attractor_cos = 0.f;
	Math::sincos(time * 0.5f, attractor_sin, attractor_cos);

	vec4 attractor = vec4(attractor_cos, attractor_cos * attractor_sin, attractor_sin, 0.f);
	attractor *= 5.f;

	// set attractor to the material so we can use it in our shader code
	id = particles_solver_material->findParameter("attractor");
	particles_solver_material->setParameterFloat4(id, attractor);


	RenderState::setTexture(RenderState::BIND_ALL, 0, position_texture[1]);
	RenderState::setTexture(RenderState::BIND_ALL, 1, velocity_texture[1]);
	RenderState::setTexture(RenderState::BIND_ALL, 2, uv_position_texture);

	render_target->bindUnorderedAccessTexture(0, position_texture[0], true);
	render_target->bindUnorderedAccessTexture(1, velocity_texture[0], true);

	// Dispatch 32x32 (1024) group threads (each group has 32x32 (1024) threads, this value defines
	// in compute shader file)
	int group_threads_x = PARTICLES_SIZE_X / 32;
	int group_threads_y = PARTICLES_SIZE_Y / 32;

	// if incomplete group exist
	if (PARTICLES_SIZE_X % 32 > 0)
		group_threads_x++;

	if (PARTICLES_SIZE_Y % 32 > 0)
		group_threads_y++;

	render_target->enable();
	particles_solver_material->renderCompute(Render::PASS_POST, group_threads_x, group_threads_y);
	render_target->disable();
	render_target->unbindUnorderedAccessTextures();

	// Swap ping-pong textures
	TexturePtr swap = position_texture[0];
	position_texture[0] = position_texture[1];
	position_texture[1] = swap;

	swap = velocity_texture[0];
	velocity_texture[0] = velocity_texture[1];
	velocity_texture[1] = swap;

	// Set textures for ObjectDynamic (particles renderer)
	MaterialPtr material = dynamic->getMaterial(0);

	if (position_texture[1])
	{
		id = material->findTexture("particles_positions");
		material->setTexture(id, position_texture[1]);
	}

	if (velocity_texture[1])
	{
		id = material->findTexture("particles_velocities");
		material->setTexture(id, velocity_texture[1]);
	}

	if (uv_position_texture)
	{
		id = material->findTexture("particles_mapped_positions");
		material->setTexture(id, uv_position_texture);
	}
}

void ComputeShader::create_resources()
{
	const int flags = Texture::FORMAT_USAGE_UNORDERED_ACCESS | Texture::FORMAT_USAGE_RENDER;

	// Init velocity texture
	for (auto &texture : velocity_texture)
	{
		if (texture == nullptr)
		{
			texture = Texture::create();
			texture->create2D(PARTICLES_SIZE_X, PARTICLES_SIZE_Y, Texture::FORMAT_RGBA32F, flags);
		}
	}

	for (auto &texture : position_texture)
	{
		if (texture == nullptr)
		{
			texture = Texture::create();
			texture->create2D(PARTICLES_SIZE_X, PARTICLES_SIZE_Y, Texture::FORMAT_RGBA32F, flags);
		}
	}

	if (!render_target)
	{
		render_target = RenderTarget::create();
	}

	if (!uv_position_texture)
	{
		uv_position_texture = Texture::create();
		uv_position_texture->create2D(PARTICLES_SIZE_X, PARTICLES_SIZE_Y, Texture::FORMAT_RGBA32F,
			flags);
	}

	if (!particles_initialized)
	{
		init_particles_data();
	}
}

void ComputeShader::init_particles_data()
{
	ImagePtr initial_position = Image::create();
	initial_position->create2D(PARTICLES_SIZE_X, PARTICLES_SIZE_Y, Image::FORMAT_RGBA32F);

	position_texture.resize(2);
	velocity_texture.resize(2);

	for (int i = 0; i < PARTICLES_SIZE_X; i++)
	{
		for (int j = 0; j < PARTICLES_SIZE_Y; j++)
		{
			// initial data for particles simulation
			vec3 position = vec3_zero;
			position.x = 10.f * (Game::getRandomFloat(-10.f, 10.f));
			position.y = 10.f * (Game::getRandomFloat(-10.f, 10.f));
			position.z = 10.f * (Game::getRandomFloat(-10.f, 10.f));

			initial_position->set2D(i, j, Image::Pixel(position.x, position.y, position.z, 1.f));
		}
	}

	if (position_texture[1])
	{
		position_texture[1]->setImage(initial_position);
	}

	initial_position.clear();

	for (int i = 0; i < 2; i++)
	{
		render_target->bindColorTexture(0, velocity_texture[i]);
		render_target->enable();
		RenderState::setBufferMask(0, RenderState::BUFFER_ALL);
		RenderState::clearBuffer(RenderState::BUFFER_ALL, vec4_zero, 0.f);
		render_target->disable();
		render_target->unbindColorTextures();
	}

	particles_initialized = true;
}

void ComputeShader::destroy_resources()
{
	for (int i = 0; i < 2; ++i)
	{
		if (position_texture[i])
		{
			position_texture[i]->destroy();
			position_texture[i].clear();
		}

		if (velocity_texture[i])
		{
			velocity_texture[i]->destroy();
			velocity_texture[i].clear();
		}
	}

	uv_position_texture->destroy();
	uv_position_texture.clear();

	if (render_target)
	{
		render_target->destroy();
		render_target.clear();
	}

	particles_initialized = false;
}

```

## ComputeShaderImage.cpp

```cpp
#include "ComputeShaderImage.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ComputeShaderImage)

void ComputeShaderImage::init()
{
	dynamic_texture = Texture::create();
	dynamic_texture->create2D(1024, 1024, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_UNORDERED_ACCESS | Texture::FORMAT_USAGE_RENDER);

	// Apply dynamic texture into albedo slot
	int albedo_id = target_material->findTexture("albedo");
	if (albedo_id != -1)
		target_material->setTexture(albedo_id, dynamic_texture);

	render_target = RenderTarget::create();
}

void ComputeShaderImage::update()
{
	if (Render::isFirstFrame())
	{
		render_target->bindColorTexture(0, dynamic_texture);
		render_target->enable();
		RenderState::setBufferMask(0, RenderState::BUFFER_ALL);
		RenderState::clearBuffer(RenderState::BUFFER_ALL, vec4_zero, 0.f);
		render_target->disable();
		render_target->unbindColorTextures();
		return;
	}

	float ifps = Game::getIFps();

	int id = compute_material->findParameter("ifps");
	compute_material->setParameterFloat(id, ifps);

	render_target->bindUnorderedAccessTexture(0, dynamic_texture, false);
	render_target->enableCompute();

	int group_threads_x = 1024 / 32;
	int group_threads_y = 1024 / 32;

	compute_material->renderCompute(Render::PASS_POST, group_threads_x, group_threads_y);

	render_target->disable();
	render_target->unbindUnorderedAccessTextures();
}

void ComputeShaderImage::shutdown()
{
	dynamic_texture->destroy();
	dynamic_texture.clear();

	render_target->destroy();
	render_target.clear();
}

```

## ConsoleSample.cpp

```cpp
#include "ConsoleSample.h"

REGISTER_COMPONENT(ConsoleSample)

using namespace Unigine;
using namespace Math;


ConsoleVariableInt my_console_variable_int{"my_console_variable_int", "my_console_variable_int", 1,
	0, 0, 1000};
ConsoleVariableFloat my_console_variable_float{"my_console_variable_float",
	"my_console_variable_float", 1, 0.0f, 0.0f, 1.0f};
ConsoleVariableString my_console_variable_string{"my_console_variable_string",
	"my_console_variable_string", 1, nullptr};


void ConsoleSample::init()
{
	// simple example of how to add some console variables and then use them
	my_console_variable_float = 1.f;
	my_console_variable_int = 1;
	my_console_variable_string = "String";

	// here we add a new console command and add callback to process this command from our c++ code
	Console::addCommand("my_console_command", "my_console_command decription",
		MakeCallback(this, &ConsoleSample::command_callback));
	Console::run("my_console_command \"Hello from C++\"");
	Console::setActive(true);

	Console::addCommand("control_node",
		"With this command you can control node, pass desired position through the arguments",
		MakeCallback(this, &ConsoleSample::move_node_callback));


	if (!controllable_node)
	{
		Log::message("ConsoleSample::init(): No node was provided!\n");
	}

	Log::message("To move the node, you can use control_node command and 3 arguments to specify "
				 "node position");
}


void ConsoleSample::shutdown()
{
	Console::removeCommand("my_console_command");
	Console::removeCommand("control_node");
	Console::setActive(false);
}


/// this callback will be called when "my_command" are called from console
/// first argument - number of arguments (first always command name), and then
/// all arguments
void ConsoleSample::command_callback(int argc, char **argv)
{
	Log::message("my_console_command(): called\n");
	for (int i = 0; i < argc; i++)
	{
		Log::message("%d: %s\n", i, argv[i]);
	}
}

void ConsoleSample::move_node_callback(int argc, char **argv)
{
	if (!controllable_node)
		return;

	Vec3 node_position{};
	if (argc != 4)
	{
		Log::warning("control_node was called incorrectly, you need to pass 3 coordinates to move "
					 "the node\n");
		return;
	}

	const auto parse_arg = [this, &argv](int index) -> float {
		const char *a_value = argv[index];
		return Scalar(atof(a_value));
	};

	node_position.x = parse_arg(1);
	node_position.y = parse_arg(2);
	node_position.z = parse_arg(3);

	controllable_node->setWorldPosition(node_position);
}

```

## CraneControl.cpp

```cpp
#include "CraneControl.h"

#include "SlingRope.h"

#include <UnigineGame.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(CraneControl);

void CraneControl::init()
{
	if (rope.nullCheck())
	{
		Log::error("%s(): Rope node is empty!\n", __FUNCTION__);
		return;
	}
	rope_component = ComponentSystem::get()->getComponent<SlingRope>(rope);
	if (!rope_component)
	{
		Log::error("%s(): Rope node must have SlingRope component!\n", __FUNCTION__);
		return;
	}
}

void CraneControl::update()
{
	// collect turn input
	float turn_rate = turn_acceleration * Game::getIFps();
	int turn_direction = 0;

	if (Input::isKeyPressed(Input::KEY_J))
		turn_direction += 1;
	if (Input::isKeyPressed(Input::KEY_L))
		turn_direction += -1;

	// if turn_direction == 0, turn_speed tends to zero
	turn_speed = lerp(turn_speed, turn_direction * turn_max_speed, turn_rate);

	// rotate dynamic crane part
	auto rot = Mat4(rotateZ(turn_speed * Game::getIFps()));
	node->setTransform(rot * node->getTransform());

	if (rope_component)
	{
		// rope length control
		int lenght_change = 0;
		if (Input::isKeyPressed(Input::KEY_I))
			lenght_change -= 1;
		if (Input::isKeyPressed(Input::KEY_K))
			lenght_change += 1;

		if (lenght_change != 0)
		{
			float delta_length = lenght_change * rope_speed * Game::getIFps();
			rope_component->setLength(rope_component->getLength() + delta_length);
		}

		// bag control
		if (Input::isKeyDown(Input::KEY_O))
			rope_component->attachBag();
		if (Input::isKeyDown(Input::KEY_U))
			rope_component->detachBag();
	}
}

```

## CraneRopeSample.cpp

```cpp
#include "CraneRopeSample.h"

#include "SlingRope.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(CraneRopeSample);

void CraneRopeSample::init()
{
	sample_description_window.createWindow();

	rope_component = ComponentSystem::get()->getComponentInWorld<SlingRope>(true);
	if (!rope_component)
		Log::error("%s: can't fine SlingRope component in world!\n", __FUNCTION__);

	sample_description_window.addIntParameter("Bag mass (kg)", "Bag mass (kg)", 5, 1, 50, [this](int value) {
		if (rope_component)
			rope_component->setBagMass(value);
	});

	sample_description_window.addBoolParameter("Visualizer", "Enable/disable debug mode", false,
		[this](bool value) {
			if (rope_component)
				rope_component->setDebugEnabled(value);
		});

	sample_description_window.addBoolParameter("Compensate Tension", "Enable/disable tension compensation",
		false, [this](bool value) {
			if (rope_component)
				rope_component->setTensionCompensationEnabled(value);
		});
}

void CraneRopeSample::shutdown()
{
	sample_description_window.shutdown();
}

```

## CreateSample.cpp

```cpp
#include "CreateSample.h"

REGISTER_COMPONENT(CreateSample);

using namespace Unigine;
using namespace Math;

void CreateSample::init()
{
	init_gui();

	int image_count = grid_size_param.get().x * grid_size_param.get().y;
	if (albedo_images_param.size() != image_count
		|| height_images_param.size() != image_count
		|| grass_mask_images_param.size() != image_count
		|| stone_mask_images_param.size() != image_count)
	{
		Log::error("Expected %i terrain images\n", image_count);
		return;
	}
}

void CreateSample::shutdown()
{
	shutdown_gui();
}

void CreateSample::create_landscape_map()
{
	auto map_file_creator = LandscapeMapFileCreator::create();
	map_file_creator->setResolution(resolution_param.get());
	map_file_creator->setGrid(grid_size_param.get());
	map_file_creator->getEventCreate().connect(this, &CreateSample::create_callback);
	map_file_creator->setPath("landscape_map.gen.lmap");
	map_file_creator->run();


	auto map_file_settings = LandscapeMapFileSettings::create();
	map_file_settings->load(FileSystem::getGUID("landscape_map.gen.lmap"));

	map_file_settings->setEnabledAlbedo(true);
	map_file_settings->setAlbedoBlending(Unigine::Landscape::BLENDING_MODE::ALPHA_BLEND);
	map_file_settings->setEnabledOpacityAlbedo(false);

	map_file_settings->setEnabledHeight(true);
	map_file_settings->setHeightBlending(Unigine::Landscape::BLENDING_MODE::ALPHA_BLEND);
	map_file_settings->setEnabledOpacityHeight(false);

	map_file_settings->setEnabledMask(0, true);
	map_file_settings->setMaskBlending(0, Unigine::Landscape::BLENDING_MODE::ALPHA_BLEND);
	map_file_settings->setEnabledOpacityMask(0, false);

	map_file_settings->setEnabledMask(1, true);
	map_file_settings->setMaskBlending(1, Unigine::Landscape::BLENDING_MODE::ALPHA_BLEND);
	map_file_settings->setEnabledOpacityMask(1, false);

	map_file_settings->setEnabledMask(2, true);
	map_file_settings->setMaskBlending(2, Unigine::Landscape::BLENDING_MODE::ALPHA_BLEND);
	map_file_settings->setEnabledOpacityMask(2, false);

	map_file_settings->apply();
}

void CreateSample::create_landscape_objects()
{
	auto terrain = ObjectLandscapeTerrain::create();
	terrain->setActiveTerrain(true);

	auto layer_map = LandscapeLayerMap::create();
	layer_map->setParent(terrain);
	layer_map->setPath("landscape_map.gen.lmap");
	layer_map->setHeightScale(terrain_height_scale);
	layer_map->setSize(Unigine::Math::Vec2(terrain_size));
	layer_map->setPosition(Vec3_zero);
}

void CreateSample::create_callback(const LandscapeMapFileCreatorPtr &creator, const LandscapeImagesPtr &images, int x, int y)
{
	int index = y * grid_size_param.get().x + x;
	ivec2 tile_resolution = resolution_param.get() / grid_size_param.get();

	auto source_albedo = Image::create(albedo_images_param.get(index).get());
	auto source_height = Image::create(height_images_param.get(index).get());
	auto source_grass_mask = Image::create(grass_mask_images_param.get(index).get());
	auto source_stone_mask = Image::create(stone_mask_images_param.get(index).get());

	if (source_albedo->getWidth() == tile_resolution.x && source_albedo->getHeight() == tile_resolution.y)
	{
		auto albedo = images->getAlbedo();
		albedo->create2D(source_albedo->getWidth(), source_albedo->getHeight(), source_albedo->getFormat());
		albedo->copy(source_albedo, 0, 0, 0, 0, source_albedo->getWidth(), source_albedo->getHeight());
	}
	else
		Log::error("Incorrect albedo tile image size\n");

	if (source_height->getWidth() == tile_resolution.x && source_height->getHeight() == tile_resolution.y)
	{
		auto height = images->getHeight();
		height->create2D(source_height->getWidth(), source_height->getHeight(), source_height->getFormat());
		height->copy(source_height, 0, 0, 0, 0, source_height->getWidth(), source_height->getHeight());
	}
	else
		Log::error("Incorrect height tile image size\n");


	auto masks = images->getMask(0);
	masks->create2D(source_albedo->getWidth(), source_albedo->getHeight(), Image::FORMAT_RGBA8);
	masks->setChannelInt(0, 255);

	if (source_grass_mask->getWidth() == tile_resolution.x && source_grass_mask->getHeight() == tile_resolution.y)
		masks->copy(source_grass_mask, 1, 0);
	else
		Log::error("Incorrect grass mask tile image size\n");

	if (source_stone_mask->getWidth() == tile_resolution.x && source_stone_mask->getHeight() == tile_resolution.y)
		masks->copy(source_stone_mask, 2, 0);
	else
		Log::error("Incorrect stone mask tile image size\n");
}

void CreateSample::init_gui()
{
	sample_description_window.createWindow();

	auto window = sample_description_window.getWindow();

	auto button = WidgetButton::create("Create");
	button->setWidth(200);
	button->setHeight(20);
	button->getEventClicked().connect(this, &CreateSample::create_button_callback);
	window->addChild(button, Gui::ALIGN_LEFT);

	add_image_grid(window, "Albedo", albedo_images_param);
	add_image_grid(window, "Height", height_images_param);
	add_image_grid(window, "Grass mask", grass_mask_images_param);
	add_image_grid(window, "Stone mask", stone_mask_images_param);


	window->arrange();
}

void CreateSample::add_image_grid(const Unigine::WidgetPtr &parent, const char *title, decltype(albedo_images_param) &images)
{
	auto hbox = WidgetHBox::create(4, 4);
	parent->addChild(hbox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create(title);
	hbox->addChild(label, Gui::ALIGN_LEFT);

	auto grid = WidgetGridBox::create(grid_size_param.get().x, 4, 4);
	for (int i = 0; i < grid_size_param.get().y; ++i)
	{
		for (int j = 0; j < grid_size_param.get().x; ++j)
		{
			auto image = Image::create(images.get(grid_size_param.get().x * (grid_size_param.get().y - i - 1) + j).get());
			image->resize(64, 64);
			image->convertToFormat(Image::FORMAT_RGB8);
			image->flipY();
			auto sprite = WidgetSprite::create();
			sprite->setImage(image);
			grid->addChild(sprite);
		}
	}
	parent->addChild(grid, Gui::ALIGN_LEFT);
}


void CreateSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void CreateSample::create_button_callback()
{
	if (created)
		return;

	create_landscape_map();
	create_landscape_objects();
	created = true;
}

```

## Crosshair.cpp

```cpp
#include "Crosshair.h"

REGISTER_COMPONENT(Crosshair);

using namespace Unigine;

void Crosshair::init()
{
	auto gui = Gui::getCurrent();

	crosshair = WidgetSprite::create(gui, crosshair_image);
	crosshair->setWidth(crosshair_size.get().x);
	crosshair->setHeight(crosshair_size.get().y);
	gui->addChild(crosshair, Gui::ALIGN_CENTER | Gui::ALIGN_OVERLAP);
}

void Crosshair::shutdown()
{
	crosshair.deleteLater();
}

```

## CurveAnimationTransform.cpp

```cpp
#include "CurveAnimationTransform.h"

#include "UnigineGame.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(CurveAnimationTransform);
REGISTER_COMPONENT(CurveAnimationMaterialParamFloat);

void CurveAnimationTransform::update()
{
	time += Game::getIFps() * speed;

	float x = position->x->evaluate(time);
	float y = position->y->evaluate(time);
	float z = position->z->evaluate(time);

	float ang_x = rotation->x->evaluate(time);
	float ang_y = rotation->y->evaluate(time);
	float ang_z = rotation->z->evaluate(time);

	float scale_x = scale_prop->x->getNumKeys() > 1 ? scale_prop->x->evaluate(time) : 1.0f;
	float scale_y = scale_prop->y->getNumKeys() > 1 ? scale_prop->y->evaluate(time) : 1.0f;
	float scale_z = scale_prop->z->getNumKeys() > 1 ? scale_prop->z->evaluate(time) : 1.0f;

	node->setTransform(Mat4(translate(vec3(x, y, z)) * rotate(quat(ang_x, ang_y, ang_z)) * scale(vec3(scale_x, scale_y, scale_z))));
}

void CurveAnimationMaterialParamFloat::update()
{
	time += Game::getIFps() * speed;

	ObjectPtr obj = checked_ptr_cast<Object>(node);
	if (!obj)
		return;

	for (int i = 0; i < parameters.size(); i++)
	{
		auto& param = parameters[i];
		obj->setMaterialParameterFloat(param->name, param->curve->evaluate(time), param->surface);
	}
}

```

## CustomWaveSample.cpp

```cpp
#include "CustomWaveSample.h"

REGISTER_COMPONENT(CustomWaveSample);

using namespace Unigine;
using namespace Math;

void CustomWaveSample::init()
{
	// change preset to custom (4)
	Render::setWaterGeometryPreset(4);
	Render::setWaterGeometryPolygonSize(0.01f);
	Render::setWaterGeometryProgression(1);
	Render::setWaterGeometrySubpixelReduction(6);

	water = ObjectWaterGlobal::create();
	// set manual mode for create your own custom waves
	water->setWavesMode(ObjectWaterGlobal::WAVES_MODE_MANUAL);


	init_gui();
	refresh_wave_param();
}

void CustomWaveSample::shutdown()
{
	water.deleteLater();
	sample_description_window.shutdown();
}

void CustomWaveSample::init_gui()
{
	sample_description_window.createWindow();

	sample_description_window.addIntParameter("Number of Octaves", "", num_octaves, 1, 5, [this](int v)
	{
		num_octaves = v;
		refresh_wave_param();
	});

	sample_description_window.addIntParameter("Number of Waves Per Octave", "", num_waves_per_octave, 1, 10, [this](int v)
	{
		num_waves_per_octave = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Stepness Scale", "", steepness_scale, 0.01f, 1.0f, [this](float v)
	{
		steepness_scale = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Length Mean", "", len_mean, 0.0f, 2.0f, [this](float v)
	{
		len_mean = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Length Spread", "", len_spread, 0.0f, 2.0f, [this](float v)
	{
		len_spread = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Amplitude Mean", "", amp_mean, 0.0f, 25.0f, [this](float v)
	{
		amp_mean = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Amplitude Spread", "", amp_spread, 0.0f, 25.0f, [this](float v)
	{
		amp_spread = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Phase Offset Mean", "", phase_mean, 0.0f, Consts::PI2, [this](float v)
	{
		phase_mean = v;
		refresh_wave_param();
	});

	sample_description_window.addFloatParameter("Phase Offset Spread", "", phase_spread, 0.0f, Consts::PI2, [this](float v)
	{
		phase_spread = v;
		refresh_wave_param();
	});
}

void CustomWaveSample::refresh_wave_param()
{
	const float len_min = Unigine::Math::clamp(len_mean - len_spread, 0.0f, 100.0f);
	const float len_max = Unigine::Math::clamp(len_mean + len_spread, 0.0f, 100.0f);
	const float amplitude_min = Unigine::Math::clamp(amp_mean - amp_spread, 0.0f, 100.0f);
	const float amplitude_max = Unigine::Math::clamp(amp_mean + amp_spread, 0.0f, 100.0f);
	const float phase_min = Unigine::Math::clamp(phase_mean - phase_spread, -Consts::PI2, Consts::PI2);
	const float phase_max = Unigine::Math::clamp(phase_mean + phase_spread, -Consts::PI2, Consts::PI2);

	// clear waves
	while (water->getNumWaves())
		water->removeWave(water->getNumWaves() - 1);

	// set wind direction
	water->setWindDirectionAngle(wind_direction_angle);

	float num_waves = (float)(num_octaves * num_waves_per_octave);
	float inv_num_waves = rcp(num_waves);
	for (int i = 0; i < num_octaves; i++)
	{
		for (int j = 0; j < num_waves_per_octave; j++)
		{
			// Randomize wave parameters
			// set seed as wave index to get the same spectre on each program run
			random.setSeed(num_waves_per_octave * i + j);

			// get wave length as a power of two
			float wave_length = powf(2.0f, float(i - 1) + random.getFloat(len_min, len_max));

			// 0.25f is maximum height of wave
			float amplitude = (float(i) + random.getFloat(amplitude_min, amplitude_max)) * inv_num_waves * 0.25f;

			// get the direction angle in a range 0.0f.. 140.0f and take into account the wind direction
			float direction_angle = random.getFloat(-1.0f, 1.0f) * 140.0f + wind_direction_angle;

			float phase_offset = random.getFloat(phase_min, phase_max);

			// in manual mode we should calculate steepness ourseves
			float steepness = steepness_scale / max(amplitude * (Consts::PI / wave_length) * num_waves, Consts::EPS);

			// add wave to water object
			water->addWave(wave_length, amplitude, steepness, direction_angle, phase_offset);
		}
	}
}

```

## DayNightSwitchSample.cpp

```cpp
#pragma once
#include "DayNightSwitchSample.h"
#include <UnigineVisualizer.h>
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(DayNightSwitchSample);


void DayNightSwitchSample::init()
{
	sun = getComponent<SunController>(sun_node.get());
	if (!sun)
	{
		Log::error("DayNightSwitchSample::init find SunController component from sun_node!\n");
	}

	switcher = getComponent<DayNightSwitcher>(switcher_node.get());
	if (!switcher)
	{
		Log::error("DayNightSwitchSample::init cannot get DayNightSwitcher component from switcher_node!\n");
	}

	Visualizer::setEnabled(true);
	const int max_minutes = 24 * 60;
	const int noon_in_minutes = 12 * 60;

	window.createWindow();

	WidgetGroupBoxPtr params = window.getParameterGroupBox();
	WidgetPtr grid = params->getChild(0);

	auto label = WidgetLabel::create("Global time:");
	label->setWidth(100);
	grid->addChild(label, Gui::ALIGN_LEFT);

	time_slider = WidgetSlider::create();
	time_slider->setMinValue(0);
	time_slider->setMaxValue(max_minutes);

	time_slider->setWidth(200);
	time_slider->setButtonWidth(20);
	time_slider->setButtonHeight(20);
	time_slider->setToolTip("Global time");
	grid->addChild(time_slider, Gui::ALIGN_LEFT);

	time_label = WidgetLabel::create("00:00");
	time_label->setWidth(20);
	grid->addChild(time_label, Gui::ALIGN_LEFT);

	time_slider->getEventChanged().connect(*this, [this]() {
		int time = time_slider->getValue();
		String time_string = getTimeString(time);
		time_label->setText(time_string);
		sun->setTime(time * 60);
		});

	time_slider->setValue(noon_in_minutes);

	//========== Threshold Slider=========//
	WidgetSliderPtr threshold_slider = window.addFloatParameter("Zenith angle threshold", "Zenith angle threshold", switcher->getZenithThreshold(), 70.0f, 120.0f, [this](float v) {
		switcher->setZenithThreshold(v);
		});

	//========== Morning Slider=========//
	auto morning_label = WidgetLabel::create("Morning time bound:");
	morning_label->setWidth(100);
	grid->addChild(morning_label, Gui::ALIGN_LEFT);

	auto morning_slider = WidgetSlider::create();
	morning_slider->setMinValue(0);
	morning_slider->setMaxValue(max_minutes);

	morning_slider->setWidth(200);
	morning_slider->setButtonWidth(20);
	morning_slider->setButtonHeight(20);
	grid->addChild(morning_slider, Gui::ALIGN_LEFT);

	auto morning_time_label = WidgetLabel::create("00:00");
	morning_time_label->setWidth(20);
	grid->addChild(morning_time_label, Gui::ALIGN_LEFT);

	morning_slider->getEventChanged().connect(*this, [this, morning_slider, morning_time_label]() {
		int time = morning_slider->getValue();
		String time_string = getTimeString(time);
		morning_time_label->setText(time_string);
		int hours = time / 60;
		int minutes = time % 60;
		switcher->setControlMorningTime(ivec2(hours, minutes));
		});
	morning_slider->setValue(switcher->getControlMorningTime());

	//========== Evening Slider =========//
	auto evening_label = WidgetLabel::create("Evening time bound:");
	evening_label->setWidth(100);
	grid->addChild(evening_label, Gui::ALIGN_LEFT);

	auto evening_slider = WidgetSlider::create();
	evening_slider->setMinValue(0);
	evening_slider->setMaxValue(max_minutes);

	evening_slider->setWidth(200);
	evening_slider->setButtonWidth(20);
	evening_slider->setButtonHeight(20);
	evening_slider->setToolTip("Evening time bound");
	grid->addChild(evening_slider, Gui::ALIGN_LEFT);

	auto evening_time_label = WidgetLabel::create("00:00");
	evening_time_label->setWidth(20);
	grid->addChild(evening_time_label, Gui::ALIGN_LEFT);

	evening_slider->getEventChanged().connect(*this, [this, evening_slider, evening_time_label]() {
		int time = evening_slider->getValue();
		String time_string = getTimeString(time);
		evening_time_label->setText(time_string);
		int hours = time / 60;
		int minutes = time % 60;
		switcher->setControlEveningTime(ivec2(hours, minutes));
		});
	evening_slider->setValue(switcher->getControlEveningTime());



	WidgetComboBoxPtr control_type = WidgetComboBox::create();
	params->addChild(control_type, Gui::ALIGN_LEFT);
	control_type->addItem("Zenith angle threshold");
	control_type->addItem("Time");
	control_type->getEventChanged().connect(*this, [this, control_type, threshold_slider, grid]() {
		int item = control_type->getCurrentItem();
		auto type = static_cast<DayNightSwitcher::CONTROL_TYPE>(item);
		switcher->setControlType(type);
		});

	//========== Timescale slider =========//

	int min_value = 0;
	int max_value = 60 * 60 * 12;
	float default_Value = sun->getTimescale();
	WidgetSliderPtr timescale_slider = window.addIntParameter("Timescale", "Timescale", default_Value, min_value, max_value, [this](int v) {
		sun->setTimescale(v);
		});

	//========== Control type Switch =========//
	WidgetCheckBoxPtr continuous_check_box = WidgetCheckBox::create("Continuous sun rotation:");
	params->addChild(continuous_check_box, Gui::ALIGN_LEFT);
	continuous_check_box->getEventChanged().connect(*this, [this, continuous_check_box](const WidgetPtr& checkbox) {
		sun->setContinuousEnabled(continuous_check_box->isChecked());
		});
	continuous_check_box->setChecked(sun->isContinuous());


	sun->getEventOnTimeChanged().connect(*this, [this](float time) {// updating slider to current time coming from sun controller
		MUTE_EVENT(sun->getEventOnTimeChanged());
		time_slider->setValue(time / 60.0f);
		});
}

void DayNightSwitchSample::shutdown()
{
	Visualizer::setEnabled(false);
	window.shutdown();
}

void DayNightSwitchSample::update()
{
	Visualizer::renderVector(Vec3(0, 0, 2), Vec3(0, 0, 7), vec4_red,0.5f);
	Visualizer::renderVector(Vec3(0, 0, 2), Vec3(0, 0, 2) + static_cast<Vec3>(sun_node->getWorldDirection(AXIS_Z)) * 5, vec4_blue,0.5f);
}

String DayNightSwitchSample::getTimeString(int minutes)
{
	int hours = minutes / 60;
	int left_minutes = minutes % 60;

	StringStack<> str = "";
	if (hours < 10)
	{
		str += "0";
	}
	str += String::itoa(hours);
	str += ":";
	if (left_minutes < 10)
	{
		str += "0";
	}
	str += String::itoa(left_minutes);
	return str;
}

```

## DayNightSwitcher.cpp

```cpp
#pragma once
#include "DayNightSwitcher.h"
#include <UnigineConsole.h>


using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(DayNightSwitcher);

void DayNightSwitcher::init()
{
	sun = getComponent<SunController>(sun_node.get());
	if (!sun)
	{
		Log::error("DayNightSwitchSample::init can't find SunController component on the sun node!\n");
	}
	sun->getEventOnTimeChanged().connect(this, &DayNightSwitcher::onTimeChange);
	switch_control_type = static_cast<CONTROL_TYPE>(selected_control_type.get());


	for (int i = 0; i < materials_day_enabled.size(); i++)
	{
		MaterialPtr mat = materials_day_enabled.get(i).get();

		if (mat)
		{
			int param = mat->findParameter(emission_material_parameter_name.get());
			if (param == -1)
			{
				Log::error("DayNightSwitchSample::init materials_day_enabled got wrong material without emission!\n");
			}
			default_emission_scale.append(mat->getGUID(), mat->getParameterFloat(param));
		}
	}
	for (int i = 0; i < materials_night_enabled.size(); i++)
	{
		MaterialPtr mat = materials_night_enabled.get(i).get();

		if (mat)
		{
			int param = mat->findParameter(emission_material_parameter_name.get());
			if (param == -1)
			{
				Log::error("DayNightSwitchSample::init materials_night_enabled got wrong material without emission!\n");
			}
			default_emission_scale.append(mat->getGUID(), mat->getParameterFloat(param));
		}
	}
	onTimeChange();
}

void DayNightSwitcher::shutdown()
{
	default_emission_scale.clear();
	sun->getEventOnTimeChanged().disconnect(this, &DayNightSwitcher::onTimeChange);
	sun = nullptr;
}

void DayNightSwitcher::onTimeChange()
{
	switch (switch_control_type)
	{
	case 0: {//Zenth angle
		bool day = true;// is day after sun is rotated
		if (sun_node)
		{
			float current_angle = getAngle(vec3_up, sun_node->getWorldDirection(AXIS_Z));
			day = current_angle < sun_zenit_threshold;
		}

		if ((day ? 1 : 0) != is_day)//is_day initialized value is -1 so that we are always swithcing nodes for the firts time depending on world initial setup
		{
			switchNodes(day);
			is_day = day;
		}
		break;
	}
	case 1: {// Time
		int time = sun->getTime()/60;
		bool day = time > (time_morning.get().x * 60 + time_morning.get().y)
				&& time < (time_evening.get().x * 60 + time_evening.get().y); // is day after sun is rotated
		if ((day ? 1 : 0) != is_day)//is_day initialized value is -1 so that we are always swithcing nodes for the firts time depending on world initial setup
		{
			switchNodes(day);
			is_day = day;
		}
		break;
	}
	default:
		break;
	}

}

void DayNightSwitcher::switchNodes(bool day)
{
	//Materials
	for (size_t i = 0; i < materials_day_enabled.size(); i++)
	{
		MaterialPtr mat = materials_day_enabled.get(i).get();
		if (mat)
		{
			mat->setParameterFloat(emission_material_parameter_name.get(), day ? default_emission_scale[mat->getGUID()] : 0);
		}
		else
		{
			Log::warning("DayNightSwitcher::on_time_changed: materials_day_enabled  wrong day material %d\n", i);
		}

	}

	for (size_t i = 0; i < materials_night_enabled.size(); i++)
	{
		MaterialPtr mat = materials_night_enabled.get(i).get();
		if (mat)
		{
			mat->setParameterFloat(emission_material_parameter_name.get(), !day ? default_emission_scale[mat->getGUID()] : 0);
		}
		else
		{
			Log::warning("DayNightSwitcher::on_time_changed: materials_night_enabled wrong day material %d\n", i);
		}

	}

	//Nodes
	for (size_t i = 0; i < nodes_day_enabled.size(); i++)
	{
		NodePtr node = nodes_day_enabled.get(i).get();
		if (node)
		{
			node->setEnabled(day);
		}
		else
		{
			Log::warning("DayNightSwitcher::on_time_changed: wrong node %d\n", i);
		}
	}

	for (size_t i = 0; i < nodes_night_enabled.size(); i++)
	{
		NodePtr node = nodes_night_enabled.get(i).get();
		if (node)
		{
			node->setEnabled(!day);
		}
		else
		{
			Log::warning("DayNightSwitcher::on_time_changed: wrong node %d\n", i);
		}
	}
}

void DayNightSwitcher::setControlType(CONTROL_TYPE type)
{
	switch_control_type = type;
	onTimeChange();//so that new threshold would apply instantly
}

void DayNightSwitcher::setZenithThreshold(float value)
{
	value = clamp(value, 0.0f, 180.0f);
	sun_zenit_threshold = value;
	onTimeChange();//so that new threshold would apply instantly
}

void DayNightSwitcher::setControlMorningTime(Unigine::Math::ivec2 time_morning)
{
	this->time_morning = time_morning;
	onTimeChange();//so that change would apply instantly

}
void DayNightSwitcher::setControlEveningTime(Unigine::Math::ivec2 time_evening)
{
	this->time_evening = time_evening;
	onTimeChange();//so that change would apply instantly
}
```

## DefaultPlayer.cpp

```cpp
#include "DefaultPlayer.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(DefaultPlayer);

using namespace Unigine;

void DefaultPlayer::init()
{
	if (!player.nullCheck())
		player_camera = checked_ptr_cast<Player>(player.get());
	else
		player_camera = Game::getPlayer();

	if (!player_camera)
	{
		Log::error("DefaultSpectator::init(): must be at least one player in world!\n");
		return;
	}

	init_player_controlled = player_camera->isControlled();
	init_mouse_enabled = ControlsApp::isMouseEnabled();

	auto button = Input::MOUSE_BUTTON(mouse_button.get());
	if (button != Input::MOUSE_BUTTON_UNKNOWN)
		spectator_mode_button = button;

	init_mouse_handle = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE::MOUSE_HANDLE_USER);
}

void DefaultPlayer::update()
{
	if (Console::isActive() || !player_camera || (Game::getPlayer() != player_camera))
		return;

	bool current_state = Input::isMouseButtonPressed(spectator_mode_button);
	if (prev_state != current_state)
	{
		ControlsApp::setMouseEnabled(current_state ? true : init_mouse_enabled);
		player_camera->setControlled(current_state ? true : init_player_controlled);
		prev_state = current_state;
	}

	Input::setMouseCursorHide(current_state);
}

void DefaultPlayer::shutdown()
{
	if (player_camera)
		player_camera->setControlled(init_player_controlled);

	ControlsApp::setMouseEnabled(init_mouse_enabled);
	Input::setMouseCursorHide(false);
	Input::setMouseHandle(init_mouse_handle);
}

```

## DescriptionWindowCreator.cpp

```cpp
#include "DescriptionWindowCreator.h"

REGISTER_COMPONENT(DescriptionWindowCreator);

void DescriptionWindowCreator::init()
{
	sample_description_window.createWindow(window_align, window_width);
}

void DescriptionWindowCreator::shutdown()
{
	sample_description_window.shutdown();
}

```

## DetailsSample.cpp

```cpp
#include "DetailsSample.h"

REGISTER_COMPONENT(DetailsSample);

using namespace Unigine;
using namespace Math;

void DetailsSample::init()
{
	init_gui();

	terrain = static_ptr_cast<ObjectLandscapeTerrain>(terrain_param.get());
}

void DetailsSample::shutdown()
{
	shutdown_gui();
}

void DetailsSample::create_detail_grass()
{
	grass_texture = Texture::create();
	grass_texture->load(grass_texture_param.get());

	grass_material
		= Materials::findManualMaterial("Unigine::landscape_terrain_detail_base")->inherit();
	grass_material->setState("triplanar", 1);
	grass_material->setParameterFloat("size", 5.0f);
	grass_material->setParameterFloat("albedo_opacity", 0.8f);
	grass_material->setParameterFloat4("albedo", {0.8f, 0.8f, 0.6f, 1.0f});
	grass_material->setTexture("albedo", grass_texture);
	grass_material->setParameterFloat("height_opacity", 0.0f);


	auto grass_mask = terrain->getDetailMask(1);
	grass_mask->setName("Grass Mask");

	auto grass_detail = grass_mask->addDetail();
	grass_detail->setName("Grass Detail");
	grass_detail->setMaterial(grass_material);
}

void DetailsSample::create_detail_stone()
{
	stone_texture = Texture::create();
	stone_texture->load(stone_texture_param.get());

	stone_material
		= Materials::findManualMaterial("Unigine::landscape_terrain_detail_base")->inherit();
	stone_material->setState("triplanar", 1);
	stone_material->setParameterFloat("size", 4.0f);
	stone_material->setParameterFloat("albedo_opacity", 0.9f);
	stone_material->setParameterFloat4("albedo", {0.6f, 0.6f, 0.5f, 1.0f});
	stone_material->setTexture("albedo", stone_texture);
	stone_material->setParameterFloat("height_opacity", 0.0f);

	auto stone_mask = terrain->getDetailMask(2);
	stone_mask->setName("Stone Mask");

	auto stone_detail = stone_mask->addDetail();
	stone_detail->setName("Stone Detail");
	stone_detail->setMaterial(stone_material);
}

void DetailsSample::create_detail_snow_cap()
{
	snow_material
		= Materials::findManualMaterial("Unigine::landscape_terrain_detail_base")->inherit();
	snow_material->setParameterFloat("height_opacity", 0.0f);

	auto white_mask = terrain->getDetailMask(0);
	white_mask->setName("White Mask");

	auto stone_detail = white_mask->addDetail();
	stone_detail->setName("Snow Cap Detail");
	stone_detail->setMaterial(snow_material);
	stone_detail->setMinVisibleHeight(100.0f);
	stone_detail->setMinFadeHeight(30.0f);
}

void DetailsSample::set_detail_render_order()
{
	// desired render order:
	// 1. stone
	// 2. grass
	// 3. snow caps

	auto white_mask = terrain->getDetailMask(0);
	auto stone_mask = terrain->getDetailMask(2);
	white_mask->swapRenderOrder(stone_mask);
}

void DetailsSample::init_gui()
{
	sample_description_window.createWindow();

	auto window = sample_description_window.getWindow();
	auto create_details_button = WidgetButton::create("Create details");
	window->addChild(create_details_button);

	create_details_button->getEventClicked().connect(this, &DetailsSample::add_details_button_callback);

	add_detail_properties(window, "Grass", grass_texture_param);
	add_detail_properties(window, "Stone", stone_texture_param);
}

void DetailsSample::add_detail_properties(const Unigine::WidgetPtr &parent, const char *title,
	decltype(grass_texture_param) &texture)
{
	auto group_box = WidgetGroupBox::create(title, 4, 0);
	parent->addChild(group_box, Gui::ALIGN_LEFT);

	auto hbox = WidgetHBox::create();
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create("Texture");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	auto image = Image::create(texture.get());
	image->resize(64, 64);
	auto sprite = WidgetSprite::create();
	sprite->setImage(image);
	hbox->addChild(sprite, Gui::ALIGN_LEFT);
}


void DetailsSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void DetailsSample::add_details_button_callback()
{
	if (created)
		return;

	create_detail_grass();
	create_detail_stone();
	create_detail_snow_cap();
	set_detail_render_order();
	created = true;
}

```

## Dialogs.cpp

```cpp
#include "Dialogs.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(Dialogs);

using namespace Unigine;
using namespace Math;

void Dialogs::init()
{
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();

	GuiPtr gui = main_window->getGui();

	window = WidgetWindow::create(gui, "Dialogs", 4, 4);
	window->setFlags(Gui::ALIGN_OVERLAP | Gui::ALIGN_CENTER);

	auto button0 = WidgetButton::create(gui, "Message");
	button0->getEventClicked().connect(this, &Dialogs::button_message_clicked, "DialogMessage", "Message");
	window->addChild(button0, Gui::ALIGN_EXPAND);

	auto button1 = WidgetButton::create(gui, "File");
	button1->getEventClicked().connect(this, &Dialogs::button_file_clicked, "DialogFile", "./");
	window->addChild(button1, Gui::ALIGN_EXPAND);

	auto button2 = WidgetButton::create(gui, "Color");
	button2->getEventClicked().connect(this, &Dialogs::button_color_clicked, "DialogColor", vec4(1.0f));
	window->addChild(button2, Gui::ALIGN_EXPAND);

	if (!String::isEmpty(image.get()))
	{
		auto button3 = WidgetButton::create(gui, "Image");
		button3->getEventClicked().connect(this, &Dialogs::button_image_clicked, "Dialogimage", image.get());
		window->addChild(button3, Gui::ALIGN_EXPAND);
	}
	else
	{
		Log::warning("Dialogs::init(): image parameter not specified.");
	}

	window->arrange();
	main_window->addChild(window);

	Console::setOnscreen(true);
}

void Dialogs::shutdown()
{
	window.deleteLater();

	if (dialog)
		dialog.deleteLater();

	Console::setOnscreen(false);
}

void Dialogs::dialog_ok_clicked(const WidgetPtr &widget, int mouse_buttons, WidgetDialogPtr dialog, int type)
{
	Log::message("%s ok clicked\n", dialog->getText());
	if (type == 1)
		Log::message("%s\n", static_ptr_cast<WidgetDialogFile>(dialog)->getFile());
	if (type == 2)
		Log::message("%s\n", static_ptr_cast<WidgetDialogColor>(dialog)->getWebColor());
	dialog.deleteLater();
}

void Dialogs::dialog_cancel_clicked(const WidgetPtr &widget, int mouse_buttons, WidgetDialogPtr dialog)
{
	Log::message("%s cancel clicked\n", dialog->getText());
	dialog.deleteLater();
}

void Dialogs::dialog_show(const WidgetDialogPtr &widget, int type)
{
	if (dialog)
		dialog.deleteLater();

	dialog = widget;

	dialog->getOkButton()->getEventClicked().connect(this, &Dialogs::dialog_ok_clicked, dialog, type);
	dialog->getCancelButton()->getEventClicked().connect(this, &Dialogs::dialog_cancel_clicked, dialog);
	WindowManager::getMainWindow()->addChild(dialog, Gui::ALIGN_OVERLAP | Gui::ALIGN_CENTER);
	dialog->setPermanentFocus();
}

void Dialogs::button_message_clicked(const WidgetPtr &widget, int mouse_buttons, const char *title, const char *message)
{
	GuiPtr gui = WindowManager::getMainWindow()->getGui();

	auto dialog_message = WidgetDialogMessage::create(gui, title);
	dialog_message->setMessageText(message);
	dialog_show(dialog_message, 0);
}

void Dialogs::button_file_clicked(const WidgetPtr &widget, int mouse_buttons, const char *title, const char *path)
{
	GuiPtr gui = WindowManager::getMainWindow()->getGui();

	auto dialog_file = WidgetDialogFile::create(gui, title);
	dialog_file->setPath(path);
	dialog_show(dialog_file, 1);
}

void Dialogs::button_color_clicked(const WidgetPtr &widget, int mouse_buttons, const char *title, vec4 color)
{
	GuiPtr gui = WindowManager::getMainWindow()->getGui();

	auto dialog_color = WidgetDialogColor::create(gui, title);
	dialog_color->setColor(color);
	dialog_show(dialog_color, 2);
}

void Dialogs::button_image_clicked(const WidgetPtr &widget, int mouse_buttons, const char *title, const char *texture)
{
	GuiPtr gui = WindowManager::getMainWindow()->getGui();

	auto dialog_image = WidgetDialogImage::create(gui, title);
	dialog_image->setTexture(texture);
	dialog_show(dialog_image, 3);
}

```

## DiggingTool.cpp

```cpp
#include "DiggingTool.h"

#include <Unigine.h>
#include <UnigineTextures.h>

REGISTER_COMPONENT(DiggingTool);

using namespace Unigine;
using namespace Math;

void DiggingTool::init()
{
	{
		layer_map = checked_ptr_cast<LandscapeLayerMap>(lmap_node.get());
		if (!layer_map)
		{
			Log::error("DiggingTool: can't cast node to lmap\n");
			return;
		}

		digging_object = checked_ptr_cast<Object>(digging_object_node.get());
		if (!digging_object)
		{
			Log::error("DiggingTool: digging object is null\n");
			return;
		}

		auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath("digging_tool.basemat"));
		if (auto mat = Materials::findMaterialByFileGUID(guid))
		{
			digging_tool_mat = mat->inherit();
			if (!digging_tool_mat)
			{
				Log::error("DiggingTool: can't create digging tool material\n");
				return;
			}
		}
		else
		{
			Log::error("DiggingTool: can't create digging tool material\n");
			return;
		}
	}

	{
		Landscape::getEventTextureDraw().connect(texture_draw_connection, this, &DiggingTool::on_texture_draw);
		reset_modifications();
	}

	{
		Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);
		target_transform = digging_object->getWorldTransform();
		gui.init(this);
	}
}

void DiggingTool::update()
{
	update_digging_object();

	if (Input::isKeyDown(Input::KEY_C))
		reset_modifications();

	if (should_update_terrain())
		enqueue_terrain_update();

	gui.update();
}

void DiggingTool::shutdown()
{
	texture_draw_connection.disconnect();
	reset_modifications();

	for (auto &it: per_operation_draw_data)
		it.data.object_depth_texture->destroy();

	per_operation_draw_data.clear();

	gui.shutdown();
}

// =======================================================================================

void DiggingTool::update_digging_object()
{
	float ifps = Game::getIFps();

	// use bound sphere to get a square boundbox -- this will help a bit with
	// optimizing texture allocation later in `enqueue_terrain_update`
	digging_object_wbb = WorldBoundBox { digging_object->getWorldBoundSphere() };

	float position_lerp_rate = 5.f;
	float rotation_lerp_rate = 2.f;

	Mat4 transform = digging_object->getWorldTransform();

	Vec3 position = transform.getTranslate();

	Vec3 new_position = lerp(position, target_transform.getTranslate(), position_lerp_rate * ifps);
	quat new_rotation = slerp(transform.getRotate(), target_transform.getRotate(), rotation_lerp_rate * ifps);

	{
		// clamp the max delta the digging object can move in one frame
		// to avoid leaving odd patches of terrain unmodified

		// ideally this should be done using proper brush logic (with interpolation, etc.)
		// but that is beyond the scope of this sample

		float max_delta = position_spacing;

		Vec3 delta = new_position - position;
		Vec3 direction = normalize(delta);
		float magnitude = length(delta);

		magnitude = min(magnitude, max_delta);
		new_position = position + direction * magnitude;
	}

	digging_object->setWorldTransform(Mat4 { new_rotation, new_position });
}

bool DiggingTool::should_update_terrain()
{
	// to help performance we don't update terrain every frame, instead, it is done only when
	// it makes sense i.e. when the digging object has moved far enough to mark a visible difference on the terrain
	// (see defined by DiggingTool::*_spacing variables)

	Vec3 position = digging_object->getWorldPosition();
	vec3 rotation = decomposeRotationXYZ(mat3(digging_object->getWorldTransform()));

	if (compare(position, prev_position, position_spacing) && compare(rotation, prev_rotation, rotation_spacing))
		return false;

	prev_position = position;
	prev_rotation = rotation;

	return true;
}

void DiggingTool::enqueue_terrain_update()
{
	auto world_to_texel = [this](const Vec3 &world_pos, bool is_max) -> ivec2 {
		Vec2 coord = world_pos.xy / layer_map->getTexelSize();
		return ivec2(is_max ? ceil(coord) : floor(coord));
	};

	auto texel_to_world = [this](const ivec2 &texel_pos) -> Vec2 {
		return Vec2(texel_pos) * layer_map->getTexelSize();
	};

	TexturePtr object_depth_texture;

	ivec2 coord = world_to_texel(digging_object_wbb.minimum, true);
	ivec2 coord_max = world_to_texel(digging_object_wbb.maximum, false);
	ivec2 resolution = coord_max - coord;

	// check validity of the resolution and align it to optimize texture allocations:
	// when the texture resolution remains the same, the resource allocator will
	// be more likely to reuse it instead of creating new one every frame
	{
		if (resolution.x <= 0 || resolution.y <= 0)
			return;

		resolution = align(resolution, 64);
	}

	// create depth texture
	{
		object_depth_texture = Texture::create();

		// use 32-bit float R-channel format for storing the depth values
		int texture_format = Texture::FORMAT_R32F;

		int texture_flags = {
			Texture::SAMPLER_FILTER_LINEAR |
			Texture::SAMPLER_FILTER_BILINEAR |
			Texture::SAMPLER_WRAP_MASK |
			Texture::FORMAT_USAGE_RENDER | // flag for rendering to texture
			0
		};

		object_depth_texture->create2D(resolution.x, resolution.y, texture_format, texture_flags);
	}

	// render the digging object to depth texture
	{
		Vec3 position { texel_to_world(coord), digging_object_wbb.minimum.z };
		Vec3 size { texel_to_world(resolution), digging_object_wbb.getSize().z };

		object_depth.renderDepthTexture(object_depth_texture, digging_object, position, size, resolution);
	}

	// add texture draw operation to async queue
	{
		int id = Landscape::generateOperationID();

		DrawData draw_data;
		draw_data.resolution = resolution;
		draw_data.object_depth_texture = object_depth_texture;

		per_operation_draw_data.append(id, draw_data);

		int flags_file_data = {
			Landscape::FLAGS_DATA_HEIGHT | // height
			Landscape::FLAGS_FILE_DATA_MASK_4 | // mask 4 (just as an example)
			0
		};

		Landscape::asyncTextureDraw(id, layer_map->getGUID(), coord, draw_data.resolution, flags_file_data);
	}
}

// =======================================================================================

void DiggingTool::on_texture_draw(const UGUID &guid, int operation_id, const LandscapeTexturesPtr &buffer, const ivec2 &coords, int data_mask)
{
	// extract the draw data for this operation (object's depth texture and its resolution)

	auto it = per_operation_draw_data.find(operation_id);
	if (it == per_operation_draw_data.end())
		return;

	// bind the resources and update the terrain's height and masks in the "draw_object" pass of the `digging_tool.basemat` material

	digging_tool_mat->setTexture("bind_height", buffer->getHeight());
	digging_tool_mat->setTexture("bind_mask", buffer->getMask(4));
	digging_tool_mat->setTexture("object_depth", it->data.object_depth_texture);

	digging_tool_mat->runExpression("draw_object", it->data.resolution.x, it->data.resolution.y);

	digging_tool_mat->setTexture("bind_height", nullptr);
	digging_tool_mat->setTexture("bind_mask", nullptr);
	digging_tool_mat->setTexture("object_depth", nullptr);

	it->data.object_depth_texture->destroy();
	per_operation_draw_data.remove(it);
}

void DiggingTool::reset_modifications()
{
	Landscape::asyncResetModifications(layer_map->getGUID());
}

// =======================================================================================

void DiggingTool::Gui::init(DiggingTool *sample)
{
	this->sample = sample;

	auto gui = Unigine::Gui::getCurrent();

	auto init_manipulator = [this, gui](auto manipulator)
	{
		manipulator->setBasis(this->sample->target_transform);
		manipulator->setTransform(this->sample->target_transform);
		manipulator->setMask(WidgetManipulator::MASK_XYZ);
		manipulator->setRenderGui(gui);
		manipulator->setHidden(true);
		gui->addChild(manipulator);
	};

	translator = WidgetManipulatorTranslator::create(gui);
	rotator = WidgetManipulatorRotator::create(gui);

	init_manipulator(translator);
	init_manipulator(rotator);

	set_manipulator(translator);
}

void DiggingTool::Gui::update()
{
	PlayerPtr player = Game::getPlayer();

	if (!player || !active)
		return;

	active->setModelview(player->getCamera()->getModelview());
	active->setProjection(player->getProjection());
	active->setBasis(basis == LOCAL ? active->getTransform() : Mat4_identity);

	if (!Input::isMouseGrab() && !Console::isActive())
	{
		if (Input::isKeyDown(Input::KEY_T))
			set_manipulator(translator);

		if (Input::isKeyDown(Input::KEY_R))
			set_manipulator(rotator);

		if (Input::isKeyDown(Input::KEY_G))
			basis = (basis == LOCAL) ? WORLD : LOCAL;
	}

	sample->target_transform = active->getTransform();
}

void DiggingTool::Gui::set_manipulator(WidgetManipulatorPtr manipulator)
{
	WidgetManipulatorPtr previous = active;
	active = manipulator;

	if (previous)
	{
		previous->setHidden(true);
		active->setTransform(previous->getTransform());
	}

	active->setHidden(false);
}

void DiggingTool::Gui::shutdown()
{
	translator.deleteLater();
	rotator.deleteLater();
}

```

## DynamicTextureFieldHeight.cpp

```cpp
#include "DynamicTextureFieldHeight.h"


REGISTER_COMPONENT(DynamicTextureFieldHeight);

using namespace Unigine;
using namespace Math;

void DynamicTextureFieldHeight::setImageSize(int size)
{
	size_map = size;
	// create R8 image
	image->create2D(size_map, size_map, 0);
}


void DynamicTextureFieldHeight::setFrequency(float f)
{
	frequency = f;
}

void DynamicTextureFieldHeight::setSpeed(float s)
{
	speed = s;
}

void DynamicTextureFieldHeight::setAmplitude(float power)
{
	// 127 = 255 / 2      255 max red channel value for R8      power = [0 , 1]
	amplitude = int(127.0f * power);
}

void DynamicTextureFieldHeight::setWidgetSprite(WidgetSpritePtr spr)
{
	sprite = spr;
}

void DynamicTextureFieldHeight::init()
{
	instance = checked_ptr_cast<FieldHeight>(node);
	if (instance)
	{
		image = Image::create();
		// create R8 image
		image->create2D(size_map, size_map, 0);

		texture = Texture::create();
		texture->setImage(image);
		instance->setTexture(texture);
	}
	else
	{
		node->setEnabled(false);
		Log::error("Component can only be added to the Field Height");
	}
}

void DynamicTextureFieldHeight::update()
{
	float time = Game::getTime() * speed;

	unsigned char* pixels_ = image->getPixels();
	for (int j = 0; j < size_map; j++)
	{
		float value = amplitude * (sinFast(j * frequency / size_map + time) + 1.0f);
		for (int i = 0; i < size_map; i++)
		{
			pixels_[i + (size_map * j)] = value;
		}
	}

	texture->setImage(image);
	if (sprite)
		sprite->setImage(image);
}



```

## DynamicTextureFieldHeightSample.cpp

```cpp
#include "DynamicTextureFieldHeightSample.h"
#include "UnigineGame.h"
#include "UnigineFields.h"
#include "DynamicTextureFieldHeight.h"

REGISTER_COMPONENT(DynamicTextureFieldHeightSample);

using namespace Unigine;
using namespace Math;

void DynamicTextureFieldHeightSample::init()
{
	description_window.createWindow();

	WidgetButtonPtr button_size_1024 = WidgetButton::create();
	WidgetButtonPtr button_size_2048 = WidgetButton::create();
	WidgetButtonPtr button_size_4096 = WidgetButton::create();

	button_size_1024->setText("1024");
	button_size_2048->setText("2048");
	button_size_4096->setText("4096");

	button_size_1024->getEventClicked().connect(*this, [this]() {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setImageSize(1024);
			size_map->setText("1024 X 1024");
		}
		});

	button_size_2048->getEventClicked().connect(*this, [this]() {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setImageSize(2048);
			size_map->setText("2048 X 2048");
		}
		});

	button_size_4096->getEventClicked().connect(*this, [this]() {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setImageSize(4096);
			size_map->setText("4096 X 4096");
		}
		});

	WidgetHBoxPtr button_box = WidgetHBox::create();

	button_box->addChild(button_size_1024);
	button_box->addChild(button_size_2048);
	button_box->addChild(button_size_4096);

	description_window.addIntParameter("Size FieldHeight", "", 40, 25, 100, [this](int value) {
		FieldHeightPtr field = checked_ptr_cast<FieldHeight>(field_height.get());
		if (field)
		{
			field->setSize(vec3(float(value)));
		}
		});

	description_window.addFloatParameter("Amplitude", "", 1.0f, 0.0f, 1.0f, [this](float value) {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setAmplitude(value);
		}
		});

	description_window.addFloatParameter("Frequency", "", 1.0f, 1.0f, 40.0f, [this](float value) {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setFrequency(value);
		}
		});

	description_window.addFloatParameter("Speed", "", 1.0f, 0.0f, 20.0f, [this](float value) {
		DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);
		if (component)
		{
			component->setSpeed(value);
		}
		});

	size_map = WidgetLabel::create();
	size_map->setText("1024 X 1024");
	size_map->setFontSize(20);
	DynamicTextureFieldHeight* component = getComponent<DynamicTextureFieldHeight>(field_height);

	WidgetSpritePtr sprite = WidgetSprite::create();
	sprite->setHeight(200);
	sprite->setWidth(200);
	component->setWidgetSprite(sprite);


	description_window.addParameterSpacer();

	description_window.getParameterGroupBox()->addChild(button_box, Gui::ALIGN_LEFT);

	WidgetGroupBoxPtr image_group = WidgetGroupBox::create();
	image_group->addChild(size_map);
	image_group->addChild(sprite);

	description_window.getParameterGroupBox()->addChild(button_box, Gui::ALIGN_TOP);
	description_window.getParameterGroupBox()->addChild(image_group, Gui::ALIGN_TOP);
}

void DynamicTextureFieldHeightSample::shutdown()
{
	description_window.shutdown();
}

```

## EaseInMotion.cpp

```cpp
#include "EaseInMotion.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(EaseInMotion);

using namespace Unigine;
using namespace Math;

void EaseInMotion::init()
{
	MotionMode::init();
	on_enable();
	physics_ifps = 1.0f / physicsFPS;
}

void EaseInMotion::update()
{
	Vec3 cur_pos = persecutor->getPosition();
	Vec3 target_pos = targetNode.get()->getWorldPosition();
	// align target to persecutor's plane
	target_pos.z = cur_pos.z;

	// calculate persecutor's new position and direction
	Vec3 target_dir;
	cur_pos = update_physics(cur_pos, target_pos, target_dir);

	// apply calculations to persecutor
	if (!finished)
		persecutor->setRotation(target_dir);

	persecutor->setPosition(cur_pos);

	float speed = Math::max(drift_vel, velocity);
	persecutor->setAnimation(speed, finished);
}

void EaseInMotion::on_enable()
{
	cur_pos = persecutor->getPosition();
	velocity = 0;
	prev_pos = cur_pos;
}

Vec3 EaseInMotion::update_physics(const Vec3 &src, const Vec3 &dst, Vec3 &out_dir)
{
	// find the distance and direction to the destination point
	Vec3 offset = dst - src;
	float dist = (float)length(offset);
	if (dist > 0)
		out_dir = offset / dist;


	float ifps = Game::getIFps();
	// avoid "spiral of death"
	ifps = min(ifps, 0.25f);

	accumulator += ifps;
	// check if we've reached next physical frame
	if (accumulator >= physics_ifps)
	{
		// update input
		prev_in = cur_in;
		cur_in = dst;

		// update physics
		int steps = ftoi(Math::floor(accumulator / physics_ifps));
		for (int i = 0; i < steps; i++)
		{
			// interpolate input for each physical frame: (0, 1]
			float alpha_in = itof(i + 1) / steps;

			prev_pos = cur_pos;
			cur_pos = move_towards(cur_pos, lerp(prev_in, cur_in, alpha_in), physics_ifps);
		}
		// reset counter
		accumulator -= steps * physics_ifps;
	}

	return lerp(prev_pos, cur_pos, accumulator / physics_ifps); // return linearly interpolated position
}

Vec3 EaseInMotion::move_towards(const Vec3 &src, const Vec3 &dst, float ifps)
{
	Vec3 target_dir;

	velocity += acceleration * ifps;
	float step = velocity * ifps;

	Vec3 offset = dst - src;
	float dist = (float)length(offset);

	// can reach destination in one step
	if (dist <= step)
	{
		finished = true;
		if (dist > 0)
			target_dir = offset / dist;
		velocity = 0;
		return dst;
	}

	finished = false;
	target_dir = offset / dist;
	return src + target_dir * step;
}
```

## EaseOutBounceMotion.cpp

```cpp
#include "EaseOutBounceMotion.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(EaseOutBounceMotion);

using namespace Unigine;
using namespace Math;


Vec3 EaseOutBounceMotion::update_physics(const Vec3 &src, const Vec3 &dst, bool &out_finished,
	Vec3 &out_dir)
{
	// find distance and direction to destination
	Vec3 offset = dst - src;
	float dist = (float)length(offset);
	if (dist > 0)
		out_dir = offset / dist;

	out_finished = dist < distance_epsilon;

	float ifps = Game::getIFps();
	// avoid "spiral of death"
	ifps = min(ifps, 0.25f);

	accumulator += ifps;
	// check if we've reached next physical frame
	if (accumulator >= physics_ifps)
	{
		// update input
		prev_in = cur_in;
		cur_in = dst;

		// target moved
		if (prev_in != cur_in)
		{
			// calculate target normal
			wall_normal = normalize(prev_in - cur_in);
			if (dot(normalize(position - cur_in), wall_normal) < 0)
				wall_normal = -wall_normal;
		}

		// update physics
		int steps = ftoi(Math::floor(accumulator / physics_ifps));
		for (int i = 0; i < steps; i++)
		{
			// interpolate input for each physical frame: (0, 1]
			float alpha_in = itof(i + 1) / steps;
			Vec3 target_position = lerp(prev_in, cur_in, alpha_in);

			prev_out_p = cur_out_p;
			integrate_spring(target_position, physics_ifps);

			Vec3 dir_to_cat_from_target = normalize(position - target_position);
			// apply the bounce effect in case the direction is opposite and the position is close to the target
			if (dot(dir_to_cat_from_target, wall_normal) < 0.0
				&& length2(position - target_position) < bounceRadius * bounceRadius)
				velocity = -velocity;
			// recalculate position after applying the bounce effect
			new_position += velocity * physics_ifps;
			position = new_position;

			cur_out_p = position;
		}
		// reset counter
		accumulator -= steps * physics_ifps;
	}

	// interpolate output position
	float alpha_out = accumulator / physics_ifps;
	lerped_position = lerp(prev_out_p, cur_out_p, alpha_out);

	return lerped_position;
}

void EaseOutBounceMotion::on_enable()
{
	SpringMotion::on_enable();
	new_position = position;
}

```

## EaseOutMotion.cpp

```cpp
#include "EaseOutMotion.h"

#include <UnigineGame.h>
#include <UnigineObjects.h>

REGISTER_COMPONENT(EaseOutMotion);

using namespace Unigine;
using namespace Math;

void EaseOutMotion::update()
{
	Vec3 cur_pos = persecutor->getPosition();
	Vec3 prev_pos = cur_pos;
	Vec3 target_pos = targetNode.get()->getWorldPosition();
	// align target to persecutor's plane
	target_pos.z = cur_pos.z;

	// calculate persecutor's new position and direction
	bool finished = true;
	Vec3 target_dir;
	cur_pos = move_towards(cur_pos, target_pos, speed, finished, target_dir);

	// apply calculations to persecutor
	if (!finished)
		persecutor->setRotation(target_dir);

	persecutor->setPosition(cur_pos);

	float real_speed = (float)length(cur_pos - prev_pos) / Game::getIFps();
	persecutor->setAnimation(real_speed, finished);
}

Vec3 EaseOutMotion::move_towards(const Vec3 &src, const Vec3 &dst, float speed, bool &out_finished,
	Vec3 &out_dir)
{
	// find the distance and the direction to destination
	Vec3 offset = dst - src;
	float dist = (float)length(offset);
	if (dist > 0)
		out_dir = offset / dist;

	out_finished = dist < distance_epsilon;

	// interpolate output position
	return lerp(src, dst, 1.0f - Math::exp(-speed * Game::getIFps()));
}

```

## EditLine.cpp

```cpp
#include "EditLine.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(EditLine);

using namespace Unigine;
using namespace Math;

void EditLine::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_editline = WidgetEditLine::create(gui, text.get());

	gui->addChild(widget_editline, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_editline->setPosition(position.get().x, position.get().y);
	widget_editline->setWidth(size.get().x);
	widget_editline->setHeight(size.get().y);
	widget_editline->setFontSize(font_size.get());

	widget_editline->getEventChanged().connect(*this, [this]() {
		String msg = String("EditLine text: ") + widget_editline->getText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void EditLine::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_editline);

		widget_editline.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## EditText.cpp

```cpp
#include "EditText.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(EditText);

using namespace Unigine;
using namespace Math;

void EditText::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_edittext = WidgetEditText::create(gui, text.get());

	gui->addChild(widget_edittext, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_edittext->setPosition(position.get().x, position.get().y);
	widget_edittext->setWidth(size.get().x);
	widget_edittext->setHeight(size.get().y);
	widget_edittext->setFontSize(font_size.get());

	widget_edittext->getEventChanged().connect(*this, [this]() {
		String msg = String("EditText text: ") + widget_edittext->getText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void EditText::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_edittext);

		widget_edittext.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## EulerAnglesSample.cpp

```cpp
#include "EulerAnglesSample.h"

#include "UnigineVisualizer.h"


REGISTER_COMPONENT(EulerAnglesSample);

using namespace Unigine;
using namespace Unigine::Math;



void EulerAnglesSample::init()
{
	init_gui();
	update_decomposition_angles();

	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);
}

void EulerAnglesSample::update()
{
	Vec3 position = plane->getWorldPosition();
	vec3 direction_x = plane->getWorldDirection(Math::AXIS_X);
	vec3 direction_y = plane->getWorldDirection(Math::AXIS_Y);
	vec3 direction_z = plane->getWorldDirection(Math::AXIS_Z);

	// render local axes of the plane
	{
		Visualizer::renderVector(position, position + Vec3(direction_x) * 1.5f, vec4_red);
		Visualizer::renderVector(position, position + Vec3(direction_y) * 1.5f, vec4_green);
		Visualizer::renderVector(position, position + Vec3(direction_z) * 1.5f, vec4_blue);

		Visualizer::renderMessage3D(position + Vec3(direction_x) * 1.5f, vec3_zero, "X", vec4_black, 1);
		Visualizer::renderMessage3D(position + Vec3(direction_y) * 1.5f, vec3_zero, "Y", vec4_black, 1);
		Visualizer::renderMessage3D(position + Vec3(direction_z) * 1.5f, vec3_zero, "Z", vec4_black, 1);
	}

	// render global axes
	{
		Vec3 offset = { -2.0f, -2.0f, 0.2f };

		Visualizer::renderVector(offset, offset + Vec3_right * 2.0f, vec4_red);
		Visualizer::renderVector(offset, offset + Vec3_forward * 2.0f, vec4_green);
		Visualizer::renderVector(offset, offset + Vec3_up * 2.0f, vec4_blue);
	}


	// render orbits (circles)
	{
		Mat4 orbit_x_transform = Mat4_identity;
		Mat4 orbit_y_transform = Mat4_identity;
		Mat4 orbit_z_transform = Mat4_identity;
		vec3 radii = vec3_zero;

		// calculate orbit transforms
		{
			float x = euler_angles.x;
			float y = euler_angles.y;
			float z = euler_angles.z;

			float big_radius = 1.4f;
			float middle_radius = 1.3f;
			float small_radius = 1.2f;

			orbit_x_transform = Mat4 { rotate(quat{ euler_angles.x, 0.0f, 0.0f }) };
			orbit_y_transform = Mat4 { rotate(quat{ euler_angles.x, euler_angles.y, 0.0f }) };
			orbit_z_transform = Mat4 { rotate(quat{ euler_angles.x, euler_angles.y, euler_angles.z }) };
			radii = vec3 { big_radius, middle_radius, small_radius };

			switch (composition_sequence)
			{
				case XYZ:
					orbit_x_transform = Mat4 { composeRotationXYZ(vec3(x, 0.0f, 0.0f)) };
					orbit_y_transform = Mat4 { composeRotationXYZ(vec3(x, y, 0.0f)) };
					orbit_z_transform = Mat4 { composeRotationXYZ(vec3(x, y, z)) };
					radii = vec3(big_radius, middle_radius, small_radius);
					break;

				case XZY:
					orbit_x_transform = Mat4 { composeRotationXZY(vec3(x, 0.0f, 0.0f)) };
					orbit_z_transform = Mat4 { composeRotationXZY(vec3(x, 0.0f, z)) };
					orbit_y_transform = Mat4 { composeRotationXZY(vec3(x, y, z)) };
					radii = vec3(big_radius, small_radius, middle_radius);
					break;

				case YXZ:
					orbit_y_transform = Mat4 { composeRotationYXZ(vec3(0.0f, y, 0.0f)) };
					orbit_x_transform = Mat4 { composeRotationYXZ(vec3(x, y, 0.0f)) };
					orbit_z_transform = Mat4 { composeRotationYXZ(vec3(x, y, z)) };
					radii = vec3(middle_radius, big_radius, small_radius);
					break;

				case YZX:
					orbit_y_transform = Mat4 { composeRotationYZX(vec3(0.0f, y, 0.0f)) };
					orbit_z_transform = Mat4 { composeRotationYZX(vec3(0.0f, y, z)) };
					orbit_x_transform = Mat4 { composeRotationYZX(vec3(x, y, z)) };
					radii = vec3(small_radius, big_radius, middle_radius);
					break;

				case ZXY:
					orbit_z_transform = Mat4 { composeRotationZXY(vec3(0.0f, 0.0f, z)) };
					orbit_x_transform = Mat4 { composeRotationZXY(vec3(x, 0.0f, z)) };
					orbit_y_transform = Mat4 { composeRotationZXY(vec3(x, y, z)) };
					radii = vec3(middle_radius, small_radius, big_radius);
					break;

				case ZYX:
					orbit_z_transform = Mat4 { composeRotationZYX(vec3(0.0f, 0.0f, z)) };
					orbit_y_transform = Mat4 { composeRotationZYX(vec3(0.0f, y, z)) };
					orbit_x_transform = Mat4 { composeRotationZYX(vec3(x, y, z)) };
					radii = vec3(small_radius, middle_radius, big_radius);
					break;
			}

			orbit_x_transform = translate(position) * orbit_x_transform * Mat4 { rotate(quat{ 0, 90, 0 }) };
			orbit_y_transform = translate(position) * orbit_y_transform * Mat4 { rotate(quat{ 90, 0, 0 }) };
			orbit_z_transform = translate(position) * orbit_z_transform;
		}

		Visualizer::renderCircle(radii.x, orbit_x_transform, vec4_red);
		Visualizer::renderCircle(radii.y, orbit_y_transform, vec4_green);
		Visualizer::renderCircle(radii.z, orbit_z_transform, vec4_blue);

		// render orbit arrows
		{
			Vec3 arrow_start = position + orbit_x_transform.getAxisY() * radii.x;
			Vec3 arrow_finish = arrow_start + orbit_x_transform.getAxisY() * 0.1f;
			Visualizer::renderVector(arrow_start, arrow_finish, vec4_red, 1.0f);

			arrow_start = position + orbit_y_transform.getAxisY() * radii.y;
			arrow_finish = arrow_start + orbit_y_transform.getAxisY() * 0.1f;
			Visualizer::renderVector(arrow_start, arrow_finish, vec4_green, 1.0f);

			arrow_start = position + orbit_z_transform.getAxisY() * radii.z;
			arrow_finish = arrow_start + orbit_z_transform.getAxisY() * 0.1f;
			Visualizer::renderVector(arrow_start, arrow_finish, vec4_blue, 1.0f);
		}
	}
}

void EulerAnglesSample::shutdown()
{
	sample_description_window.shutdown();
	Visualizer::setEnabled(visualizer_enabled);
}


void EulerAnglesSample::update_rotation()
{
	mat4 rotation = mat4_identity;

	switch (composition_sequence)
	{
		case XYZ: rotation = composeRotationXYZ(euler_angles); break;
		case XZY: rotation = composeRotationXZY(euler_angles); break;
		case YXZ: rotation = composeRotationYXZ(euler_angles); break;
		case YZX: rotation = composeRotationYZX(euler_angles); break;
		case ZXY: rotation = composeRotationZXY(euler_angles); break;
		case ZYX: rotation = composeRotationZYX(euler_angles); break;
	}

	plane->setWorldRotation(quat{ rotation }, true);
}

void EulerAnglesSample::update_decomposition_angles()
{
	mat3 rotation = plane->getWorldRotation().getMat3();

	switch (decomposition_sequence)
	{
		case XYZ: decomposition_angles = decomposeRotationXYZ(rotation); break;
		case XZY: decomposition_angles = decomposeRotationXZY(rotation); break;
		case YXZ: decomposition_angles = decomposeRotationYXZ(rotation); break;
		case YZX: decomposition_angles = decomposeRotationYZX(rotation); break;
		case ZXY: decomposition_angles = decomposeRotationZXY(rotation); break;
		case ZYX: decomposition_angles = decomposeRotationZYX(rotation); break;
	}

	status = String::format("Decomposition angles:\nPitch (X):\t%.2f\nRoll (Y):\t%.2f\nYaw (Z):\t%.2f\n",
		decomposition_angles.x, decomposition_angles.y, decomposition_angles.z);
	sample_description_window.setStatus(status);
}

void EulerAnglesSample::init_gui()
{
	sample_description_window.createWindow();

	auto pitch_slider = sample_description_window.addIntParameter("Pitch (X)", "Pitch (X)", 0, -180, 180, [this](int value) {
		euler_angles.x = float(value);
		update_rotation();
		update_decomposition_angles();
	});

	auto roll_slider = sample_description_window.addIntParameter("Roll (Y)", "Roll (Y)", 0, -180, 180, [this](int value) {
		euler_angles.y = float(value);
		update_rotation();
		update_decomposition_angles();
	});

	auto yaw_slider = sample_description_window.addIntParameter("Yaw (Z)", "Yaw (Z)", 0, -180, 180, [this](int value) {
		euler_angles.z = float(value);
		update_rotation();
		update_decomposition_angles();
	});

	auto parameters = sample_description_window.getParameterGroupBox();

	WidgetComboBoxPtr composition_combo_box;
	WidgetComboBoxPtr decomposition_combo_box;

	{
		auto hbox = WidgetHBox::create();
		hbox->addChild(WidgetLabel::create("Composition sequence: "), Gui::ALIGN_LEFT);

		auto combo_box = WidgetComboBox::create();

		combo_box->addItem("XYZ");
		combo_box->addItem("XZY");
		combo_box->addItem("YXZ");
		combo_box->addItem("YZX");
		combo_box->addItem("ZXY");
		combo_box->addItem("ZYX");

		combo_box->getEventChanged().connect(*this, [this, combo_box] {
			composition_sequence = ROTATION_SEQUENCE(combo_box->getCurrentItem());
			update_rotation();
		});

		composition_combo_box = combo_box;

		hbox->addChild(combo_box);
		parameters->addChild(hbox, Gui::ALIGN_LEFT);
	};

	{
		auto hbox = WidgetHBox::create();
		hbox->addChild(WidgetLabel::create("Decomposition sequence: "), Gui::ALIGN_LEFT);

		auto combo_box = WidgetComboBox::create();

		combo_box->addItem("XYZ");
		combo_box->addItem("XZY");
		combo_box->addItem("YXZ");
		combo_box->addItem("YZX");
		combo_box->addItem("ZXY");
		combo_box->addItem("ZYX");

		combo_box->getEventChanged().connect(*this, [this, combo_box] {
			decomposition_sequence = ROTATION_SEQUENCE(combo_box->getCurrentItem());
			update_decomposition_angles();
		});

		decomposition_combo_box = combo_box;

		hbox->addChild(combo_box);
		parameters->addChild(hbox, Gui::ALIGN_LEFT);
	};

	auto reset_button = WidgetButton::create("Reset");
	reset_button->getEventClicked().connect(*this, [this, yaw_slider, roll_slider, pitch_slider, composition_combo_box, decomposition_combo_box] {
		euler_angles = vec3_zero;
		update_rotation();
		update_decomposition_angles();

		yaw_slider->setValue(0);
		pitch_slider->setValue(0);
		roll_slider->setValue(0);
		composition_combo_box->setCurrentItem(0);
		decomposition_combo_box->setCurrentItem(0);
	});

	parameters->addChild(reset_button, Gui::ALIGN_LEFT);
}

```

## EventsAdvancedSample.cpp

```cpp
#include "EventsAdvancedSample.h"
#include <UnigineConsole.h>
#include <UnigineInput.h>

REGISTER_COMPONENT(EventsAdvancedSample);

using namespace Unigine;

void EventsAdvancedSample::init()
{
	Console::setOnscreen(true);
}

void EventsAdvancedSample::update()
{
	if (Console::isActive())
		return;

	if (Input::isKeyPressed(Input::KEY_T))
	{
		Log::message("Run rotate X with 1 arg\n");
		rotate_x_event.run(rotation_speed.get().x);
	}
	if (Input::isKeyPressed(Input::KEY_Y))
	{
		Log::message("Run rotate Y with 1 arg\n");
		rotate_y_event.run(rotation_speed.get().y);
	}
	if (Input::isKeyPressed(Input::KEY_U))
	{
		Log::message("Run rotate Z with 1 arg\n");
		rotate_z_event.run(rotation_speed.get().z);
	}
	if (Input::isKeyPressed(Input::KEY_I))
	{
		Log::message("Run rotate XYZ with 4 args\n");
		rotate_event.run(rotation_speed.get().x, rotation_speed.get().y, rotation_speed.get().z, this);
	}
}

void EventsAdvancedSample::shutdown()
{
	Console::setOnscreen(false);
}

```

## EventsAdvancedUnit.cpp

```cpp
#include "EventsAdvancedUnit.h"
#include "EventsAdvancedSample.h"

REGISTER_COMPONENT(EventsAdvancedUnit);

using namespace Unigine;

void EventsAdvancedUnit::init()
{
	auto inputManager = getComponent<EventsAdvancedSample>(input_manager);

	if (!inputManager)
		return;

	// Connect to class method with extra parameters.
	// It works within component because Unigine::ComponentBase inherits from EventConnection
	inputManager->getEventRotateX().connect(this, &EventsAdvancedUnit::rotate, 0.0f, 0.0f);

	// Connect to function and EventConnection with extra parameter
	inputManager->getEventRotateY().connect(rotate_y_connection, rotateNodeY, node);

	// Connect to lambda and store EventConnectionId to disconnect it later
	rotate_z_connection_id = inputManager->getEventRotateZ().connectUnsafe([this](float angle) {
		Log::message("Rotate Z (%f)!\n", angle);
		node->rotate(0, 0, angle);
	});

	// Connect with discarding argument to function and store EventConnectionId to disconnect it later
	rotate_connection_id = inputManager->getEventRotate().connectUnsafe(rotateNode, node);
}

void EventsAdvancedUnit::shutdown()
{
	auto inputManager = getComponent<EventsAdvancedSample>(input_manager);

	if (!inputManager)
		return;

	// Disconnect class method
	// It works within component because Unigine::ComponentBase inherits from EventConnection
	inputManager->getEventRotateX().disconnect(this, &EventsAdvancedUnit::rotate);

	// Disconnect EventConnection
	rotate_y_connection.disconnect();

	// Disconnect by EventConnectionId
	inputManager->getEventRotateZ().disconnect(rotate_z_connection_id);

	// Disconnect by EventConnectionId
	inputManager->getEventRotate().disconnect(rotate_connection_id);
}

void EventsAdvancedUnit::rotate(float x, float y, float z)
{
	Log::message("Rotate (%f %f %f)!\n", x, y, z);
	node->rotate(x, y, z);
}

void EventsAdvancedUnit::rotateNode(float x, float y, float z, Unigine::NodePtr node)
{
	Log::message("Rotate with 1 discarded and 1 extra arguments (%f %f %f)!\n", x, y, z);
	if (node)
		node->rotate(x, y, z);
}

void EventsAdvancedUnit::rotateNodeY(float angle, Unigine::NodePtr node)
{
	Log::message("Rotate Y 1 with extra arguments (%f)!\n", angle);
	if (node)
		node->rotate(0, angle, 0);
}

```

## EventsSample.cpp

```cpp
#include "EventsSample.h"

#include <UnigineConsole.h>

using namespace Unigine;

void EventsSample::EventHolder::run(int value)
{
	event.run(value);
}

void EventsSample::InheritedEventConnectionExample::subscribe(Unigine::Event<int> &event)
{
	// because "this" is inherited from Unigine::EventConnections
	// we can pass to connect *this, and connect will take "this" as a connection
	// this approach is similar to EventConnectionsExample, and you can use your class
	// as event connection, which makes connection disconnect in class destructor
	event.connect(*this,
		[](int value) { Log::message("InheritedEventConnectionExample event called\n", value); });
}

void EventsSample::InheritedEventConnectionExample::unsubscribe()
{
	disconnectAll();
}

void EventsSample::EventConnectionExample::subscribe(Unigine::Event<int> &event)
{
	// here we pass the connection, in which we want to store our callback
	// this connection type is useful when you want a precise control over your callback
	event.connect(connection,
		[](int value) { Log::message("EventConnectionExample event called\n", value); });

	// here you can enable or disable your callback in the connection
	connection.setEnabled(true);
}

void EventsSample::EventConnectionExample::unsubscribe()
{
	connection.disconnect();
}

void EventsSample::EventConnectionsExample::subscribe(Unigine::Event<int> &event)
{
	// here we pass Unigine::EventConnections object to connect, in which we store events
	// you can easily manage lots of callbacks with different connections, but you can't
	// disable or enable connections.
	// it is useful when you have a lot of callbacks with same lifetimes
	event.connect(connections,
		[](int value) { Log::message("EventConnectionsExample event called\n", value); });
}

void EventsSample::EventConnectionsExample::unsubscribe() {}

void EventsSample::CallbackIDConnection::subscribe(Unigine::Event<int> &event)
{
	callback_id = event.connectUnsafe(
		[](int value) { Log::message("CallbackIDConnection event called\n", value); });
}

void EventsSample::CallbackIDConnection::unsubscribe(Unigine::Event<int> &event)
{
	// we need to store event because in event our callback is stored
	// you need to manage lifetimes yourself
	event.disconnect(callback_id);
}


REGISTER_COMPONENT(EventsSample)

void EventsSample::init()
{
	event_connection_example.subscribe(holder.getEvent());
	event_connections_example.subscribe(holder.getEvent());
	inherited_event_connection_example.subscribe(holder.getEvent());
	callback_id_connection.subscribe(holder.getEvent());

	holder.run(42);
	Console::setOnscreen(true);
}

void EventsSample::shutdown()
{
	event_connection_example.unsubscribe();
	event_connections_example.unsubscribe();
	inherited_event_connection_example.unsubscribe();
	callback_id_connection.unsubscribe(holder.getEvent());

	Console::setOnscreen(false);
}

```

## ExternWidget.cpp

```cpp
#include "ExternWidget.h"

REGISTER_COMPONENT(ExternWidget);

using namespace Unigine;
using namespace Math;

MyWidget::MyWidget(GuiPtr gui, const char *str)
	: WidgetExternBase(gui)
{
	setTime(0.0f);
	setText(str);
	setColor(vec4(1.0f));
}

MyWidget::MyWidget(void *widget)
	: WidgetExternBase(widget)
{
	setTime(0.0f);
	setColor(vec4(1.0f));
}

MyWidget::~MyWidget()
{}

int MyWidget::getClassID()
{
	return 1;
}


void MyWidget::update(float ifps)
{
	time += ifps;
	WidgetExternBase::update(ifps);
}

void MyWidget::checkCallbacks(int x, int y)
{
	check_default_callbacks(x, y);
	check_pressed_callbacks(x, y);
}

void MyWidget::arrange()
{
	int width = 0;
	int height = 0;
	get_text_unit_size(text.get(), width, height);
	set_width(max(get_default_width(), width));
	set_height(max(get_default_height(), height));
}

void MyWidget::expand(int width, int height)
{
	set_width(max(width, get_width()));
}

void MyWidget::render()
{
	push_transform();
	set_translate(get_position_x(), get_position_y());

	float offset = get_width() / 2.0f;
	set_transform(translate(vec3(offset, 0.0f, -10.0f)) * rotateY((float)Unigine::Math::sin(time * 2.0f) * 45.0f) * translate(vec3(-offset, 0.0f, 10.0f)));

	render_text(0, 0, color, text.get(), 0, 0);

	pop_transform();
}

void MyWidget::setTime(float t)
{
	time = t;
}

void MyWidget::setText(const char *str)
{
	text = str;
}

void MyWidget::setColor(const vec4 &c)
{
	color = c;
}

void ExternWidget::init()
{
	// register MyWidget class constructor
	WidgetExternBase::addClassID<MyWidget>(1);
	
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();

	GuiPtr gui = main_window->getGui();

	window = WidgetWindow::create(gui, "WidgetWindow", 4, 4);

	my_widget_0 = new MyWidget(gui, "My Widget 0");
	window->addChild(my_widget_0->getWidget(), Gui::ALIGN_EXPAND);
	WidgetPtr widget_0 = my_widget_0->getWidget();
	widget_0->setFontSize(48);
	
	WidgetExternPtr widget_1 = WidgetExtern::create(gui, 1);
	my_widget_1 = static_cast<MyWidget *>(widget_1->getWidgetExtern());
	my_widget_1->setTime(2.0f);
	my_widget_1->setText("My Widget 1");
	my_widget_1->setColor(vec4(1.0f, 1.0f, 0.0f, 1.0f));
	widget_1->setFontSize(48);
	window->addChild(widget_1, Gui::ALIGN_EXPAND);

	window->arrange();
	
	main_window->addChild(window, Gui::ALIGN_OVERLAP | Gui::ALIGN_CENTER);
}

void ExternWidget::shutdown()
{
	if (my_widget_0)
		delete my_widget_0;

	if (my_widget_1)
		delete my_widget_1;

	window.deleteLater();
}

```

## ExternalPackageSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineFileSystem.h>
#include <UnigineObjects.h>
#include <UnigineWorlds.h>
#include <UnigineGame.h>

#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

namespace
{
	vec3 random_vec3(const vec3 &from, const vec3 &to)
	{
		return {
			Game::getRandomFloat(from.x, to.x),
			Game::getRandomFloat(from.y, to.y),
			Game::getRandomFloat(from.z, to.z)
		};
	}

	vec3 random_vec3(const vec3 &size)
	{
		return random_vec3(- size * .5f, size * .5f);
	}
}

class ExternalPackage : public Package
{
public:
	ExternalPackage(int num_files)
	{
		this->num_files = num_files;
		file = File::create();

		MeshPtr mesh = Mesh::create();
		mesh->addBoxSurface("box", vec3 {1.f });

		StringStack<> path = joinPaths(getWorldRootPath(), ".temporary", "box.mesh");

		if (mesh->save(path))
		{
			file->open(path, "rb");
		}
	}

	virtual ~ExternalPackage() = default;

	virtual int getNumFiles() override
	{
		return num_files;
	}

	virtual const char *getFilePath(int num) override
	{
		return String::format("%d.mesh", num);
	}

	virtual bool selectFile(const char *name, size_t &size) override
	{
		bool exists = findFile(name) > 0;

		if (exists)
			size = file->getSize();

		return exists;
	}

	virtual bool readFile(unsigned char *data, size_t size) override
	{
		if (!file->isOpened())
			return false;

		file->seekSet(0);
		size_t written = file->read(data, size);

		return written == size;
	}

	virtual int findFile(const char *name) const override
	{
		for (int i = 0; i < num_files; i += 1)
		{
			if (String::format("%d.mesh", i) == name)
				return 1;
		}

		return 0;
	}

	virtual size_t getFileSize(int num) const override
	{
		return file->getSize();
	}

private:
	int num_files = 0;
	FilePtr file;
};

class ExternalPackageSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(ExternalPackageSample, ComponentBase);
	COMPONENT_INIT(init);

private:
	void init()
	{
		FileSystem::addExternPackage("package", new ExternalPackage(num_files));

		for (int i = 0; i < num_files; i += 1)
		{
			ObjectMeshStaticPtr mesh_static = ObjectMeshStatic::create(String::format("%d.mesh", i));

			Vec3 position = Vec3(::random_vec3({ 4.f, 4.f, 2.f })) + Vec3_up * 2.f;
			quat rotation = quat(Game::getRandomFloat(0.f, 360.f), Game::getRandomFloat(0.f, 360.f), Game::getRandomFloat(0.f, 360.f));

			mesh_static->setWorldTransform(Mat4 { rotation, position });
		}
	}
	// ========================================================================================

	constexpr static int num_files = 64;
};

REGISTER_COMPONENT(ExternalPackageSample);

```

## ExtinguishingPuddles.cpp

```cpp
#include "ExtinguishingPuddles.h"
#include <UnigineWorld.h>
#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ExtinguishingPuddles);

void ExtinguishingPuddles::init()
{
	emitter = checked_ptr_cast<ObjectParticles>(node);
	if (!emitter)
	{
		Log::error("%s: ExtinguishingPuddles component can only be assigned to ObjectParticles\n", __FUNCTION__);
		return;
	}

	// Creating a temporary decal for cloning
	auto tmp = World::loadNode(decal_ref.get());
	
	if (tmp)
	{
		tmp->setEnabled(false);

		decal_prefab = checked_ptr_cast<Decal>(tmp);
		if (decal_prefab)
		{
			decal_albedo_id = decal_prefab->getMaterial()->findParameter("albedo");
		}
		else
		{
			Log::error("%s: can't load %s decal\n", __FUNCTION__, decal_ref.get());
			return;
		}
	} 
	else
	{
		Log::error("%s: can't load %s NodeReference \n", __FUNCTION__, decal_ref.get());
		return;
	}
	spark_emitter = checked_ptr_cast<ObjectParticles>(spark_emitter_node.get());

	cos_min_spawn_angle = Math::cos(min_spawn_angle * Math::Consts::DEG2RAD);
	cos_max_spawn_angle = Math::cos(max_spawn_angle * Math::Consts::DEG2RAD);

	emitter->setFPSInvisible(30);
	emitter->setUpdateDistanceLimit(1e+4f);

	if (dead_time <= 0.0f)
		dead_time = 0.01f;
}

void ExtinguishingPuddles::update()
{
	update_decal_traces();

	if (!emitter || !emitter->isEmitterEnabled() || !decal_prefab)
			return;

	if (emitter->getNumContacts() == 0)
		return;

	// Creation of decals at the point of contact between particles and the surface.
	for (int i = 0; i < emitter->getNumContacts(); i++)
	{
		ObjectPtr contact_obj = emitter->getContactObject(i);

		Math::Vec3 contact_point = emitter->getContactPoint(i);
		Math::vec3 contact_normal = emitter->getContactNormal(i);
		Math::vec3 contact_velocity = emitter->getContactVelocity(i);

		float cos_contact_angle = contact_normal.z;
		if (cos_min_spawn_angle < cos_contact_angle || cos_max_spawn_angle > cos_contact_angle) // cos(max) < cos(a) < cos(min)
			continue;

		NodePtr decal_node = decal_prefab->clone();
		decal_node->setEnabled(true);

		auto & data = decal_traces.append();
		data.node = decal_node;
		data.material = checked_ptr_cast<Decal>(decal_node)->getMaterialInherit();
		data.life = 1.0f; // 100%
		data.life_time = life_time;
		data.gravity_drag = Math::vec3_zero;
		data.ground_drag = Math::vec3_zero;
		data.ground_velocity = max(0.0f,Game::getRandomFloat(ground_speed - ground_speed_spread, ground_speed + ground_speed_spread));
		data.ground_damping = max(0.0f,Game::getRandomFloat(ground_damping - ground_damping_spread, ground_damping + ground_damping_spread));
		data.scale_velocity = grow_speed;

		bool on_ground = Math::abs(contact_normal.z - 1.0f) < Math::Consts::EPS;
		if (!on_ground)
		{
			data.gravity_drag = normalize(Math::cross(Math::cross(contact_normal, Math::vec3_down), contact_normal));
			decal_node->setWorldDirection(-contact_normal, Math::vec3_up);
		}
		else
		{
			data.ground_drag = normalize(Math::cross(Math::cross(contact_normal, contact_velocity), contact_normal));
			data.ground_velocity *= Math::saturate(dot(data.ground_drag, normalize(contact_velocity)));
		}

		// Makes the particles of the visual emitter behave according to the behavior of the particles of this emitter,
		// which are used to process the interaction.
		if (spark_emitter)
		{
			Math::vec3 direction = contact_velocity;
			direction.z = 0.0f;
			direction.normalize();

			auto dm = spark_emitter->getDirectionOverTimeModifier();
			dm->setMode(ParticleModifier::MODE::MODE_CONSTANT);
			dm->setConstant(direction);

			auto vm = spark_emitter->getVelocityOverTimeModifier();
			vm->setMode(ParticleModifier::MODE::MODE_RANDOM_BETWEEN_TWO_CONSTANTS);
			vm->setConstantMin(on_ground ? 0.8f : 0);
			vm->setConstantMax(on_ground ? 1.2f : 0);
			spark_emitter->setDirection((on_ground) ? direction : Math::vec3_zero, Math::vec3_up, AXIS_Y);
			auto lm = spark_emitter->getLinearDampingOverTimeModifier();
			lm->setMode(ParticleModifier::MODE_CONSTANT);
			lm->setConstant(spark_linear_damping);
		}

		// Set decal transform
		decal_node->setWorldPosition(contact_point + Math::Vec3(contact_normal * decal_node->getBoundSphere().radius * 1.0f));
	    decal_node->setWorldRotation(Math::quat(contact_normal, Game::getRandomFloat(0.0f, 360.0f)) * decal_node->getWorldRotation());
		decal_node->setWorldScale(Math::vec3_one * Game::getRandomFloat(min_spawn_scale, max_spawn_scale));
	}
}

void ExtinguishingPuddles::post_update()
{
	if (decal_albedo_id == -1)
			return;
	// Changing the material's transparency
	for (auto & data : decal_traces)
	{
		Math::vec4 albedo = data.material->getParameterFloat4(decal_albedo_id);
		albedo.w *= data.life;
		data.material->setParameterFloat4(decal_albedo_id, albedo);
	}
}

void ExtinguishingPuddles::shutdown()
{
	for (auto & it : decal_traces)
		it.clear();
	decal_traces.clear();
}

void ExtinguishingPuddles::update_decal_traces()
{
	float dt = Game::getIFps();

	// Reduces lifetime of excess decals
	if (decal_traces.size() > max_count)
	{
		for (int i = 0; i < decal_traces.size() - max_count; i++)
		{
			if (decal_traces[i].life_time > dead_time)
				decal_traces[i].life_time = dead_time;
		}
	}

	// Decal state update 
	for (int i = decal_traces.size() - 1; i >= 0; i--)
	{
		DecalTraceData &data = decal_traces[i];
		data.life -= dt / data.life_time;

		if (data.life <= 0.0f)
		{
			auto d = decal_traces.takeAt(i);
			d.clear();
			continue;
		}

		Math::Vec3 position = data.node->getWorldPosition();
		Math::vec3 scale = data.node->getScale();

		position += Math::Vec3(data.gravity_drag * dt * vertical_speed);
		position += Math::Vec3(data.ground_drag * dt * data.ground_velocity);

		data.ground_velocity = Math::max(0.0f, data.ground_velocity - data.ground_damping * dt);

		scale += Math::vec3_one * data.scale_velocity * dt;
		data.scale_velocity = Math::max(0.0f, data.scale_velocity - grow_damping * dt);

		data.node->setScale(scale);
		data.node->setWorldPosition(position);
	}
}

```

## FFPDepth.cpp

```cpp
#include "FFPDepth.h"

#include <UnigineFfp.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(FFPDepth)

void FFPDepth::init()
{
	Render::getEventEndVisualizer().connect(this, &FFPDepth::render_lines_callback);
}

void FFPDepth::render_lines_callback()
{
	RenderTargetPtr render_target = Renderer::getRenderTarget();
	TexturePtr texture = Renderer::getTextureColor();

	RenderState::saveState();
	RenderState::clearStates();

	// bind color texture
	render_target->bindColorTexture(0, texture);
	// bind depth texture
	// in this callback depth texture is already bound to scene

	render_target->enable();
	{
		RenderState::setDepthFunc(RenderState::DEPTH_GEQUAL);
		RenderState::setBlendFunc(RenderState::BLEND_SRC_ALPHA, RenderState::BLEND_ONE_MINUS_SRC_ALPHA);
		RenderState::flushStates();

		Ffp::enable();

		// pixel_color = vertex_color * this_texture_color
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 0, Render::getWhite2DTexture());

		mat4 projection;
		// reverse depth and convert from [-1..1] to [0..1] range
		const mat4 offset = translate(0.f, 0.f, 0.5f) * scale(1.f, 1.f, 0.5f);
		mul(projection, offset, reverseDepthProjection((Renderer::getProjectionWithoutTAA())));

		Ffp::setTransform(projection);

		auto model_view = Renderer::getModelview();

		const unsigned col_argb = 0xffff0000;

		Ffp::beginLines();
		Ffp::addLines(1);

		Ffp::Vertex vert;

		// transform to camera space
		vec3(model_view * vec3(-0.5f, -0.3f, 0.65f)).get(vert.xyz);
		Ffp::addVertex(vert);
		Ffp::setColor(col_argb);

		vec3(model_view * vec3(0.5f, -0.3f, 0.65f)).get(vert.xyz);
		Ffp::addVertex(vert);
		Ffp::setColor(col_argb);


		Ffp::endLines();
		Ffp::disable();

	}
	render_target->disable();
	render_target->unbindColorTextures();
	RenderState::restoreState();
}

```

## FFPSample.cpp

```cpp
#include "FFPSample.h"

#include <UnigineFfp.h>
#include <UnigineGame.h>

using namespace Unigine;
using namespace Unigine::Math;

REGISTER_COMPONENT(FFPSample)

void FFPSample::init()
{

	// we want to render after engine finished render
	Engine::get()->getEventEndPluginsGui().connect(*this, &FFPSample::render);
}

void FFPSample::render()
{
	Ffp::setTextureSample(1);
	const EngineWindowViewportPtr window = WindowManager::getMainWindow();
	const auto time = Game::getTime();
	// screen size
	const int width = window->getClientRenderSize().x;
	const int height = window->getClientRenderSize().y;
	const float radius = height / 2.0f;

	Ffp::enable(Ffp::MODE_SOLID);
	Ffp::setOrtho(width, height);

	// begin triangles
	Ffp::beginTriangles();

	// vertex colors
	constexpr unsigned int colors[] = {0xffff0000, 0xff00ff00, 0xff0000ff};

	// create vertices
	constexpr int num_vertex = 16;
	for (int i = 0; i < num_vertex; i++)
	{
		const float angle = Consts::PI2 * i / (num_vertex - 1) - time;
		const float x = width / 2 + sinf(angle) * radius;
		const float y = height / 2 + cosf(angle) * radius;
		Ffp::addVertex(x, y);
		Ffp::setColor(colors[i % 3]);
	}

	// create indices
	for (int i = 1; i < num_vertex; i++)
	{
		Ffp::addIndex(0);
		Ffp::addIndex(i);
		Ffp::addIndex(i - 1);
	}

	// end triangles
	Ffp::endTriangles();

	Ffp::disable();
}

```

## FMODCoreSample.cpp

```cpp
#include "FMODCoreSample.h"

#include <UnigineVisualizer.h>
#include <UniginePrimitives.h>

REGISTER_COMPONENT(FMODCoreSample);

using namespace Unigine;
using namespace Math;
using namespace Unigine::Plugins::FMOD;

void FMODCoreSample::init()
{
	sample_description_window.createWindow(Gui::ALIGN_LEFT, 500);

	// load the FMOD plugin
	if(Engine::get()->findPlugin("UnigineFMOD") == -1)
		Engine::get()->addPlugin("UnigineFMOD");
	if (!FMOD::checkPlugin())
	{
		WidgetGroupBoxPtr parameters_groupbox = sample_description_window.getParameterGroupBox();

		auto info_label = WidgetLabel::create();
		info_label->setFontWrap(1);
		info_label->setText("Cannot find FMOD plugin. Please check UnigineFMOD and fmod.dll, fmodL.dll, fmodstudio.dll, fmodstudioL.dll (You can download these files from official site) in bin directory.");

		parameters_groupbox->addChild(info_label);

		return;
	}

	plugin_initialized = true;

	// initialize FMOD Core with 1024 channels in NORMAL mode
	FMODCore *core = FMOD::get()->getCore();
	core->initCore(1024, FMODEnums::NORMAL);

	// load a 2D sound file
	music_sound = core->createSound(
		FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_core/sounds/soundtrack.oga")),
		FMODEnums::_2D);

	// load the same file as a 3D sound
	music_sound_3D = core->createSound(
		FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_core/sounds/soundtrack.oga")),
		FMODEnums::_3D);

	// create a sphere to visualize the 3D sound source
	car_sphere = Primitives::createSphere(1.0f);
	car_sphere->setMaterialParameterFloat4("albedo_color", vec4(0.4f, 0.0f, 0.0f, 1.0f), 0);

	Visualizer::setEnabled(true);
	init_description_window();
}

void FMODCoreSample::update()
{
	if (!plugin_initialized)
		return;

	// display the "Music 3D" label above the car sphere in the 3D world
	auto len = music_sound->getLength(FMODEnums::TIME_UNIT::MS);
	Visualizer::renderMessage3D(car_sphere->getWorldPosition(), vec3_zero, "Music 3D", vec4_white, 0, 25);

	// update music progress slider
	unsigned int pos;
	if (music_channel)
	{
		music_channel->getPositionTimeLine(pos, FMODEnums::TIME_UNIT::MS);
		int progress = ftoi(pos / itof(len) * 100);
		if (progress >= 100)
		{
			music_channel->setPositionTimeLine(0, FMODEnums::TIME_UNIT::MS);
			stop_music();
			progress = 0;
		}
		music_position_slider->setValue(progress);
	}
}

void FMODCoreSample::shutdown()
{
	// release all FMOD sounds and channels
	if (music_sound)
	{
		music_sound->release();
		music_sound = nullptr;
	}

	if (music_sound_3D)
	{
		music_sound_3D->release();
		music_sound_3D = nullptr;
	}

	if (music_channel)
	{
		music_channel->release();
		music_channel = nullptr;
	}

	if (music_channel_3D)
	{
		music_channel_3D->release();
		music_channel_3D = nullptr;
	}

	// unload the FMOD plugin
	int idx = Engine::get()->findPlugin("UnigineFMOD");
	if (idx != -1)
	{
		Plugin *plugin = Engine::get()->getPluginInterface(idx);
		Engine::get()->destroyPlugin(plugin);
	}
	plugin_initialized = false;

	car_sphere.deleteLater();
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

void FMODCoreSample::init_description_window()
{
	// create GUI tabs and controls
	WidgetGroupBoxPtr parameters_groupbox = sample_description_window.getParameterGroupBox();
	WidgetTabBoxPtr tab = WidgetTabBox::create(4, 4);
	parameters_groupbox->addChild(tab, Gui::ALIGN_EXPAND);

	// tab music
	{
		tab->addTab("Music");

		// playback controls
		auto play_button = WidgetButton::create("Play");
		auto stop_button = WidgetButton::create("Stop");
		auto pause_button = WidgetButton::create("Pause/Resume");
		auto plus_button = WidgetButton::create("+ 10 sec");
		auto minus_button = WidgetButton::create("- 10 sec");

		auto hbox = WidgetHBox::create();
		play_button->getEventClicked().connect(this, &FMODCoreSample::play_music);
		stop_button->getEventClicked().connect(this, &FMODCoreSample::stop_music);
		pause_button->getEventClicked().connect(this, &FMODCoreSample::toggle_pause_music);

		minus_button->getEventClicked().connect(this, &FMODCoreSample::minus_ms);
		plus_button->getEventClicked().connect(this, &FMODCoreSample::plus_ms);

		music_position_slider = WidgetSlider::create();

		distortion_slider = WidgetSlider::create();
		distortion_slider->getEventChanged().connect(this, &FMODCoreSample::distortion_changed);

		volume_slider = WidgetSlider::create();
		volume_slider->getEventChanged().connect(this, &FMODCoreSample::volume_changed);
		volume_slider->setValue(100);
		hbox->addChild(minus_button);
		hbox->addChild(plus_button);

		tab->addChild(WidgetLabel::create("Time Line"), Gui::ALIGN_EXPAND);
		tab->addChild(music_position_slider, Gui::ALIGN_EXPAND);


		tab->addChild(hbox, Gui::ALIGN_EXPAND);
		tab->addChild(play_button, Gui::ALIGN_EXPAND);
		tab->addChild(stop_button, Gui::ALIGN_EXPAND);
		tab->addChild(pause_button, Gui::ALIGN_EXPAND);

		tab->addChild(WidgetLabel::create("Distortion Mix"), Gui::ALIGN_EXPAND);
		tab->addChild(distortion_slider, Gui::ALIGN_EXPAND);

		tab->addChild(WidgetLabel::create("Volume"), Gui::ALIGN_EXPAND);
		tab->addChild(volume_slider, Gui::ALIGN_EXPAND);
	}

	// tab music 3D
	{
		tab->addTab("Music 3D");
		auto play_button = WidgetButton::create("Play");
		auto stop_button = WidgetButton::create("Stop");
		auto pause_button = WidgetButton::create("Pause/Resume");

		auto hbox = WidgetHBox::create();
		play_button->getEventClicked().connect(this, &FMODCoreSample::play_music_3D);
		stop_button->getEventClicked().connect(this, &FMODCoreSample::stop_music_3D);
		pause_button->getEventClicked().connect(this, &FMODCoreSample::toggle_pause_music_3D);

		tab->addChild(play_button, Gui::ALIGN_EXPAND);
		tab->addChild(stop_button, Gui::ALIGN_EXPAND);
		tab->addChild(pause_button, Gui::ALIGN_EXPAND);
	}

	parameters_groupbox->arrange();
}

void FMODCoreSample::distortion_changed()
{
	if (!music_channel)
	{
		return;
	}

	// adjust distortion effect on the music channel
	music_channel->getDSP(0)->setParameterFloat(0, distortion_slider->getValue() * 0.01f);
}

void FMODCoreSample::volume_changed()
{
	if (!music_channel)
	{
		return;
	}

	// adjust volume on the music channel
	music_channel->setVolume(volume_slider->getValue() * 0.01f);
}

void FMODCoreSample::plus_ms()
{
	if (!music_channel)
	{
		return;
	}

	// jump forward by 10 seconds in the timeline
	unsigned int curr_time_line;
	unsigned int len = music_sound->getLength(FMODEnums::TIME_UNIT::MS);
	music_channel->getPositionTimeLine(curr_time_line, FMODEnums::TIME_UNIT::MS);
	if (curr_time_line + 10000 >= len)
	{
		music_channel->setPositionTimeLine(0, FMODEnums::TIME_UNIT::MS);
	} else
	{
		music_channel->setPositionTimeLine(curr_time_line + 10000, FMODEnums::TIME_UNIT::MS);
	}
}

void FMODCoreSample::minus_ms()
{
	if (!music_channel)
	{
		return;
	}

	// jump backward by 10 seconds in the timeline
	unsigned int curr_time_line;
	music_channel->getPositionTimeLine(curr_time_line, FMODEnums::TIME_UNIT::MS);
	if (curr_time_line < 10000)
	{
		music_channel->setPositionTimeLine(0, FMODEnums::TIME_UNIT::MS);
	} else
	{
		music_channel->setPositionTimeLine(curr_time_line - 10000, FMODEnums::TIME_UNIT::MS);
	}
}

void FMODCoreSample::play_music()
{
	// start 2D music playback if 3D music is not playing
	// adds a distortion DSP effect and sets the volume
	if (!music_channel_3D || !music_channel_3D->isPlaying())
	{
		stop_music();

		music_channel = music_sound->play();
		music_channel->addDSP(0, DSPType::DISTORTION)->setParameterFloat(0, distortion_slider->getValue() * 0.01f);
		music_channel->setVolume(volume_slider->getValue() * 0.01f);
	}
}

void FMODCoreSample::stop_music()
{
	if (!music_channel)
	{
		return;
	}

	music_channel->stop();
	music_channel = nullptr;
}

void FMODCoreSample::toggle_pause_music()
{
	if (!music_channel)
	{
		return;
	}

	music_channel->setPaused(!music_channel->isPaused());
}

void FMODCoreSample::play_music_3D()
{
	// start 3D music playback at the car_sphere position
	if (!music_channel || !music_channel->isPlaying())
	{
		stop_music_3D();

		music_channel_3D = music_sound_3D->play();
		music_channel_3D->setPosition(car_sphere->getWorldPosition());
	}
}

void FMODCoreSample::stop_music_3D()
{
	if (!music_channel_3D)
	{
		return;
	}

	music_channel_3D->stop();
	music_channel_3D = nullptr;
}

void FMODCoreSample::toggle_pause_music_3D()
{
	if (!music_channel_3D)
	{
		return;
	}

	music_channel_3D->setPaused(!music_channel_3D->isPaused());
}

```

## FMODStudioSample.cpp

```cpp
#include "FMODStudioSample.h"

#include <UnigineVisualizer.h>
#include <UniginePrimitives.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(FMODStudioSample);

using namespace Unigine;
using namespace Math;
using namespace Unigine::Plugins::FMOD;

void FMODStudioSample::init()
{
	sample_description_window.createWindow(Gui::ALIGN_LEFT, 500);

	// load the FMOD plugin
	if (Engine::get()->findPlugin("UnigineFMOD") == -1)
		Engine::get()->addPlugin("UnigineFMOD");
	if (!FMOD::checkPlugin())
	{
		WidgetGroupBoxPtr parameters_groupbox = sample_description_window.getParameterGroupBox();

		auto info_label = WidgetLabel::create();
		info_label->setFontWrap(1);
		info_label->setText("Cannot find FMOD plugin. Please check UnigineFMOD and fmod.dll, fmodL.dll, fmodstudio.dll, fmodstudioL.dll (You can download these files from official site) in bin directory.");

		parameters_groupbox->addChild(info_label);

		return;
	}

	plugin_initialized = true;

	// create two spheres: one static (car) and one moving (doppler)
	car_sphere = Primitives::createSphere(2.0f);
	car_sphere->setMaterialParameterFloat4("albedo_color", vec4(0.4f, 0.0f, 0.0f, 1.0f), 0);

	doppler_sphere = Primitives::createSphere(1.0f);
	doppler_sphere->setMaterialParameterFloat4("albedo_color", vec4(0.0f, 4.0f, 0.0f, 1.0f), 0);
	doppler_sphere->setWorldPosition(start_point);

	// initialize FMOD Studio and load sound banks
	FMODStudio *studio = FMOD::get()->getStudio();
	studio->useStudioLiveUpdateFlag();
	studio->initStudio();
	studio->loadBank(FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_studio/fmod_banks/Master.bank")));
	studio->loadBank(FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_studio/fmod_banks/Master.strings.bank")));
	studio->loadBank(FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_studio/fmod_banks/Vehicles.bank")));
	studio->loadBank(FileSystem::getAbsolutePath(FileSystem::resolvePartialVirtualPath("fmod_studio/fmod_banks/SFX.bank")));

	// play ambient forest and engine events
	forest_event = studio->getEvent("event:/Ambience/Forest");
	forest_event->play();

	engine_event = studio->getEvent("event:/Vehicles/Car Engine");
	engine_event->play();

	// doppler effect setup
	doppler_engine_event = studio->getEvent("event:/Vehicles/Car Engine");
	doppler_engine_event->setParent(doppler_sphere);
	doppler_engine_event->setParameter("RPM", 4000);

	// initial movement direction
	velocity = -Vec3_forward;

	// load VCA for master environmental volume
	env_vca = studio->getVCA("vca:/Environment");

	Visualizer::setEnabled(true);
	init_description_window();
}

void FMODStudioSample::update()
{
	if (!plugin_initialized)
		return;

	float dt = Game::getIFps();

	// Doppler simulation logic
	if (show_doppler_box_check_box->isChecked())
	{
		doppler_sphere->setEnabled(true);

		// reset position after 2.5 seconds
		if (timer >= 2.5f)
		{
			doppler_sphere->setWorldPosition(start_point);
			timer = 0.0f;
		}
		timer += dt;

		// restart Doppler sound if not playing
		if (!doppler_engine_event->isPlaying() && !doppler_engine_event->isStarting())
		{
			doppler_engine_event->play();
		}

		// move the Doppler object and update sound velocity
		doppler_sphere->setWorldPosition(doppler_sphere->getWorldPosition() + velocity);
		doppler_engine_event->setVelocity(velocity);
		Visualizer::renderMessage3D(doppler_sphere->getWorldPosition(), vec3_zero, "Doppler", vec4_white, 0, 20);
	} else
	{
		doppler_engine_event->stop();
		doppler_sphere->setEnabled(false);
	}

	// show label above the car
	Visualizer::renderMessage3D(car_sphere->getWorldPosition(), vec3_zero, "Car", vec4_white, 0, 20);
}

void FMODStudioSample::shutdown()
{
	// release all FMOD events
	if (engine_event)
	{
		engine_event->release();
		engine_event = nullptr;
	}

	if (doppler_engine_event)
	{
		doppler_engine_event->release();
		doppler_engine_event = nullptr;
	}

	if (forest_event)
	{
		forest_event->release();
		forest_event = nullptr;
	}

	if (env_vca)
	{
		env_vca->release();
		env_vca = nullptr;
	}

	// unload the FMOD plugin
	int idx = Engine::get()->findPlugin("UnigineFMOD");
	if (idx != -1)
	{
		Plugin *plugin = Engine::get()->getPluginInterface(idx);
		Engine::get()->destroyPlugin(plugin);
	}
	plugin_initialized = false;

	car_sphere.deleteLater();
	doppler_sphere.deleteLater();
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

void FMODStudioSample::init_description_window()
{
	// create GUI tabs and controls
	WidgetGroupBoxPtr parameters_groupbox = sample_description_window.getParameterGroupBox();
	WidgetTabBoxPtr tab = WidgetTabBox::create(4, 4);
	parameters_groupbox->addChild(tab, Gui::ALIGN_EXPAND);

	// ambience tab
	{
		tab->addTab("Ambience");
		wind_forest_slider = WidgetSlider::create();
		auto wind_label = WidgetLabel::create( "Wind");
		tab->addChild(wind_label, Gui::ALIGN_EXPAND);
		tab->addChild(wind_forest_slider, Gui::ALIGN_EXPAND);
		wind_forest_slider->getEventChanged().connect(this, &FMODStudioSample::wind_forest_slider_changed);

		rain_forest_slider = WidgetSlider::create();
		auto forest_label = WidgetLabel::create("Rain");
		tab->addChild(forest_label, Gui::ALIGN_EXPAND);
		tab->addChild(rain_forest_slider, Gui::ALIGN_EXPAND);
		rain_forest_slider->getEventChanged().connect(this, &FMODStudioSample::rain_forest_slider_changed);

		cover_forest_slider = WidgetSlider::create();
		auto cover_label = WidgetLabel::create("Cover");
		tab->addChild(cover_label, Gui::ALIGN_EXPAND);
		tab->addChild(cover_forest_slider, Gui::ALIGN_EXPAND);
		cover_forest_slider->getEventChanged().connect(this, &FMODStudioSample::cover_forest_slider_changed);
	}

	// engine tab
	{
		tab->addTab("Engine");
		engine_slider = WidgetSlider::create();
		engine_slider->setMinValue(0);
		engine_slider->setMaxValue(8000);
		auto label = WidgetLabel::create("RPM");
		tab->addChild(label, Gui::ALIGN_EXPAND);
		tab->addChild(engine_slider, Gui::ALIGN_EXPAND);
		engine_slider->getEventChanged().connect(this, &FMODStudioSample::engine_slider_changed);
	}

	// doppler tab
	{
		tab->addTab("Doppler");
		show_doppler_box_check_box = WidgetCheckBox::create();
		show_doppler_box_check_box->setChecked(false);
		auto label = WidgetLabel::create("Show Doppler Effect");
		tab->addChild(label, Gui::ALIGN_EXPAND);
		tab->addChild(show_doppler_box_check_box, Gui::ALIGN_EXPAND);
		doppler_rpm_slider = WidgetSlider::create();
		doppler_velocity_slider = WidgetSlider::create();
		doppler_rpm_slider->setMaxValue(8000);
		doppler_rpm_slider->setValue(4000);
		tab->addChild(WidgetLabel::create("RPM"), Gui::ALIGN_EXPAND);
		tab->addChild(doppler_rpm_slider, Gui::ALIGN_EXPAND);

		tab->addChild(WidgetLabel::create("Velocity"), Gui::ALIGN_EXPAND);
		tab->addChild(doppler_velocity_slider, Gui::ALIGN_EXPAND);

		doppler_rpm_slider->getEventChanged().connect(this, &FMODStudioSample::doppler_rpm_slider_changed);
		doppler_velocity_slider->getEventChanged().connect(this, &FMODStudioSample::doppler_velocity_slider_changed);
		doppler_velocity_slider->setValue(5);
	}

	// vca tab
	{
		tab->addTab("VCA");
		env_vca_slider = WidgetSlider::create();
		env_vca_slider->setValue(100);
		auto label = WidgetLabel::create("Sounds Volume");
		tab->addChild(label, Gui::ALIGN_EXPAND);
		tab->addChild(env_vca_slider, Gui::ALIGN_EXPAND);
		env_vca_slider->getEventChanged().connect(this, &FMODStudioSample::env_vca_slider_changed);
	}

	parameters_groupbox->arrange();
}

void FMODStudioSample::env_vca_slider_changed()
{
	// adjust environment volume
	env_vca->setVolume(env_vca_slider->getValue() * 0.01f);
}

void FMODStudioSample::engine_slider_changed()
{
	// set RPM for engine event
	engine_event->setParameter("RPM", itof(engine_slider->getValue()));
}

void FMODStudioSample::wind_forest_slider_changed()
{
	// set wind intensity in forest ambience
	forest_event->setParameter("Wind", wind_forest_slider->getValue() * 0.01f);
}

void FMODStudioSample::rain_forest_slider_changed()
{
	// set rain intensity in forest ambience
	forest_event->setParameter("Rain", rain_forest_slider->getValue() * 0.01f);
}

void FMODStudioSample::cover_forest_slider_changed()
{
	// set cover parameter in forest ambience
	forest_event->setParameter("Cover", cover_forest_slider->getValue() * 0.01f);
}

void FMODStudioSample::doppler_rpm_slider_changed()
{
	// set RPM for Doppler engine event
	doppler_engine_event->setParameter("RPM", itof(doppler_rpm_slider->getValue()));
}

void FMODStudioSample::doppler_velocity_slider_changed()
{
	// adjust velocity of Doppler object
	velocity.y = -doppler_velocity_slider->getValue() * 0.1f;
}

```

## FilesSample.cpp

```cpp
#include "FilesSample.h"

using namespace Unigine;
using namespace Math;

// Here you can see how to perform basic file I/O

//-----------------------------------------------------------
void writeTextToFile(const String &content, const String &filepath)
{
	// create a file
	const FilePtr file = File::create();
	// open file with specified filepath and mode
	if (!file->open(filepath, "wb"))
	{
		Log::error("writeTextToFile: Failed to open file %s\n", filepath.get());
		return;
	}
	file->writeString(content.get());

	if (!file->close())
	{
		Log::error("writeTextToFile: Failed to close file %s\n", filepath.get());
	}
}

String readTextFromFile(const String &filepath)
{
	const FilePtr file = File::create();
	if (!file->open(filepath, "rb"))
	{
		Log::error("readTextFromFile: Failed to open file %s", filepath.get());
		return "";
	}
	String content = file->readString();

	if (!file->close())
	{
		Log::error("readTextFromFile: Failed to close file %s\n", filepath.get());
	}
	return content;
}


// Sample Logic
//-----------------------------------------------------------

REGISTER_COMPONENT(FilesSample)

void FilesSample::init()
{
	create_reader();
	create_writer();
}

void FilesSample::shutdown()
{
	writer.deleteLater();
	reader.deleteLater();
}

void FilesSample::create_writer()
{
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();
	GuiPtr gui = main_window->getGui();

	writer = WidgetWindow::create(gui, "Writer");
	writer->setWidth(300);
	writer->setHeight(150);
	gui->addChild(writer, Gui::ALIGN_OVERLAP);
	writer->setPosition(widget_padding, main_window->getSize().y / 2);

	WidgetEditLinePtr edit_line = WidgetEditLine::create(gui, readTextFromFile(filepath.get()));
	edit_line->setCapacity(1000);
	writer->addChild(edit_line, Gui::ALIGN_TOP | Gui::ALIGN_EXPAND);
	edit_line->setText(readTextFromFile(filepath.get()));

	WidgetButtonPtr write_button = WidgetButton::create(gui, "Write");
	write_button->getEventClicked().connect(*this, [edit_line, this] {
		const char *content = edit_line->getText();
		writeTextToFile(content, filepath.get());
	});
	writer->addChild(write_button, Gui::ALIGN_CENTER | Gui::ALIGN_BOTTOM);
}

void FilesSample::create_reader()
{
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();
	GuiPtr gui = main_window->getGui();

	reader = WidgetWindow::create(gui, "Reader");
	reader->setWidth(300);
	reader->setHeight(150);
	gui->addChild(reader, Gui::ALIGN_OVERLAP);
	reader->setPosition(main_window->getSize().x - reader->getWidth() - widget_padding,
		main_window->getSize().y / 2);
	WidgetLabelPtr label = WidgetLabel::create(gui, "");
	label->setEnabled(false);
	reader->addChild(label, Gui::ALIGN_TOP | Gui::ALIGN_EXPAND);
	WidgetButtonPtr read_button = WidgetButton::create(gui, "Read");

	const auto read_file = [label, this] {
		label->setText(readTextFromFile(filepath.get()));
	};

	read_button->getEventClicked().connect(*this, read_file);
	read_file();
	reader->addChild(read_button, Gui::ALIGN_CENTER | Gui::ALIGN_BOTTOM);
}

```

## FireHoseSample.cpp

```cpp
#include "FireHoseSample.h"
#include "ExtinguishingPuddles.h"
#include "UnigineGame.h"

REGISTER_COMPONENT(FireHoseSample);

using namespace Unigine;
using namespace Math;

void FireHoseSample::init()
{
	description_window.createWindow();

	WidgetCheckBoxPtr rotate_check = WidgetCheckBox::create();
	rotate_check->setText(" Rotate");
	rotate_check->setChecked(emitter_rotate);
	rotate_check->getEventChanged().connect(*this, [this, rotate_check]() {
		if (emitter)
		{
			emitter_rotate = rotate_check->isChecked();
			emitter->setRotation(quat(vec3_up, 0));
			if (rotate_check->isChecked())
				time_start = Game::getTime();
		}
		});

	description_window.getParameterGroupBox()->addChild(rotate_check, Gui::ALIGN_LEFT);

	description_window.addFloatParameter("Angle", "", 0.0f, -50.0f, 50.0f, [this](float value) {
		if (emitter && !emitter_rotate)
		{
			emitter->setRotation(quat(vec3_up, -value ));
		}
		});
	
}

void FireHoseSample::update()
{
	if (emitter && emitter_rotate)
	{
		float delta = 11.0f * Game::getIFps();
		emitter->rotate(quat(emitter->getWorldDirection(AXIS_Z), delta * ((cosf((Game::getTime() - time_start) / 3)) > 0.0f ? 1 : -1)));
	}
}

void FireHoseSample::shutdown()
{
	description_window.shutdown();
}

```

## FirstPersonController.cpp

```cpp
#include "FirstPersonController.h"
#include <UnigineGame.h>
#include <UnigineVisualizer.h>
#include <UnigineProfiler.h>
#include <UnigineConsole.h>
#include <UnigineInput.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(FirstPersonController)

void FirstPersonController::setWorldTransform(const Unigine::Math::Mat4 &t)
{
	// fix player transformation
	// player can only have vertical position, Y axis is used for forward direction
	Vec3 axis_y = t.getAxisY();
	axis_y.z = 0;
	axis_y = (axis_y.length2() > Consts::EPS ? axis_y.normalize() : Vec3_forward);
	node->setWorldTransform(setTo(t.getTranslate(), t.getTranslate() + axis_y, vec3_up, AXIS_Y));

	if (camera && camera_mode != CameraMode::NONE)
	{
		camera_vertical_angle = getAngle(vec3_down, static_cast<vec3>(-t.getAxisZ()));
		camera_vertical_angle = clamp(camera_vertical_angle, min_vertical_angle + 90.0f, max_vertical_angle + 90.0f);

		camera_horizontal_angle = node->getWorldRotation().getAngle(vec3_up);

		vec3 camera_direction = vec3_forward * rotateZ(-camera_horizontal_angle);
		camera_direction = camera_direction * rotate(cross(camera_direction, vec3_up), 90.0f - camera_vertical_angle);
		camera_direction.normalize();
		camera->setWorldDirection(camera_direction, vec3_up);
	}
}

void FirstPersonController::init()
{
	// check object type
	ObjectPtr obj = checked_ptr_cast<Object>(node);
	if (!obj)
	{
		Log::error("FirstPersonController: can't cast node to Object\n");
		return;
	}

	// fix player transformation
	// player can only have vertical position, Y axis is used for forward direction
	Vec3 axis_y = obj->getWorldTransform().getAxisY();
	axis_y.z = 0;
	axis_y = (axis_y.length2() > Consts::EPS ? axis_y.normalize() : Vec3_forward);
	obj->setWorldTransform(setTo(node->getWorldPosition(), node->getWorldPosition() + axis_y, vec3_up, AXIS_Y));

	// set dummy body
	if (use_object_body)
	{
		body = checked_ptr_cast<BodyDummy>(obj->getBody());
		if (!body)
			Log::warning("FirstPersonController: object doesn't contain BodyDummy, it was created automatically\n");
	}

	if (!body)
	{
		body = BodyDummy::create(obj);
		body->setTransform(obj->getWorldTransform());
	}

	// set capsule shape
	if (use_object_body)
	{
		if (body->getNumShapes() > 0)
		{
			for (int i = 0; i < body->getNumShapes(); i++)
				if (!shape)
					shape = checked_ptr_cast<ShapeCapsule>(body->getShape(i));

			if (!shape)
				Log::warning("FirstPersonController: body doesn't contain ShapeCapsule, it was created automatically\n");
		}
		else
			Log::warning("FirstPersonController: body doesn't contain shapes, it was created automatically\n");
	}

	if (!shape)
	{
		shape = ShapeCapsule::create(body, capsule_radius, capsule_height);
		body->setShapeTransform(body->getNumShapes() - 1, translate(vec3_up * (capsule_radius + 0.5f * capsule_height)));

		shape->setPhysicsIntersectionMask(physics_intersection_mask);
		shape->setCollisionMask(collision_mask);
		shape->setExclusionMask(exclusion_mask);
	}

	capsule_height = shape->getHeight();
	crouch_height = clamp(crouch_height, 2.0f * shape->getRadius(), shape->getHeight() + 2.0f * shape->getRadius());
	crouch_state.current_height = shape->getHeight() + 2.0f * shape->getRadius();
	crouch_state.start_height = crouch_state.current_height;
	crouch_state.end_height = crouch_height.get();

	// set camera
	camera = checked_ptr_cast<PlayerDummy>(camera_editor_node.get());

	if (camera_mode == CameraMode::USE_EXTERNAL && !camera)
		Log::warning("FirstPersonController: camera is null, it was created automatically\n");

	if (!camera || camera_mode == CameraMode::CREATE_AUTOMATICALLY)
	{
		camera = PlayerDummy::create();
		camera->setParent(obj);
		camera->setFov(fov);
		camera->setZNear(near_clipping);
		camera->setZFar(far_clipping);

		camera->setWorldPosition(obj->getWorldTransform() * Vec3(camera_position_offset));
		camera->setWorldDirection(vec3(axis_y), vec3_up);

		camera->setMainPlayer(true);
	}

	if (camera && camera_mode != CameraMode::NONE)
	{
		camera_vertical_angle = getAngle(vec3_down, camera->getWorldDirection());
		camera_vertical_angle = clamp(camera_vertical_angle, min_vertical_angle + 90.0f, max_vertical_angle + 90.0f);

		camera_horizontal_angle = node->getWorldRotation().getAngle(vec3_up);
		camera_position_offset = vec3(node->getIWorldTransform() * camera->getWorldPosition());

		vec3 camera_direction = vec3_forward * rotateZ(-camera_horizontal_angle);
		camera_direction = camera_direction * rotate(cross(camera_direction, vec3_up), 90.0f - camera_vertical_angle);
		camera_direction.normalize();
		camera->setWorldDirection(camera_direction, vec3_up);
	}

	// create cylinder shape for interacting with objects
	if (use_objects_interaction)
	{
		interaction_shape = ShapeCylinder::create();
		interaction_shape->setEnabled(false);
	}

	// set auxiliary parameters
	player_ifps = 1.0f / player_fps;
	crouch_transition_time = max(crouch_transition_time, Consts::EPS);

	cos_ground_angle = Math::cos(max_ground_angle * Math::Consts::DEG2RAD);
	cos_ceiling_angle = Math::cos(max_ceiling_angle * Math::Consts::DEG2RAD);
	cos_stair_angle = Math::cos(max_stair_angle * Math::Consts::DEG2RAD);
	cos_stairs_detection_angle = Math::cos(stairs_detection_angle * Math::Consts::DEG2RAD + Math::Consts::PI05);
	cos_wall_stop_sliding_angle = Math::cos(wall_stop_sliding_angle * Math::Consts::DEG2RAD);

	normal_intersection = WorldIntersectionNormal::create();

#if DEBUG
	max_pass_contacts = contacts_buffer_size;
#endif

	world_transform = obj->getWorldTransform();

	for (int i = 0; i < Input::getNumGamePads(); i++)
	{
		if (Input::getGamePad(i)->isAvailable())
		{
			game_pad = Input::getGamePad(i);
			break;
		}
	}

	is_initialized = true;

#if DEBUG
	init_debug();
#endif
}

void FirstPersonController::update()
{
	if (!is_initialized)
		return;

	world_transform = node->getWorldTransform();

	float ifps = Game::getIFps() * Physics::getScale();

	update_move_directions(ifps);
	check_move_and_stair();

	if (!is_available_side_move)
	{
		if (has_bottom_contacts)
		{
			horizontal_velocity = Vec3_zero;
			horizontal_move_direction = vec2_zero;
		}
	}

	float update_time = ifps;
	has_bottom_contacts = false;
	while (update_time > 0.0f)
	{
		float adaptive_time_step = min(update_time, player_ifps);
		update_time -= adaptive_time_step;

		update_velocity(adaptive_time_step, adaptive_time_step / ifps);
		mul(world_transform, translate((horizontal_velocity + Vec3_up * vertical_velocity) * adaptive_time_step), world_transform);
		update_collisions(adaptive_time_step);
	}

	update_crouch(ifps);

	// update player transformation
	node->setWorldTransform(world_transform);
	body->setTransform(node->getWorldTransform());
	if (is_crouch)
		shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f)));

	update_camera();

#if DEBUG
	update_debug();
#endif
}

void FirstPersonController::update_physics()
{
	if (!is_initialized)
		return;

	if (use_objects_interaction)
	{
		// enable interaction cylinder shape and set parameters
		// this shape is slightly larger than the capsule shape
		// this allows to get more correct contacts with objects, especially with bottom of player
		interaction_shape->setEnabled(true);
		interaction_shape->setRadius(shape->getRadius() + check_move_ray_offset + skin_width_offset);
		interaction_shape->setHeight(shape->getHeight() + 2.0f * (shape->getRadius() + check_move_ray_offset - skin_width_offset));
		interaction_shape->setTransform(translate(world_transform.getTranslate() + Vec3_up * (0.5f * interaction_shape->getHeight() + skin_width_offset)));

		interaction_shape->getCollision(contacts);
		int contacts_count = min(contacts_buffer_size, contacts.size());

		Scalar speed = horizontal_velocity.length() + Math::abs(vertical_velocity);
		speed = max(speed, static_cast<Scalar>(1.0f));

		// multiply by 0.5f only for normalization impulse multiplier in editor settings
		float k = player_mass * impulse_multiplier * 0.5f;
		if (contacts_count > 0)
			k /= contacts_count;

		float top_cap_z = shape->getTopCap().z;
		for (int i = 0; i < contacts_count; i++)
		{
			const ShapeContactPtr &c = contacts[i];
			if (auto contact_object = c->getObject())
			{
				if (auto rb = contact_object->getBodyRigid())
				{
					Vec3 point = c->getPoint();
					if (ignore_top_contacts && point.z > top_cap_z)
						continue;

					rb->setFrozen(false);
					rb->addWorldImpulse(point, -c->getNormal() * k * speed);
				}
			}
		}

		interaction_shape->setEnabled(false);
	}
}

void FirstPersonController::update_move_directions(float ifps)
{
	// reset all directions
	horizontal_move_direction = vec2_zero;
	vertical_move_direction = 0.0f;

	if (!Input::isMouseGrab())
		return;

	// update horizontal direction
	if (Input::isKeyPressed(static_cast<Input::KEY>(forward_key.get())))
		horizontal_move_direction += forward;

	if (Input::isKeyPressed(static_cast<Input::KEY>(backward_key.get())))
		horizontal_move_direction -= forward;

	if (Input::isKeyPressed(static_cast<Input::KEY>(right_key.get())))
		horizontal_move_direction += right;

	if (Input::isKeyPressed(static_cast<Input::KEY>(left_key.get())))
		horizontal_move_direction -= right;

	horizontal_move_direction.normalize();

	if (game_pad)
	{
		vec2 moveValue = (move_stick == GamepadStickSide::LEFT ? game_pad->getAxesLeft() : game_pad->getAxesRight());
		if (moveValue.length() > sticks_dead_zone && moveValue.length2() > horizontal_move_direction.length2())
			horizontal_move_direction = moveValue;
	}

	// update vertical direction
	if (use_jump && is_ground && (Input::isKeyDown(static_cast<Input::KEY>(jump_key.get())) ||
		game_pad && game_pad->isButtonDown(static_cast<Input::GAMEPAD_BUTTON>(jump_button.get()))))
	{
		vertical_move_direction = (is_crouch ? crouch_jump_power : jump_power) / ifps;
	}
}

void FirstPersonController::check_move_and_stair()
{
	is_available_side_move = false;
	is_available_stair = false;

	vec3 horizontal_direction = world_transform.getRotate() * vec3(horizontal_move_direction);
	horizontal_move_direction.normalize();

	// check angle of surface for possible movement
	if (horizontal_move_direction.length2() > 0.0f)
	{
		Vec3 p2 = world_transform.getTranslate() + Vec3(horizontal_direction) * (static_cast<Scalar>(shape->getRadius()) + check_move_ray_offset) + Vec3_down * Scalar(check_move_ray_offset.get());
		Vec3 p1 = p2 + Vec3_up * (max(shape->getRadius(), max_step_height) + check_move_ray_offset);

		auto hitObj = World::getIntersection(p1, p2, check_move_mask, normal_intersection);
		if (hitObj)
		{
			if (dot(vec3_up, normal_intersection->getNormal()) > cos_ground_angle)
				is_available_side_move = true;

			// this check allows movement through elevations
			Scalar cos = dot(slope_normal, Vec3(normal_intersection->getNormal()));
			if (cos < large_epsilon)
				is_available_side_move = true;
		}
		else
		{
			// allow to move in air
			is_available_side_move = true;
		}

	#if DEBUG
		if (debug_visualizer.get().enabled && debug_visualizer.get().check_move_ray)
		{
			if (is_available_side_move)
				Visualizer::renderVector(p1, p2, vec4_green);
			else
				Visualizer::renderVector(p1, p2, vec4_red);
		}
	#endif
	}

	// check stair surface angle for auto stepping
	if (use_auto_stepping && horizontal_move_direction.length2() > 0.0f)
	{
		Vec3 p2 = world_transform.getTranslate() + Vec3(horizontal_direction)
			* static_cast<Scalar>(shape->getRadius() + check_stair_ray_offset)
			+ Vec3_up * static_cast<Scalar>(min_step_height);
		Vec3 p1 = p2 + Vec3(vec3_up)
			* static_cast<Scalar>(max_step_height.get() - min_step_height.get() + check_stair_ray_offset.get());

		auto hitObj = World::getIntersection(p1, p2, stair_detection_mask, normal_intersection);
		if (hitObj)
		{
			if (dot(vec3_up, normal_intersection->getNormal()) > cos_stair_angle)
				is_available_stair = true;
		}

	#if DEBUG
		if (debug_visualizer.get().enabled && debug_visualizer.get().stair_detection_ray)
		{
			if (is_available_stair)
				Visualizer::renderVector(p1, p2, vec4_green);
			else
				Visualizer::renderVector(p1, p2, vec4_red);
		}
	#endif
	}
}

void FirstPersonController::update_velocity(float ifps, float update_part)
{
	// update current slope basis
	// check vectors for collinearity and, depending on this, calculate the slope basis
	Scalar cos_angle = dot(Vec3(world_transform.getAxisY()), slope_normal);
	if (compare(Math::abs(cos_angle), static_cast<Scalar>(1.0f)) == 0)
	{
		slope_axis_x = cross(Vec3(world_transform.getAxisY()), slope_normal).normalize();
		slope_axis_y = cross(slope_normal, slope_axis_x).normalize();
	}
	else
	{
		slope_axis_y = cross(Vec3(world_transform.getAxisX()) * sign(cos_angle), slope_normal).normalize();
		slope_axis_x = cross(slope_axis_y, slope_normal).normalize();
	}

	// get decomposition of velocity for instant change on ground
	Vec3 horizontal_velocity_decomposition = Vec3_zero;
	if (is_ground)
	{
		horizontal_velocity_decomposition.x = dot(slope_axis_x, horizontal_velocity);
		horizontal_velocity_decomposition.y = dot(slope_axis_y, horizontal_velocity);
		horizontal_velocity_decomposition.z = dot(slope_normal, horizontal_velocity);
	}

	// player rotation
	if (Input::isMouseGrab())
	{
		world_transform *= Mat4(rotate(quat(vec3_up, -Input::getMouseDeltaPosition().x * mouse_sensitivity * update_part)));

		float delta = -Input::getMouseDeltaPosition().x * mouse_sensitivity;
		if (game_pad)
		{
			vec2 rotate_value = (camera_stick == GamepadStickSide::LEFT ? game_pad->getAxesLeft() : game_pad->getAxesRight());
			if (rotate_value.length() > sticks_dead_zone && Math::abs(rotate_value.x * camera_stick_sensitivity) > Math::abs(delta))
				delta = -rotate_value.x * camera_stick_sensitivity;
		}

		camera_horizontal_angle += delta * update_part;
		if (camera_horizontal_angle < -180.0f || 180.0f < camera_horizontal_angle)
			camera_horizontal_angle -= sign(camera_horizontal_angle) * 360.0f;

		Vec3 position = world_transform.getTranslate();
		world_transform.setRotate(Vec3_up, camera_horizontal_angle);
		world_transform.setColumn3(3, position);
	}

	// on the ground change velocity without inertia
	if (is_ground)
	{
		// again check vectors for collinearity and, depending on this, update the slope basis
		cos_angle = dot(Vec3(world_transform.getAxisY()), slope_normal);
		if (compare(Math::abs(cos_angle), static_cast<Scalar>(1.0f)) == 0)
		{
			slope_axis_x = cross(Vec3(world_transform.getAxisY()), slope_normal).normalize();
			slope_axis_y = cross(slope_normal, slope_axis_x).normalize();
		}
		else
		{
			slope_axis_y = cross(Vec3(world_transform.getAxisX()) * sign(cos_angle), slope_normal).normalize();
			slope_axis_x = cross(slope_axis_y, slope_normal).normalize();
		}

		// restore velocity in new basis
		horizontal_velocity = slope_axis_x * horizontal_velocity_decomposition.x +
			slope_axis_y * horizontal_velocity_decomposition.y +
			slope_normal * horizontal_velocity_decomposition.z;
	}

	// add horizontal velocity in slope basis
	float acceleration = (is_ground ? ground_acceleration : air_acceleration);
	horizontal_velocity += slope_axis_x * horizontal_move_direction.x * acceleration * ifps;
	horizontal_velocity += slope_axis_y * horizontal_move_direction.y * acceleration * ifps;

	// update vertical velocity
	vertical_velocity += vertical_move_direction * ifps;
	if (!is_ground)
		vertical_velocity += Physics::getGravity().z * ifps;

	// get current max speed
	float max_speed = max_air_speed;
	if (is_ground)
	{
		max_speed = (use_run && use_run_default) ? run_speed : walk_speed;

		if (use_run && (Input::isKeyPressed(static_cast<Input::KEY>(run_key.get())) ||
			game_pad && game_pad->isButtonPressed(static_cast<Input::GAMEPAD_BUTTON>(run_button.get()))))
		{
			max_speed = use_run_default ? walk_speed : run_speed;
		}

		if (is_ground && is_crouch)
			max_speed = crouch_speed;

		max_air_speed = max_speed;
	}

	// apply damping to horizontal velocity when it exceeds target speed
	// or target speed too low (not pressed horizontal movement keys)
	vec2 targetSpeed = horizontal_move_direction * max_speed;
	if (targetSpeed.length() < Consts::EPS || targetSpeed.length() < horizontal_velocity.length())
		horizontal_velocity *= Math::exp((is_ground ? -ground_damping : -air_damping) * ifps);

	// clamp horizontal velocity if it greater than current max speed
	if (horizontal_velocity.length() > max_speed)
		horizontal_velocity = horizontal_velocity.normalize() * max_speed;

	// check frozen state for horizontal velocity
	// IsGround needed in case of slipping from the edges
	// contacts will be pushed player in all directions, and not just up
	is_horizontal_frozen = is_ground && (horizontal_velocity.length() < Physics::getFrozenLinearVelocity());
}

void FirstPersonController::update_collisions(float ifps)
{
	// set default collision parameters
	is_ground = false;
	is_ceiling = false;
	slope_normal = Vec3_up;

	is_heavy_contacts = false;

	// resolve current collisions
	for (int j = 0; j < collision_iterations; j++)
	{
		if (use_auto_stepping)
		{
		#if DEBUG
			auto_stepping_applied = false;
		#endif
			if (is_available_stair)
				try_move_up(ifps);
		}

		move_side(ifps);

		if (use_auto_stepping && used_auto_stepping && is_available_stair)
		{
		#if DEBUG
			auto_stepping_applied = true;
		#endif
			try_move_down(ifps);
		}

		if (is_heavy_contacts)
			break;
	}
}

void FirstPersonController::try_move_up(float ifps)
{
	used_auto_stepping = false;
	last_step_height = 0.0f;

	if (horizontal_move_direction.length2() > 0.0f && !is_horizontal_frozen && vertical_velocity < 0.0f)
	{
		body->setTransform(world_transform);
		if (is_crouch)
			shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f)));

		// find collisions with the capsule
		shape->getCollision(contacts);
		if (contacts.size() == 0)
			return;

		if (contacts.size() > heavy_contacts_count)
			is_heavy_contacts = true;

		int contacts_count = min(contacts_buffer_size, contacts.size());

		// find max step height
		Vec2 velocity_xy = Vec2(horizontal_velocity);
		if (velocity_xy.length2() < auto_stepping_speed_threshold)
		{
			// set minimal velocity for climb
			velocity_xy = Vec2(world_transform.getRotate() * Vec3(Vec2(horizontal_move_direction)));
			velocity_xy.normalize();
			horizontal_velocity = Vec3(velocity_xy * static_cast<Scalar>(walk_speed));
		}

		for (int i = 0; i < contacts_count; i++)
		{
			const ShapeContactPtr &c = contacts[i];

			Vec2 normalXY = Vec2(Vec3(c->getNormal()));

			// skip contacts opposite to movement
			if (dot(normalXY, velocity_xy) > cos_stairs_detection_angle)
				continue;

			Scalar step = dot(c->getPoint() - world_transform.getTranslate(), Vec3_up);
			if (last_step_height < step)
				last_step_height = step;
		}

		// apply auto stepping
		if (min_step_height < last_step_height && last_step_height < max_step_height)
		{
			world_transform.setColumn3(3, world_transform.getTranslate() + Vec3(vec3_up) * last_step_height);

			// check contacts with other objects after elevating
			// and cancel automatic step if contacts exist
			body->setTransform(world_transform);
			if (is_crouch)
				shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f)));

			shape->getCollision(contacts);
			if (contacts.size() == 0)
				used_auto_stepping = true;
			else
				world_transform.setColumn3(3, world_transform.getTranslate() + Vec3(vec3_down) * last_step_height);
		}

	#if DEBUG
		if (debug_visualizer.get().enabled && debug_visualizer.get().up_pass_contacts)
		{
			for (const auto &c : contacts)
				Visualizer::renderVector(c->getPoint(), c->getPoint() + Vec3(c->getNormal()), debug_colors.get().up_pass_contacts);
		}

		if (debug_profiler.get().enabled && debug_profiler.get().up_pass_contact)
			Profiler::setValue("Up Pass Contacts ", "", contacts.size(), max_pass_contacts, debug_colors.get().array_up_pass_contacts);
	#endif
	}
}

void FirstPersonController::move_side(float ifps)
{
	// apply new player transformation for physic body
	body->setTransform(world_transform);
	if (is_crouch)
		shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f)));

	// get contacts in new position and process them
	shape->getCollision(contacts);
	if (contacts.size() == 0)
		return;

	if (contacts.size() > heavy_contacts_count)
		is_heavy_contacts = true;

	int contacts_count = min(contacts_buffer_size, contacts.size());

	// total position offset for all contacts depth
	auto position_offset = vec3_zero;

	// maximum angle of inclination of the surface under the player
	float max_cos_angle = 1.0f;

	float inum = 1.0f / contacts_count;
	for (int i = 0; i < contacts_count; i++)
	{
		const ShapeContactPtr &c = contacts[i];

		// when horizontal velocity is frozen, we can move player only in vertical direction
		// this help to avoid sliding on slopes
		// in other cases, move player in all directions
		// use epsilon offset with depth for accuracy ground detection
		if (is_horizontal_frozen)
		{
			float depth = dot(vec3_up, c->getNormal()) * (c->getDepth() - Consts::EPS);
			position_offset += vec3_up * depth * inum;
		}
		else
		{
			position_offset += c->getNormal() * (c->getDepth() - Consts::EPS) * inum;

			// remove part of horizontal velocity that is projected onto normal of current contact
			Scalar normal_speed = dot(Vec3(c->getNormal()), horizontal_velocity);
			horizontal_velocity -= Vec3(c->getNormal()) * normal_speed;
		}

		// stop sliding near the wall at a certain angle
		if ((c->getObject() && !c->getObject()->getBodyRigid()) && shape->getBottomCap().z < c->getPoint().z && c->getPoint().z < shape->getTopCap().z)
		{
			float cos = dot(world_transform.getRotate() * vec3(horizontal_move_direction), -c->getNormal());
			if (cos > cos_wall_stop_sliding_angle)
				horizontal_velocity = Vec3_zero;
		}

		// check ground state
		// first part of expression checks that current contact belongs to bottom sphere of capsule
		// second part of expression checks that current angle of inclination of surface
		// not exceed maximum allowed angle
		if (dot(c->getPoint() - shape->getBottomCap(), Vec3_up) < 0.0f)
		{
			has_bottom_contacts = true;
			if (dot(c->getNormal(), vec3_up) > cos_ground_angle)
			{
				vertical_velocity = Physics::getGravity().z * ifps;
				is_ground = true;
			}

			// find to maximum angle of inclination of surface under player
			// and save normal of this surface
			float cos_angle = dot(vec3_up, c->getNormal());
			if (compare(cos_angle, 0.0f, 0.01f) == 0 && cos_angle < max_cos_angle)
			{
				slope_normal = Vec3(contacts[i]->getNormal());
				max_cos_angle = cos_angle;
			}
		}

		// check ceiling state
		// first part of expression checks that current angle of inclination of ceiling
		// not exceed maximum allowed angle
		// second part of expression checks that current contact belongs to top sphere of capsule
		if (dot(contacts[i]->getNormal(), vec3_down) > cos_ceiling_angle && dot(contacts[i]->getPoint() - shape->getTopCap(), Vec3_down) < 0.0f)
		{
			is_ceiling = true;

			// stop moving up
			vertical_velocity = 0.0f;
		}
	}

	// add total position offset to player transformation
	world_transform.setColumn3(3, world_transform.getTranslate() + Vec3(position_offset));

#if DEBUG
	if (debug_visualizer.get().enabled && debug_visualizer.get().side_pass_contacts)
	{
		for (const auto &c : contacts)
			Visualizer::renderVector(c->getPoint(), c->getPoint() + Vec3(c->getNormal()), debug_colors.get().side_pass_contacts);
	}

	if (debug_profiler.get().enabled && debug_profiler.get().side_pass_contact)
		Profiler::setValue("Side Pass Contacts ", "", contacts.size(), max_pass_contacts, debug_colors.get().array_side_pass_contacts);
#endif
}

void FirstPersonController::try_move_down(float ifps)
{
	// this correction allows to avoid jittering on large stairs
	if (last_step_height > shape->getRadius())
		last_step_height = shape->getRadius() - Physics::getPenetrationTolerance();

	// try to drop down the player
	world_transform.setColumn3(3, world_transform.getTranslate() - Vec3(vec3_up) * last_step_height);

	body->setTransform(world_transform);
	if (is_crouch)
		shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f)));

	// find collisions with the capsule
	shape->getCollision(contacts);
	if (contacts.size() == 0)
		return;

	if (contacts.size() > heavy_contacts_count)
		is_heavy_contacts = true;

	int contacts_count = min(contacts_buffer_size, contacts.size());

	float inum_contacts = 1.0f / itof(contacts_count);
	for (int i = 0; i < contacts_count; i++)
	{
		const ShapeContactPtr &c = contacts[i];

		float depth = dot(vec3_up, c->getNormal()) * c->getDepth();
		world_transform.setColumn3(3, world_transform.getTranslate()
			+ Vec3(vec3_up) * static_cast<Scalar>(depth) * static_cast<Scalar>(inum_contacts));

		if (dot(c->getNormal(), vec3_up) > cos_ground_angle && dot(c->getPoint() - shape->getBottomCap(), Vec3_up) < 0.0f)
		{
			is_ground = true;
			vertical_velocity = Physics::getGravity().z * ifps;
		}
	}

#if DEBUG
	if (debug_visualizer.get().enabled && debug_visualizer.get().down_pass_contacts)
	{
		for(const auto &c : contacts)
			Visualizer::renderVector(c->getPoint(), c->getPoint() + Vec3(c->getNormal()), debug_colors.get().down_pass_contacts);
	}

	if (debug_profiler.get().enabled && debug_profiler.get().down_pass_contact)
		Profiler::setValue("Down Pass Contacts ", "", contacts.size(), max_pass_contacts, debug_colors.get().array_down_pass_contacts);
#endif
}

void FirstPersonController::update_crouch(float ifps)
{
	if (!use_crouch)
		return;

	// get state of crouch key
	bool is_key = (Input::isKeyPressed(static_cast<Input::KEY>(crouch_key.get())) ||
				  game_pad && game_pad->isButtonPressed(static_cast<Input::GAMEPAD_BUTTON>(crouch_button.get())));

	// determine the subsequent behavior depending on the current phase
	switch (crouch_state.phase)
	{
		case CrouchPhase::STAND:
			if (is_key)
			{
				// go into a state of smooth movement down
				// set begin height to full player height
				// set end height to crouch player height
				// and activate crouch state
				crouch_state.phase = CrouchPhase::MOVE_DOWN;
				swap_interpolation_direction(capsule_height + 2.0f * shape->getRadius(), crouch_height);
				is_crouch = true;
			}
			break;

		case CrouchPhase::MOVE_DOWN:
		case CrouchPhase::CROUCH:
			if (!is_key)
			{
				// set players full height and check if we can get up
				bool can_stand_up = true;

				// set shape parameters for standing position
				// use width offset to avoid false wall contacts
				float radius = shape->getRadius();
				shape->setRadius(radius - skin_width_offset);
				update_player_height(capsule_height + 2.0f * skin_width_offset);

				// check current collisions
				shape->getCollision(contacts);

				Scalar top_point = world_transform.getTranslate().z + crouch_height;
				for (int i = 0; i < contacts.size(); i++)
					if (contacts[i]->getPoint().z > top_point)
					{
						// some collisions are higher than crouch height and we can't stand up
						can_stand_up = false;
						break;
					}

				// set current shape parameters
				shape->setRadius(radius);
				update_player_height(crouch_state.current_height - 2.0f * shape->getRadius());

				if (can_stand_up)
				{
					// go into a state of smooth movement up
					// set begin height to crouch player height
					// set end height to full player height
					crouch_state.phase = CrouchPhase::MOVE_UP;
					swap_interpolation_direction(crouch_height, capsule_height + 2.0f * shape->getRadius());
				}
			}
			break;

		case CrouchPhase::MOVE_UP:
			if (is_ceiling || is_key)
			{
				// if we touched an obstacle from above or the key is pressed again,
				// we go into a state of smooth movement down
				// set begin height to full player height
				// set end height to crouch player height
				crouch_state.phase = CrouchPhase::MOVE_DOWN;
				swap_interpolation_direction(capsule_height + 2.0f * shape->getRadius(), crouch_height);
			}
			break;

		default: break;
	}

	// handle smooth motion
	if (crouch_state.current_time > 0.0f)
	{
		// get current linear interpolation coefficient based on current phase time
		float t = 1.0f;
		if (compare(crouch_transition_time, Consts::EPS) == 0)
			t = saturate(1.0f - crouch_state.current_time / crouch_transition_time);

		// update current player height
		crouch_state.current_height = lerp(crouch_state.start_height, crouch_state.end_height, static_cast<Scalar>(t));
		update_player_height(crouch_state.current_height - 2.0f * shape->getRadius());

		crouch_state.current_time -= ifps;

		// handle final step of smooth motion
		if (crouch_state.current_time <= 0.0f)
		{
			// set final time and height
			crouch_state.current_time = 0.0f;
			crouch_state.current_height = crouch_state.end_height;

			switch (crouch_state.phase)
			{
				case CrouchPhase::MOVE_DOWN:
					// set crouch player height and go into crouch phase
					update_player_height(crouch_state.current_height - 2.0f * shape->getRadius());
					crouch_state.phase = CrouchPhase::CROUCH;
					break;

				case CrouchPhase::MOVE_UP:
					// set full player height and go into stand phase
					// also disable crouch state
					update_player_height(crouch_state.current_height - 2.0f * shape->getRadius());
					crouch_state.phase = CrouchPhase::STAND;
					is_crouch = false;
					break;

				default: break;
			}
		}
	}
}

void FirstPersonController::update_camera()
{
	if (!camera || camera_mode == CameraMode::NONE)
		return;

	if (Input::isMouseGrab())
	{
		// change vertical angle of camera
		camera_vertical_angle -= Input::getMouseDeltaPosition().y * mouse_sensitivity;

		float delta = -Input::getMouseDeltaPosition().y * mouse_sensitivity;
		if (game_pad)
		{
			vec2 rotate_value = (camera_stick == GamepadStickSide::LEFT ? game_pad->getAxesLeft() : game_pad->getAxesRight());
			if (rotate_value.length() > sticks_dead_zone && Math::abs(rotate_value.y * camera_stick_sensitivity) > Math::abs(delta))
				delta = rotate_value.y * camera_stick_sensitivity;
		}

		camera_vertical_angle += delta;
		camera_vertical_angle = clamp(camera_vertical_angle, min_vertical_angle + 90.0f, max_vertical_angle + 90.0f);
	}

	// update camera transformation taking into account all additional offsets of position and rotation
	camera->setWorldPosition(world_transform * (Vec3(camera_position_offset.get()) + Vec3(camera_crouch_offset) + Vec3(additional_camera_offset)));

	vec3 camera_direction = vec3_forward * rotateZ(-camera_horizontal_angle);
	camera_direction = camera_direction * rotate(cross(camera_direction, vec3_up), 90.0f - camera_vertical_angle);
	camera_direction = additional_camera_rotation * camera_direction;
	camera_direction.normalize();
	camera->setWorldDirection(camera_direction, vec3_up);
}

void FirstPersonController::swap_interpolation_direction(Scalar start_height, Scalar end_height)
{
	crouch_state.current_time = max(Consts::EPS, crouch_transition_time - crouch_state.current_time);
	crouch_state.start_height = start_height;
	crouch_state.end_height = end_height;
}

void FirstPersonController::update_player_height(Scalar height)
{
	shape->setHeight((float)height);
	camera_crouch_offset = vec3_up * (height - capsule_height);
	shape->setTransform(world_transform * translate(Vec3_up * (shape->getRadius() + height * 0.5f)));
}

#if DEBUG

void FirstPersonController::init_debug()
{
	if (!is_initialized)
		return;

	// debug camera
	if (debug_camera.get().enabled)
	{
		debug_camera.get().camera = PlayerDummy::create();
		debug_camera.get().angular_speed = 90.0f;
		debug_camera.get().zoom_speed = 3.0f;
		debug_camera.get().max_distance = 10.0f;
		debug_camera.get().horizontal_angle = 0.0f;
		debug_camera.get().vertical_angle = 0.0f;
		debug_camera.get().distance = debug_camera.get().max_distance * 0.5f;

		Game::setPlayer(debug_camera.get().camera);

		debug_camera.get().camera->setWorldDirection(vec3_forward, vec3_up);
		debug_camera.get().camera->setWorldPosition((world_transform.getTranslate() + Vec3(vec3_up)
			* static_cast<Scalar>(shape->getRadius() + shape->getHeight() * 0.5f)) - Vec3(vec3_forward)
			* static_cast<Scalar>(debug_camera.get().distance));
	}

	// use visualizer
	String command;

	Visualizer::setEnabled(debug_visualizer.get().enabled != 0);
	if (debug_visualizer.get().enabled)
	{
		Render::setShowTriangles(debug_visualizer.get().triangles ? 1 : 0);

		int showShapes = (debug_visualizer.get().shapes ? 1 : 0);
		command = "physics_show_shapes " + String::itoa(showShapes);
		Console::run(command);
	}

	// use profiler
	int show_profiler = (debug_profiler.get().enabled ? 1 : 0);
	command = "show_profiler " + String::itoa(show_profiler);
	Console::run(command);
	if (debug_profiler.get().enabled)
	{
		// applied horizontal speed
		max_applied_horizontal_speed = max(crouch_speed, walk_speed);
		max_applied_horizontal_speed = max(max_applied_horizontal_speed, run_speed);
		max_applied_horizontal_speed *= 1.1f;

		debug_colors.get().array_applied_horizontal_velocity[0] = debug_colors.get().applied_horizontal_velocity.get().x;
		debug_colors.get().array_applied_horizontal_velocity[1] = debug_colors.get().applied_horizontal_velocity.get().y;
		debug_colors.get().array_applied_horizontal_velocity[2] = debug_colors.get().applied_horizontal_velocity.get().z;
		debug_colors.get().array_applied_horizontal_velocity[3] = debug_colors.get().applied_horizontal_velocity.get().w;

		// applied vertical speed
		debug_colors.get().array_applied_vertical_velocity[0] = debug_colors.get().applied_vertical_velocity.get().x;
		debug_colors.get().array_applied_vertical_velocity[1] = debug_colors.get().applied_vertical_velocity.get().y;
		debug_colors.get().array_applied_vertical_velocity[2] = debug_colors.get().applied_vertical_velocity.get().z;
		debug_colors.get().array_applied_vertical_velocity[3] = debug_colors.get().applied_vertical_velocity.get().w;

		// up pass contacts
		debug_colors.get().array_up_pass_contacts[0] = debug_colors.get().up_pass_contacts.get().x;
		debug_colors.get().array_up_pass_contacts[1] = debug_colors.get().up_pass_contacts.get().y;
		debug_colors.get().array_up_pass_contacts[2] = debug_colors.get().up_pass_contacts.get().z;
		debug_colors.get().array_up_pass_contacts[3] = debug_colors.get().up_pass_contacts.get().w;

		// side pass contacts
		debug_colors.get().array_side_pass_contacts[0] = debug_colors.get().side_pass_contacts.get().x;
		debug_colors.get().array_side_pass_contacts[1] = debug_colors.get().side_pass_contacts.get().y;
		debug_colors.get().array_side_pass_contacts[2] = debug_colors.get().side_pass_contacts.get().z;
		debug_colors.get().array_side_pass_contacts[3] = debug_colors.get().side_pass_contacts.get().w;

		// down pass contacts
		debug_colors.get().array_down_pass_contacts[0] = debug_colors.get().down_pass_contacts.get().x;
		debug_colors.get().array_down_pass_contacts[1] = debug_colors.get().down_pass_contacts.get().y;
		debug_colors.get().array_down_pass_contacts[2] = debug_colors.get().down_pass_contacts.get().z;
		debug_colors.get().array_down_pass_contacts[3] = debug_colors.get().down_pass_contacts.get().w;

		// is ground
		debug_colors.get().array_is_ground[0] = debug_colors.get().is_ground.get().x;
		debug_colors.get().array_is_ground[1] = debug_colors.get().is_ground.get().y;
		debug_colors.get().array_is_ground[2] = debug_colors.get().is_ground.get().z;
		debug_colors.get().array_is_ground[3] = debug_colors.get().is_ground.get().w;

		// is ceiling
		debug_colors.get().array_is_ceiling[0] = debug_colors.get().is_ceiling.get().x;
		debug_colors.get().array_is_ceiling[1] = debug_colors.get().is_ceiling.get().y;
		debug_colors.get().array_is_ceiling[2] = debug_colors.get().is_ceiling.get().z;
		debug_colors.get().array_is_ceiling[3] = debug_colors.get().is_ceiling.get().w;

		// is crouch
		debug_colors.get().array_is_crouch[0] = debug_colors.get().is_crouch.get().x;
		debug_colors.get().array_is_crouch[1] = debug_colors.get().is_crouch.get().y;
		debug_colors.get().array_is_crouch[2] = debug_colors.get().is_crouch.get().z;
		debug_colors.get().array_is_crouch[3] = debug_colors.get().is_crouch.get().w;

		// average speed
		debug_colors.get().array_average_speed[0] = debug_colors.get().average_speed.get().x;
		debug_colors.get().array_average_speed[1] = debug_colors.get().average_speed.get().y;
		debug_colors.get().array_average_speed[2] = debug_colors.get().average_speed.get().z;
		debug_colors.get().array_average_speed[3] = debug_colors.get().average_speed.get().w;

		// profile auto stepping
		debug_colors.get().array_auto_stepping[0] = debug_colors.get().auto_stepping.get().x;
		debug_colors.get().array_auto_stepping[1] = debug_colors.get().auto_stepping.get().y;
		debug_colors.get().array_auto_stepping[2] = debug_colors.get().auto_stepping.get().z;
		debug_colors.get().array_auto_stepping[3] = debug_colors.get().auto_stepping.get().w;
	}

	last_player_position = world_transform.getTranslate();
}

void FirstPersonController::update_debug()
{
	if (!is_initialized)
		return;

	// debug camera
	if (debug_camera.get().enabled)
	{
		if (!debug_camera.get().use_fixed_angles)
		{
			if (Input::isKeyPressed(Input::KEY_UP))
				debug_camera.get().vertical_angle += debug_camera.get().angular_speed * Game::getIFps();
			if (Input::isKeyPressed(Input::KEY_DOWN))
				debug_camera.get().vertical_angle -= debug_camera.get().angular_speed * Game::getIFps();

			debug_camera.get().vertical_angle = clamp(debug_camera.get().vertical_angle, -89.9f, 89.9f);

			if (Input::isKeyPressed(Input::KEY_RIGHT))
				debug_camera.get().horizontal_angle -= debug_camera.get().angular_speed * Game::getIFps();
			if (Input::isKeyPressed(Input::KEY_LEFT))
				debug_camera.get().horizontal_angle += debug_camera.get().angular_speed * Game::getIFps();

			if (debug_camera.get().horizontal_angle < -180.0f || 180.0f < debug_camera.get().horizontal_angle)
				debug_camera.get().horizontal_angle -= sign(debug_camera.get().horizontal_angle) * 360.0f;
		}

		if (Input::isKeyPressed(Input::KEY_EQUALS))
			debug_camera.get().distance -= debug_camera.get().zoom_speed * Game::getIFps();
		if (Input::isKeyPressed(Input::KEY_MINUS))
			debug_camera.get().distance += debug_camera.get().zoom_speed * Game::getIFps();

		debug_camera.get().distance = clamp(debug_camera.get().distance, 0.0f, debug_camera.get().max_distance);

		vec3 camera_direction = debug_camera.get().camera->getDirection();
		if (debug_camera.get().use_fixed_angles && camera)
		{
			if (dot(camera->getDirection(), vec3_down) < 1.0f)
				camera_direction = camera->getWorldDirection();
		} else
		{
			camera_direction = vec3_forward * rotateZ(debug_camera.get().horizontal_angle);
			camera_direction = camera_direction * rotate(cross(camera_direction, vec3_up), debug_camera.get().vertical_angle);
		}

		debug_camera.get().camera->setWorldDirection(camera_direction, vec3_up);
	debug_camera.get().camera->setWorldPosition((world_transform.getTranslate() + Vec3(vec3_up)
		* static_cast<Scalar>(shape->getRadius() + shape->getHeight() * 0.5f)) - Vec3(camera_direction)
		* static_cast<Scalar>(debug_camera.get().distance));
	}

	// use visualizer
	if (debug_visualizer.get().enabled)
	{
		if (debug_visualizer.get().player_shape)
			shape->renderVisualizer(debug_colors.get().player_shape);

		if (debug_visualizer.get().player_direction)
		{
			Vec3 p0 = world_transform.getTranslate() + Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f);
			Vec3 p1 = p0 + Vec3(world_transform.getAxisY());
			Visualizer::renderVector(p0, p1, debug_colors.get().player_direction);
		}

		if (debug_visualizer.get().camera && camera)
		{
			Vec3 p0 = camera->getWorldPosition();
			Vec3 p1 = p0 + Vec3(camera->getWorldDirection());
			Visualizer::renderVector(p0, p1, debug_colors.get().camera_color);

			camera->renderVisualizer();
		}

		if (debug_visualizer.get().slope_basis)
		{
			Vec3 p0 = world_transform.getTranslate();
			Visualizer::renderVector(p0, p0 + slope_axis_x, vec4_red);
			Visualizer::renderVector(p0, p0 + slope_axis_y, vec4_green);
			Visualizer::renderVector(p0, p0 + slope_normal, vec4_blue);
		}

		if (debug_visualizer.get().applied_horizontal_velocity)
		{
			Vec3 p0 = world_transform.getTranslate() + Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f);
			Vec3 p1 = p0 + horizontal_velocity;
			Visualizer::renderVector(p0, p1, debug_colors.get().applied_horizontal_velocity);
		}

		if (debug_visualizer.get().applied_vertical_velocity)
		{
			Vec3 p0 = world_transform.getTranslate() + Vec3_up * (shape->getRadius() + shape->getHeight() * 0.5f);
			Vec3 p1 = p0 + Vec3(vec3_up) * static_cast<Scalar>(vertical_velocity);
			Visualizer::renderVector(p0, p1, debug_colors.get().applied_vertical_velocity);
		}
	}

	// use profiler
	if (debug_profiler.get().enabled)
	{
		if (debug_profiler.get().applied_horizontal_speed)
			Profiler::setValue("Applied Horizontal Speed", "m/s", (float)horizontal_velocity.length(), max_applied_horizontal_speed, debug_colors.get().array_applied_horizontal_velocity);

		if (debug_profiler.get().applied_vertical_speed)
			Profiler::setValue("|Applied Vertical Speed|", "m/s", Math::abs(vertical_velocity), max_applied_vertical_speed, debug_colors.get().array_applied_vertical_velocity);

		if (debug_profiler.get().is_ground)
			Profiler::setValue("Is Ground", "", (is_ground ? 1.0f : 0.0f), max_flag_value, debug_colors.get().array_is_ground);

		if (debug_profiler.get().is_ceiling)
			Profiler::setValue("Is Ceiling", "", (is_ceiling ? 1.0f : 0.0f), max_flag_value, debug_colors.get().array_is_ceiling);

		if (debug_profiler.get().is_crouch)
			Profiler::setValue("Is Crouch", "", (is_crouch ? 1.0f : 0.0f), max_flag_value, debug_colors.get().array_is_crouch);

		if (debug_profiler.get().average_speed)
		{
			for (int i = 0; i < speeds_buffer_size - 1; i++)
				speeds_buffer[i] = speeds_buffer[i + 1];

			speeds_buffer[speeds_buffer_size - 1] = (float)(world_transform.getTranslate() - last_player_position).length() / Game::getIFps();
			last_player_position = world_transform.getTranslate();

			float avg_speed = 0.0f;
			for (int i = 0; i < speeds_buffer_size; i++)
				avg_speed += speeds_buffer[i];

			avg_speed /= (float)speeds_buffer_size;

			Profiler::setValue("Avg Speed", "m/s", avg_speed, max_applied_horizontal_speed * 1.75f, debug_colors.get().array_average_speed);
		}

		if (debug_profiler.get().auto_stepping)
			Profiler::setValue("Auto Stepping", "", (auto_stepping_applied ? 1.0f : 0.0f), max_flag_value, debug_colors.get().array_auto_stepping);
	}
}

#endif
```

## FirstPersonControllerSample.cpp

```cpp
#include "FirstPersonControllerSample.h"

REGISTER_COMPONENT(FirstPersonControllerSample);

using namespace Unigine;

void FirstPersonControllerSample::init()
{
	mouse_grab_state_at_init = Input::isMouseGrab();
	mouse_handle_at_init = Input::getMouseHandle();
	Input::setMouseGrab(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
}

void FirstPersonControllerSample::shutdown()
{
	Input::setMouseGrab(mouse_grab_state_at_init);
	Input::setMouseHandle(mouse_handle_at_init);
}

```

## Flame.cpp

```cpp
#include "Flame.h"
#include "ExtinguishingPuddles.h"
#include "UnigineGame.h"
#include "UnigineVisualizer.h"

REGISTER_COMPONENT(Flame);

using namespace Unigine;
using namespace Math;


void Flame::setBurn(bool burn_)
{
	this->burn = burn_;
	if (emitter)
	{
		emitter->setEmitterEnabled(burn_);
	}
}

void Flame::init()
{
	if (emitter_node)
	{
		emitter = checked_ptr_cast<ObjectParticles>(emitter_node.get());
		if (!emitter)
		{
			Log::error("%s: Flame component can only accept ObjectParticles as the emitter_node\n", __FUNCTION__);
			node->setEnabled(false);
		}
	}
	else
	{
		Log::error("%s: Flame component can not found ObjectParticles\n", __FUNCTION__);
		node->setEnabled(false);
	}
}

void Flame::update()
{
	Vector<NodePtr> nodes;
	BoundBox box(vec3(-10.0f), vec3(10.0f));
	
	box.setTransform(node->getWorldTransform());
	World::getIntersection(box, Unigine::Node::DECAL_ORTHO, nodes);

	if ((nodes.size() > 10) == getBurn())
		setBurn(!getBurn());
}

```

## Flock.cpp

```cpp
#include "Flock.h"

#include "FlockController.h"

#include <UnigineProfiler.h>


Flock::Flock()
{
	updater = std::make_unique<FlockUpdater>(this);
}

Flock::Flock(Flock &&other)
{
	units = std::move(other.units);
	cohesion_coefficient = other.cohesion_coefficient;
	alignment_coefficient = other.alignment_coefficient;
	separation_coefficient = other.separation_coefficient;
	flock_target_node = std::move(other.flock_target_node);
	use_bound = other.use_bound;
	updater = std::move(other.updater);
}

void Flock::addUnit(Unit unit)
{
	units.push_back(std::move(unit));
}

void Flock::update()
{
	updater->run();
}

Flock::FlockUpdater::FlockUpdater(Flock *flock)
	: flock(flock)
{}

Flock::FlockUpdater::~FlockUpdater() = default;

void Flock::FlockUpdater::process(int thread_num, int num_threads)
{
	if (!flock)
		return;

	while (true)
	{
		const int index = counter.fetch_add(1);
		if (index >= flock->getUnits().size())
			break;
		auto &unit = flock->getUnits().get(index);
		unit.update(flock);
	}
}

void Flock::FlockUpdater::run()
{
	counter = 0;
	runSync();
}

```

## FlockController.cpp

```cpp
#include "FlockController.h"

#include <UnigineGame.h>

namespace
{
Unit generate_unit(const Unigine::String &node_path, const Unigine::Math::BoundBox &spawn_zone)
{
	const Unigine::NodePtr node = Unigine::World::loadNode(node_path);
	const Unigine::Math::Random random;
	random.setSeed(Unigine::Game::getRandom());
	Unigine::Math::Vec3 spawn_point;
	spawn_point.x = random.getFloat(spawn_zone.minimum.x, spawn_zone.maximum.x);
	spawn_point.y = random.getFloat(spawn_zone.minimum.y, spawn_zone.maximum.y);
	spawn_point.z = random.getFloat(spawn_zone.minimum.z, spawn_zone.maximum.z);
	node->setWorldPosition(spawn_point);
	auto unit = Unit(node);
	return unit;
}

std::unique_ptr<Flock> generate_flock(const Unigine::String &node_path, const int flock_size,
	const Unigine::Math::BoundBox &spawn_zone)
{
	auto flock = std::make_unique<Flock>();
	for (int i = 0; i < flock_size; ++i)
	{
		auto unit = generate_unit(node_path, spawn_zone);
		flock->addUnit(std::move(unit));
	}
	return flock;
}
} // namespace

void FlockController::init()
{
	auto spawn_zone = Unigine::Math::BoundBox(-spawn_zone_size.get(), spawn_zone_size.get());
	spawn_zone.setTransform(node->getWorldTransform());
	flock = generate_flock(unit_node.get(), flock_size, spawn_zone);
	UNIGINE_ASSERT(targets.size() > 0);
	flock_current_target = get_new_target();
	flock->setTarget(flock_current_target);
	flock->setCohesionCoefficient(cohesion_coefficient);
	flock->setAlignmentCoefficient(alignment_coefficient);
	flock->setSeparationCoefficient(separation_coefficient);
	flock->setTargetChaseValue(target_coefficient);
	for (auto &unit : flock->getUnits())
	{
		unit.setSpotRadius(cohesion_spot_radius);
		unit.setDesiredSeparationRange(separation_desired_range);
		const auto speed_offset = Unigine::Game::getRandomFloat(-2.f, 2.f);
		unit.setMaxSpeed(max_speed + speed_offset);
		unit.setMaxForce(max_force);
		unit.setRotationSpeed(rotation_speed);
		unit.setLimitByHeightEnabled(true);
		unit.setMinHeight(min_height);
		unit.setMaxHeight(max_height);
		unit.setHeightPadding(escape_force_height_padding);
	}
}

void FlockController::update()
{
	flock->update();

	if (distance2(get_flock_center(), flock_current_target->getWorldPosition()) < 30.f)
	{
		flock_current_target = get_new_target();
		flock->setTarget(flock_current_target);
	}
}

Unigine::Math::Vec3 FlockController::get_flock_center()
{
	Unigine::Math::Vec3 sum{};
	for (auto &unit : flock->getUnits())
	{
		sum += unit.getNode()->getWorldPosition();
	}

	return sum / static_cast<Unigine::Math::Scalar>(flock->getUnits().size());
}

Unigine::NodePtr FlockController::get_new_target()
{
	Unigine::NodePtr new_target = targets[Unigine::Game::getRandomInt(0, targets.size() - 1)];

	if (flock_current_target && targets.size() > 1)
		while (new_target->getID() == flock_current_target->getID())
			new_target = targets[Unigine::Game::getRandomInt(0, targets.size() - 1)];

	return new_target;
}

REGISTER_COMPONENT(FlockController)

```

## FlockSample.cpp

```cpp
#include "FlockSample.h"

#include <UnigineVisualizer.h>

#include "FlockController.h"

REGISTER_COMPONENT(FlockSample);

void FlockSample::init()
{
	fish_controller = Unigine::ComponentSystem::get()->getComponent<FlockController>(
		fish_controller_parameter);
	if (!fish_controller)
	{
		Unigine::Log::error("FlockSample::init(): No FlockController on fish node was found\n");
		return;
	}
	bird_controller = Unigine::ComponentSystem::get()->getComponent<FlockController>(
		bird_controller_parameter);
	if (!bird_controller)
	{
		Unigine::Log::message("FlockSample::init(): No FlockController on bird node was found\n");
		return;
	}

	is_visualizer_enabled_at_sample_start = Unigine::Visualizer::isEnabled();
	Unigine::Visualizer::setEnabled(true);

	sample_description_window.createWindow();
	init_ui();
}

void FlockSample::init_ui()
{
	const auto create_flock_ui = [this](const Unigine::String &controller_name,
									 FlockController *controller) {
		sample_description_window.addLabel(controller_name);
		sample_description_window.addFloatParameter("Cohesion", "Cohesion coefficient",
			controller->cohesion_coefficient, 0.f, 10.f,
			[this, controller](float v) { controller->getFlock()->setCohesionCoefficient(v); });
		sample_description_window.addFloatParameter("Spot Radius", "Spot radius", controller->cohesion_spot_radius,
			0.f, 1000.f, [this, controller](float v) {
				for (auto &unit : controller->getFlock()->getUnits())
					unit.setSpotRadius(v);
			});
		sample_description_window.addFloatParameter("Alignment", "Alignment Coefficient",
			controller->alignment_coefficient, 0.f, 10.f,
			[this, controller](float v) { controller->getFlock()->setAlignmentCoefficient(v); });
		sample_description_window.addFloatParameter("Separation", "Separation coefficient",
			controller->separation_coefficient, 0.f, 10.f,
			[this, controller](float v) { controller->getFlock()->setSeparationCoefficient(v); });
		sample_description_window.addFloatParameter("Separation Desired Range", "separation desired range",
			controller->separation_desired_range, 1.f, 10.f, [this, controller](float v) {
				for (auto &unit : controller->getFlock()->getUnits())
					unit.setDesiredSeparationRange(v);
			});

		sample_description_window.addFloatParameter("Target", "Target chase coefficient",
			controller->target_coefficient, 0.f, 10.f,
			[this, controller](float v) { controller->getFlock()->setTargetChaseValue(v); });

		sample_description_window.addFloatParameter("Unit Max Speed", "Unit speed", controller->max_speed, 0.f, 100.f,
			[this, controller](float v) {
				for (auto &unit : controller->getFlock()->getUnits())
				{
					Unigine::Math::Random rand;
					auto offset = rand.getFloat(-5.f, 5.f);
					unit.setMaxSpeed(v + offset);
				}
			});
		sample_description_window.addFloatParameter("Unit Max Force", "unit max force", controller->max_force, 0.f,
			10.f, [this, controller](float v) {
				for (auto &unit : controller->getFlock()->getUnits())
				{
					Unigine::Math::Random rand;
					const auto offset = rand.getFloat(-5.f, 5.f);
					unit.setMaxForce(v + offset);
				}
			});

		sample_description_window.addFloatParameter("Unit Max Turn Speed", "unit max turn speed", controller->rotation_speed, 0.1f, 300.f, [this, controller](float v) {
			for (auto &unit : controller->getFlock()->getUnits())
			{
				unit.setRotationSpeed(v);
			}
		});
		sample_description_window.addParameterSpacer();
	};

	create_flock_ui("Birds controller", bird_controller);
	create_flock_ui("Fish controller", fish_controller);
	sample_description_window.addBoolParameter("Enable Debug", "Enable debugging", is_debug_enabled, [this](bool v) {
		is_debug_enabled = v;
	});
}

void FlockSample::update()
{
	if (is_debug_enabled)
		visualize_flock();
}

void FlockSample::shutdown()
{
	sample_description_window.shutdown();
	Unigine::Visualizer::setEnabled(is_visualizer_enabled_at_sample_start);
}

void FlockSample::visualize_flock()
{
	using namespace Unigine::Math;
	const auto visualize_flock = [this](FlockController* flock, const vec4 &color) {
		if (flock->getFlock()->getUnits().empty())
			return;

		BoundBox bb;
		bb.setTransform(flock->getFlock()->getUnits().first().getNode()->getWorldTransform());

		for (auto& unit : flock->getFlock()->getUnits())
			bb.expand(unit.getNode()->getWorldBoundBox());

		Unigine::Visualizer::renderBoundBox(bb, Mat4_identity, color, 0, false);
	};
	visualize_flock(bird_controller, vec4_red);
	visualize_flock(fish_controller, vec4_green);
}

```

## GBufferRead.cpp

```cpp
#include "GBufferRead.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(GBufferRead)

using namespace Unigine;
using namespace Math;

constexpr int TEXTURE_WIDTH = 1024;
constexpr int TEXTURE_HEIGHT = 1024;


void GBufferRead::init()
{
	viewport = Viewport::create();

	// as we are not interested in the final image, we can stop
	// rendering when G-buffer textures are ready
	viewport->setRenderMode(Viewport::RENDER_DEPTH_GBUFFER);
	viewport->getEventEndOpacityGBuffer().connect(on_viewport_g_buffer_ready_connection, this,
		&GBufferRead::g_buffers_ready_callback);

	Render::getEventEndOpacityGBuffer().connect(on_render_g_buffer_ready_connection, this,
		&GBufferRead::g_buffers_ready_callback);

	// create all textures
	// use Texture::FORMAT_USAGE_RENDER so texture can be used in rendering operations
	albedo_texture = Texture::create();
	albedo_texture->create2D(TEXTURE_WIDTH, TEXTURE_HEIGHT, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	normal_texture = Texture::create();
	normal_texture->create2D(TEXTURE_WIDTH, TEXTURE_HEIGHT, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	metalness_texture = Texture::create();
	metalness_texture->create2D(TEXTURE_WIDTH, TEXTURE_HEIGHT, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	roughness_texture = Texture::create();
	roughness_texture->create2D(TEXTURE_WIDTH, TEXTURE_HEIGHT, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	depth_texture = Texture::create();
	depth_texture->create2D(TEXTURE_WIDTH, TEXTURE_HEIGHT, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	setMode(mode);
}

void GBufferRead::g_buffers_ready_callback()
{
	RenderTargetPtr render_target = Renderer::getPostRenderTarget();

	// save current state and put it to the top of RenderStates saved states stack
	RenderState::saveState();
	// clear current render state, so our render won't be affected by current render settings
	RenderState::clearStates();

	// set textures in which we will render
	render_target->bindColorTexture(0, depth_texture);
	render_target->bindColorTexture(1, albedo_texture);
	render_target->bindColorTexture(2, normal_texture);
	render_target->bindColorTexture(3, metalness_texture);
	render_target->bindColorTexture(4, roughness_texture);

	// enable render target
	render_target->enable();
	{
		// Bind already rendered GBuffer textures to shader
		// we use RenderState::BIND_FRAGMENT to bind textures only for fragment shader
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 0, Renderer::getTextureOpacityDepth());
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 1, Renderer::getTextureGBufferAlbedo());
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 2, Renderer::getTextureGBufferNormal());
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 3,
			Renderer::getTextureGBufferShading());

		// this material contains shader, which will render textures, bound to RenderTarget
		// to see code of this shader, go to sample folder and then to materials folder
		// and open fetch_buffers_post.basemat
		fetch_buffers_post_material->renderScreen(Render::PASS_POST);
	}
	render_target->disable();
	render_target->unbindColorTextures();

	// get RenderState from top of inner RenderState stack
	RenderState::restoreState();

	depth_texture->createMipmaps();
	normal_texture->createMipmaps();
	roughness_texture->createMipmaps();
	metalness_texture->createMipmaps();
	albedo_texture->createMipmaps();
}

void GBufferRead::renderNode(const Mat4 &model_view, const Mat4 &projection,
	const NodePtr &to_render) const
{
	// here we will render node with our viewport
	CameraPtr camera = Camera::create();
	camera->setProjection(mat4(projection));
	camera->setModelview(model_view);

	RenderState::saveState();
	RenderState::clearStates();
	RenderState::setViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);
	{
		// here g_buffers_ready_callback will be called, after all g_buffers textures will be ready
		// look at init() function to see how we subscribe on this event
		viewport->renderNode(camera, to_render);
	}
	RenderState::restoreState();
}

void GBufferRead::setMode(GBufferRead::Mode in_mode)
{
	mode = in_mode;
	switch (mode)
	{
	case Mode::RenderNode:
		on_render_g_buffer_ready_connection.setEnabled(false);
		on_viewport_g_buffer_ready_connection.setEnabled(true);
		break;
	case Mode::RenderMainViewport:
		on_render_g_buffer_ready_connection.setEnabled(true);
		on_viewport_g_buffer_ready_connection.setEnabled(false);
		break;
	}
}

```

## GBufferReadSample.cpp

```cpp
#include "GBufferReadSample.h"

#include "GBufferRead.h"

#include <UnigineGame.h>
#include <UnigineMathLibVec4.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(GBufferReadSample)

void GBufferReadSample::init()
{
	g_buffer_read_component = ComponentSystem::get()->getComponentInWorld<GBufferRead>();
	if (!g_buffer_read_component)
	{
		Log::error("GBufferReadSample::init: No gbuffer read component");
		return;
	}

	init_display(roughness_node_param, g_buffer_read_component->getRoughnessTexture());
	init_display(metallness_node_param, g_buffer_read_component->getMetalnessTexture());
	init_display(normal_node_param, g_buffer_read_component->getNormalTexture());
	init_display(albedo_node_param, g_buffer_read_component->getAlbedoTexture());
	init_display(depth_node_param, g_buffer_read_component->getDepthTexture());

	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);

	sample_description_window.createWindow();
	{
		WidgetGroupBoxPtr parameters = sample_description_window.getParameterGroupBox();

		auto label = WidgetLabel::create("Render <b>G-buffer</b> from:");
		label->setFontRich(1);
		parameters->addChild(label, Gui::ALIGN_EXPAND);

		auto buttons_hbox = WidgetHBox::create();
		parameters->addChild(buttons_hbox, Gui::ALIGN_EXPAND);

		auto main_camera_button = WidgetButton::create("Main Camera");
		main_camera_button->setToggleable(true);
		auto custom_camera_button = WidgetButton::create("Custom Camera");
		custom_camera_button->setToggleable(true);

		buttons_hbox->addChild(main_camera_button, Gui::ALIGN_EXPAND);
		buttons_hbox->addChild(custom_camera_button, Gui::ALIGN_EXPAND);

		main_camera_button->getEventClicked().connect(*this, [this, main_camera_button, custom_camera_button]()
			{
				main_camera_button->getEventClicked().setEnabled(false);
				main_camera_button->setToggled(true);
				main_camera_button->getEventClicked().setEnabled(true);

				custom_camera_button->getEventClicked().setEnabled(false);
				custom_camera_button->setToggled(false);
				custom_camera_button->getEventClicked().setEnabled(true);

				if (g_buffer_read_component->getMode() != GBufferRead::Mode::RenderMainViewport)
				{
					g_buffer_read_component->setMode(GBufferRead::Mode::RenderMainViewport);
				}
			});

		custom_camera_button->getEventClicked().connect(*this, [this, main_camera_button, custom_camera_button]()
			{
				main_camera_button->getEventClicked().setEnabled(false);
				main_camera_button->setToggled(false);
				main_camera_button->getEventClicked().setEnabled(true);

				custom_camera_button->getEventClicked().setEnabled(false);
				custom_camera_button->setToggled(true);
				custom_camera_button->getEventClicked().setEnabled(true);

				if (g_buffer_read_component->getMode() != GBufferRead::Mode::RenderNode)
				{
					g_buffer_read_component->setMode(GBufferRead::Mode::RenderNode);
				}
			});

		custom_camera_button->runEventClicked(0);
	}
}

void GBufferReadSample::update()
{
	float ifps = Game::getIFps();

	WorldBoundSphere bound_sphere = node_to_render->getWorldBoundSphere();

	Vec3 camera_target = bound_sphere.center;
	float camera_distance = (float)bound_sphere.radius;
	float camera_radius = (float)bound_sphere.radius * 1.5f;

	phi += 90.0f * ifps;
	Mat4 camera_transform = translate(camera_target)
		* Mat4(rotateZ(phi) * rotateX(90.0f - THETA) * translate(0.0f, 0.0f, -camera_distance));
	if (!Render::isFlipped())
	{
		camera_transform *= Mat4(rotateZ(180.0f));
	}
	Mat4 model_view = inverse(camera_transform);
	mat4 projection = ortho(-camera_radius, camera_radius, -camera_radius, camera_radius,
		-camera_radius * 1.8f, camera_radius * 1.8f);

	if (g_buffer_read_component->getMode() == GBufferRead::Mode::RenderNode)
	{
		g_buffer_read_component->renderNode(model_view, Mat4(projection), node_to_render);

		// render frustum
		Visualizer::renderFrustum(projection, camera_transform, vec4_red, 0, false);
		Visualizer::renderVector(camera_transform.getTranslate()
				+ camera_transform.getAxisZ() * camera_radius * 2,
			camera_transform.getTranslate() - camera_transform.getAxisZ() * camera_radius / 2.f,
			vec4_red, 0.25, false, 0.f, false);
	}
}

void GBufferReadSample::shutdown()
{
	Visualizer::setEnabled(visualizer_enabled);

	sample_description_window.shutdown();
}

void GBufferReadSample::init_display(const Unigine::NodePtr &display_node,
	const Unigine::TexturePtr &texture)
{
	ObjectPtr obj = checked_ptr_cast<Object>(display_node);
	MaterialPtr display_material = obj->getMaterialInherit(0);
	display_material->setState("emission", 1);
	display_material->setParameterFloat4("albedo_color", vec4(0.f, 0.f, 0.f, 1.f));
	display_material->setTexture(display_material->findTexture("emission"), texture);
}

```

## GBufferWrite.cpp

```cpp
#include "GBufferWrite.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(GBufferWrite)


// this callback will called after g-buffer textures is ready
void GBufferWrite::g_buffers_ready_callback()
{
	// get shader from material to set parameters and bind it in exact time we want
	// we use getShaderForce to get it instantly, and if shader is not compiled, engine will compile
	// it and we can use it instantly
	ShaderPtr shader = modify_buffer_material->getShaderForce(Render::PASS_POST);
	if (!shader)
	{
		return;
	}

	RenderTargetPtr render_target = Renderer::getPostRenderTarget();

	// because this callback is called after g-buffer textures are ready,
	// we can freely get them
	TexturePtr albedo = Renderer::getTextureGBufferAlbedo();
	TexturePtr normal = Renderer::getTextureGBufferNormal();
	TexturePtr shading = Renderer::getTextureGBufferShading();

	// engine will allocate new texture, or just use one from its internal pool,
	// so its better to use this method than create new textures
	// but we need to release this textures explicitly ourselves
	TexturePtr albedo_temp = Render::getTemporaryTexture(albedo);
	TexturePtr normal_temp = Render::getTemporaryTexture(normal);
	TexturePtr shading_temp = Render::getTemporaryTexture(shading);


	RenderState::saveState();
	RenderState::clearStates();

	// set textures with flag BIND_FRAGMENT, so this textures can be usable only from fragment
	// shader these textures correspond to this shader code in our material STRUCT_FRAG_BEGIN
	// 	INIT_MRT(float4, OUT_ALBEDO)
	// 	INIT_MRT(float4, OUT_NORMAL)
	// 	INIT_MRT(float4, OUT_SHADING)
	// STRUCT_FRAG_END
	// MRT stands for Multiple Render Target, and we use it to render multiple textures in single
	// draw call
	render_target->bindColorTexture(0, albedo_temp);
	render_target->bindColorTexture(1, normal_temp);
	render_target->bindColorTexture(2, shading_temp);
	render_target->enable();
	{
		// bind shader and set its parameters (look into modify_buffers_post.basemat
		// to find out how you can use this parameters in shader
		shader->bind();
		// these parameters correspond with these lines in shader
		// CBUFFER(parameters)
		//	UNIFORM float ss_influence;
		//	UNIFORM float ss_plastic;
		//	UNIFORM float4 ss_color;
		// END
		shader->setParameterFloat("ss_influence", influence);
		shader->setParameterFloat("ss_plastic", plastic);
		shader->setParameterFloat4("ss_color", color);
		shader->flushParameters();

		// here we bind textures to shader so we can read from it
		// this lines correspond to these shader lines
		// INIT_TEXTURE(0, TEX_ALBEDO)
		// INIT_TEXTURE(1, TEX_NORMAL)
		// INIT_TEXTURE(2, TEX_SHADING)
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 0, albedo);
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 1, normal);
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 2, shading);

		// now we can start our render
		modify_buffer_material->renderScreen(Render::PASS_POST);
	}
	render_target->disable();
	render_target->unbindColorTextures();
	RenderState::restoreState();

	// here we set new g-buffer textures
	albedo_temp->swap(albedo);
	normal_temp->swap(normal);
	shading_temp->swap(shading);

	// release temporary textures
	Render::releaseTemporaryTexture(albedo_temp);
	Render::releaseTemporaryTexture(normal_temp);
	Render::releaseTemporaryTexture(shading_temp);
}

void GBufferWrite::init()
{
	Render::getEventEndOpacityGBuffer().connect(this, &GBufferWrite::g_buffers_ready_callback);

	sample_description_window.createWindow();

	color_label = sample_description_window.addLabel("Color: ");
	plastic_label = sample_description_window.addLabel("Plastic: ");
	influence_label = sample_description_window.addLabel("Influence: ");
}

void GBufferWrite::update()
{
	const VectorStack<vec4> colors = {vec4(1.0f, 1.0f, 0.0f, 1.0f), vec4(0.0f, 1.0f, 0.0f, 1.0f),
		vec4(0.0f, 1.0f, 1.0f, 1.0f), vec4(0.0f, 0.0f, 1.0f, 1.0f), vec4(1.0f, 0.0f, 1.0f, 1.0f)};

	const float time = Game::getTime();
	const float ifps = Game::getIFps();

	influence = saturate(Math::sin(time / 2.0f) + 1.0f);
	plastic = (Math::cos(time / 5.0f) + 1.0f) / 2.0f;

	int color_index = static_cast<int>(time / 4.0f) % colors.size();

	color = lerp(color, colors[color_index], 0.2f * ifps);

	color_label->setText(
		String::format("Color: %0.2f %0.2f %0.2f %0.2f", color.x, color.y, color.z, color.w));
	influence_label->setText(String::format("Influence: %0.2f", influence));
	plastic_label->setText(String::format("Plastic: %0.2f", plastic));
}

void GBufferWrite::shutdown()
{
	sample_description_window.shutdown();
}

```

## GamepadInput.cpp

```cpp
#include "GamepadInput.h"
#include "Car.h"
#include "../../utils/SimpleInformationBox.h"
#include <UnigineGame.h>

REGISTER_COMPONENT(GamepadInput);

using namespace Unigine;
using namespace Math;

void GamepadInput::setFilter(float f)
{
	if (gamepad)
	{
		gamepad->setFilter(f);
	}
}

void GamepadInput::setLowFrequency(float f)
{
	low_frequency = clamp(f, 0.0f, 1.0f);
}

void GamepadInput::setHighFrequency(float f)
{
	high_frequency = clamp(f, 0.0f, 1.0f);
}

void GamepadInput::setDuration(float d)
{
	vibration_duration = d;
	if (vibration_duration < 0.0f)
		vibration_duration = 0.0f;
}


void GamepadInput::init()
{
	Physics::setFrozenLinearVelocity(0.1f);
	Physics::setFrozenAngularVelocity(0.1f);

	info = getComponent<SimpleInformationBox>(node);

	info->setWindowTitle("Gamepad Input Sample");
	info->setColumnsCount(1);
	info->setWidth(300);
	info->pushBackAboutInfo("This sample demostrates the simple usage of Gamepad input.");

	auto group = info->getParametersGroupBox(0);
	canvas = WidgetCanvas::create();
	group->addChild(canvas);
	canvas->setWidth(group->getWidth());
	canvas->setHeight(toInt(group->getWidth() * 0.5));
	canvas->setHidden(true);

	auto slider = info->addSlider(0, "Filter ", 0.01f, "Buttons sensitivity threshold");
	slider->getEventChanged().connect(widget_connections, [this, slider]() {
		setFilter(slider->getValue() * 0.01f);
		});
	slider = info->addSlider(0, "Low Frequency ", 0.01f, "Power of vibration for low frequency");
	slider->getEventChanged().connect(widget_connections, [this, slider]() {
		setLowFrequency(slider->getValue() * 0.01f);
		});
	slider = info->addSlider(0, "High Frequency ", 0.01f, "Power of vibration for high frequency");
	slider->getEventChanged().connect(widget_connections, [this, slider]() {
		setHighFrequency(slider->getValue() * 0.01f);
		});
	slider = info->addSlider(0, "Duration ", 1.0f, "Vibration duration in ms");
	slider->getEventChanged().connect(widget_connections, [this, slider]() {
		setDuration((float)slider->getValue());
		});
	slider->setMinValue(1);
	slider->setMaxValue(1000);
	slider->setValue(1);

	car = getComponent<Car>(World::getNodeByName("car"));

	if (Input::getNumGamePads() > 0)
	{
		gamepad = Input::getGamePad(0);
	}
	else
	{
		Log::error("GamepadInput::init(): No available gamepads!\n");
		return;
	}

}

void GamepadInput::update()
{
	update_inputs();

	info->clearParametersInfo(0);

	if (gamepad && gamepad->isAvailable())
	{
		draw_touches();

		info->pushBackParametersInfo(0, gamepad->getName(), SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Press Left and Right triggers to run motors", SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Press <b>X button</b> to respawn", SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Press <b>Y button</b> to vibrate", SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Number", String::itoa(gamepad->getNumber()));
		info->pushBackParametersInfo(0, "Player Index", String::itoa(gamepad->getPlayerIndex()));
		info->pushBackParametersInfo(0, "Device Type", getDeviceName(gamepad->getDeviceType()));
		info->pushBackParametersInfo(0, "Model Type", getModelName(gamepad->getModelType()));
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Axes", SimpleInformationBox::INFO_ALIGN::CENTER);

		info->pushBackParametersInfo(0, "Left X", String::ftoa(gamepad->getAxesLeft().x));

		info->pushBackParametersInfo(0, "Left Y", String::ftoa(gamepad->getAxesLeft().y));

		info->pushBackParametersInfo(0, "Right X", String::ftoa(gamepad->getAxesRight().x));

		info->pushBackParametersInfo(0, "Right Y", String::ftoa(gamepad->getAxesRight().y));

		info->pushBackParametersInfo(0, "Left X Last Delta", String::ftoa(last_axes_left_delta.x));

		info->pushBackParametersInfo(0, "Left Y Last Delta", String::ftoa(last_axes_left_delta.y));

		info->pushBackParametersInfo(0, "Right X Last Delta", String::ftoa(last_axes_right_delta.x));

		info->pushBackParametersInfo(0, "Right Y Last Delta", String::ftoa(last_axes_right_delta.y));

		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Triggers", SimpleInformationBox::INFO_ALIGN::CENTER);

		info->pushBackParametersInfo(0, "Left", String::ftoa(gamepad->getTriggerLeft()));

		info->pushBackParametersInfo(0, "Right", String::ftoa(gamepad->getTriggerRight()));

		info->pushBackParametersInfo(0, "Left Last Delta", String::ftoa(last_trigger_left_delta));

		info->pushBackParametersInfo(0, "Right Last Delta", String::ftoa(last_trigger_right_delta));
		info->pushBackWhiteSpaceLineParametersInfo(0);

		info->pushBackParametersInfo(0, "Buttons", SimpleInformationBox::INFO_ALIGN::CENTER);

		info->pushBackParametersInfo(0, "Last Button Down", last_button_down, SimpleInformationBox::INFO_ALIGN::LEFT);
		info->pushBackParametersInfo(0, "Last Button Pressed", last_button_pressed, SimpleInformationBox::INFO_ALIGN::LEFT);
		info->pushBackParametersInfo(0, "Last Button Up", last_button_up, SimpleInformationBox::INFO_ALIGN::LEFT);
		info->pushBackParametersInfo(0, "                   ", SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(0);
		info->showAdditionalWidgets(0, true);

		if (gamepad->isButtonPressed(Input::GAMEPAD_BUTTON_X))
			car->respawn();

		if(gamepad->isButtonDown(Input::GAMEPAD_BUTTON_Y))
			gamepad->setVibration(low_frequency, high_frequency, vibration_duration);

		car->setAngle(gamepad->getAxesLeft().x);
		car->setVelocity(gamepad->getTriggerRight());
		car->setBrake(gamepad->getTriggerLeft());
	}
	else
	{
		info->pushBackParametersInfo(0, "Connect gamepad.", SimpleInformationBox::INFO_ALIGN::CENTER);
		info->showAdditionalWidgets(0, false);

		if(!gamepad && Input::getNumGamePads())
			gamepad = Input::getGamePad(0);
	}
}

void GamepadInput::update_inputs()
{
	if (!gamepad)
		return;

	if (gamepad->getAxesLeftDelta().length2() > 0)
		last_axes_left_delta = gamepad->getAxesLeftDelta();

	if (gamepad->getAxesRightDelta().length2() > 0)
		last_axes_right_delta = gamepad->getAxesRightDelta();

	if (gamepad->getTriggerLeftDelta() > 0)
		last_trigger_left_delta = gamepad->getTriggerLeftDelta();

	if (gamepad->getTriggerRightDelta() > 0)
		last_trigger_right_delta = gamepad->getTriggerRightDelta();

	for (int i = 0; i < Input::NUM_GAMEPAD_BUTTONS; i++)
	{
		Input::GAMEPAD_BUTTON i_button = Input::GAMEPAD_BUTTON(i);

		if (gamepad->isButtonDown(i_button))
			last_button_down = getGamePadButtonName(i_button);

		if (gamepad->isButtonPressed(i_button) && !pressed_buttons.contains(i))
		{
			pressed_buttons.append(i);
			last_button_pressed = getGamePadButtonName(i_button);
		}

		if (gamepad->isButtonUp(i_button))
		{
			pressed_buttons.remove(i);
			last_button_up = getGamePadButtonName(i_button);
		}
	}
}

void GamepadInput::draw_touches()
{
	if (gamepad->getNumTouches() == 0)
	{
		canvas->setHidden(true);
		return;
	}

	canvas->setHidden(false);
	canvas->clear();

	const static int number_of_colors = 10;
	const static Unigine::Math::vec4 colors[number_of_colors] = {
		Unigine::Math::vec4(1.0f, 0.0f, 0.0f, 1.0f),
		Unigine::Math::vec4(0.0f, 1.0f, 0.0f, 1.0f),
		Unigine::Math::vec4(0.0f, 0.0f, 1.0f, 1.0f),
		Unigine::Math::vec4(1.0f, 1.0f, 0.0f, 1.0f),
		Unigine::Math::vec4(0.0f, 1.0f, 1.0f, 1.0f),
		Unigine::Math::vec4(1.0f, 0.0f, 1.0f, 1.0f),
		Unigine::Math::vec4(1.0f, 1.0f, 1.0f, 1.0f),
		Unigine::Math::vec4(0.5f, 0.0f, 0.0f, 1.0f),
		Unigine::Math::vec4(0.0f, 0.5f, 0.0f, 1.0f),
		Unigine::Math::vec4(0.0f, 0.0f, 0.5f, 1.0f), };

	auto draw_circle = [](vec2 pos, WidgetCanvasPtr canvas, vec4 color,float pressure)
	{
		int polygon = canvas->addPolygon();
		canvas->setPolygonColor(polygon, color);
		const int num = 10;
		const float radius = 10;
		for (int i = 0; i < num; i++)
		{
			float s = Math::sin(Consts::PI2 * i / num) * radius * pressure + pos.x * canvas->getWidth();
			float c = Math::cos(Consts::PI2 * i / num) * radius * pressure + pos.y * canvas->getHeight();
			canvas->addPolygonPoint(polygon, vec3(s, c, 0.0f));
		}
	};

	for (int i = 0; i < gamepad->getNumTouches(); i++)
	{
		for (int j = 0; j < gamepad->getNumTouchFingers(i); j++)
		{
			if (gamepad->getTouchPressure(i,j) > Consts::EPS)
			{
				vec4 color = colors[i * gamepad->getNumTouches() + j];
				draw_circle(gamepad->getTouchPosition(i,j), canvas, color, gamepad->getTouchPressure(i,j));
			}
		}
	}
}

String GamepadInput::getDeviceName(Input::DEVICE t)
{
	String ans = "";

	switch (t)
	{
	case Unigine::Input::DEVICE_UNKNOWN:
		ans = "UNKNOWN";
		break;
	case Unigine::Input::DEVICE_GAME_CONTROLLER:
		ans = "GAME CONTROLLER";
		break;
	case Unigine::Input::DEVICE_WHEEL:
		ans = "WHEEL";
		break;
	case Unigine::Input::DEVICE_ARCADE_STICK:
		ans = "ARCADE STICK";
		break;
	case Unigine::Input::DEVICE_FLIGHT_STICK:
		ans = "FLIGHT STICK";
		break;
	case Unigine::Input::DEVICE_DANCE_PAD:
		ans = "DANCE PAD";
		break;
	case Unigine::Input::DEVICE_GUITAR:
		ans = "GUITAR";
		break;
	case Unigine::Input::DEVICE_DRUM_KIT:
		ans = "DRUM KIT";
		break;
	case Unigine::Input::DEVICE_VR:
		ans = "VR";
		break;
	default:
		break;
	}

	return ans;
}

String GamepadInput::getModelName(InputGamePad::MODEL_TYPE t)
{
	String ans = "";

	switch (t)
	{
	case Unigine::InputGamePad::MODEL_TYPE_UNKNOWN:
		ans = "UNKNOWN";
		break;
	case Unigine::InputGamePad::MODEL_TYPE_XBOX_360:
		ans = "XBOX 360";
		break;
	case Unigine::InputGamePad::MODEL_TYPE_XBOX_ONE:
		ans = "XBOX ONE";
		break;
	case Unigine::InputGamePad::MODEL_TYPE_PS3:
		ans = "PS3";
		break;
	case Unigine::InputGamePad::MODEL_TYPE_PS4:
		ans = "PS4";
		break;
	case Unigine::InputGamePad::MODEL_TYPE_PS5:
		ans = "PS5";
		break;
	default:
		break;
	}

	return ans;
}

String GamepadInput::getGamePadButtonName(Input::GAMEPAD_BUTTON btn)
{
	String ans = "";

	switch (btn)
	{
	case Unigine::Input::GAMEPAD_BUTTON_A: ans = "A"; break;
	case Unigine::Input::GAMEPAD_BUTTON_B: ans = "B"; break;
	case Unigine::Input::GAMEPAD_BUTTON_X: ans = "X"; break;
	case Unigine::Input::GAMEPAD_BUTTON_Y: ans = "Y"; break;
	case Unigine::Input::GAMEPAD_BUTTON_BACK: ans = "BACK"; break;
	case Unigine::Input::GAMEPAD_BUTTON_START: ans = "START"; break;
	case Unigine::Input::GAMEPAD_BUTTON_DPAD_UP: ans = "DPAD_UP"; break;
	case Unigine::Input::GAMEPAD_BUTTON_DPAD_DOWN: ans = "DPAD_DOWN"; break;
	case Unigine::Input::GAMEPAD_BUTTON_DPAD_LEFT: ans = "DPAD_LEFT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_DPAD_RIGHT: ans = "DPAD_RIGHT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_THUMB_LEFT: ans = "THUMB_LEFT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_THUMB_RIGHT: ans = "THUMB_RIGHT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_SHOULDER_LEFT: ans = "SHOULDER_LEFT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_SHOULDER_RIGHT: ans = "SHOULDER_RIGHT"; break;
	case Unigine::Input::GAMEPAD_BUTTON_GUIDE: ans = "GUIDE"; break;
	case Unigine::Input::GAMEPAD_BUTTON_MISC1: ans = "MISC1"; break;
	case Unigine::Input::GAMEPAD_BUTTON_TOUCHPAD: ans = "TOUCHPAD"; break;
	default:
		break;
	}

	return ans;
}

```

## GuiToTexture.cpp

```cpp
#include "GuiToTexture.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(GuiToTexture);

using namespace Unigine;

void GuiToTexture::renderToTexture() const
{
	// Render gui onto texture

	// Save render state and put it at the top of the stack
	// To pop current settings, we will need to call RenderState.RestoreState() at the and of this method
	RenderState::saveState();

	// Now we clear state, so that our rendered texture won't be affected by other render activities
	RenderState::clearStates();

	// Set viewport size matching texture resolution
	RenderState::setViewport(0, 0, texture_resolution.get().x, texture_resolution.get().y);

	// Now we bind gui texture to slot 0, because gui renders in slot 0
	render_target->bindColorTexture(0, gui_texture);
	// Enable render target
	render_target->enable();
	// Clear texture and fill it with black color
	RenderState::clearBuffer(RenderState::BUFFER_COLOR, Math::vec4_black);

	// Now we need to perform the whole gui render loop

	// Enable gui so that it will be updated and rendered
	gui->enable();

	// Update all widgets
	gui->update();

	// Render gui
	gui->preRender();
	gui->render();

	// Disable gui
	gui->disable();

	// Now we need to free render target and unbind texture
	render_target->disable();
	render_target->unbindColorTexture(0);

	// Create texture mipmaps (set of textures of different resolutions to ensure correct rendering at longer distances)
	gui_texture->createMipmaps();

	// Pop render state from top of the stack to let render pipeline continue as usual
	RenderState::restoreState();
}

void GuiToTexture::init()
{
	// Obtain object from the node this component is attached to
	const auto object = checked_ptr_cast<Object>(node);
	if (!object)
	{
		Log::error("GuiToTexture::init: component must be assigned to object");
	}

	// Find the required surface
	const int surface = object->findSurface(surface_name);
	if (surface == -1)
	{
		Log::error("GuiToTexture::init: surface with name %s not found", surface_name.get());
	}

	render_target = RenderTarget::create();

	// We need to inherit material, because there might be other objects that are using this material
	// and we don't want all objects in the scene to get gui from this component
	const MaterialPtr material = object->getMaterialInherit(surface);

	gui = Gui::create();
	gui->setSize(texture_resolution.get());
	gui->setDefaultColor(Math::vec4_red);

	// here we need to specify format of texture: rgba8
	// and set the flag FORMAT_USAGE_RENDER to be able to render into the texture
	// we also need to specify the sampler by setting another flag (bilinear sampler in our case)
	gui_texture = Texture::create();
	gui_texture->create2D(texture_resolution.get().x, texture_resolution.get().y,
		Texture::FORMAT_RGBA8, Texture::FORMAT_USAGE_RENDER | Texture::SAMPLER_FILTER_BILINEAR);

	for (int texture_index = 0, num_textures = texture_slot_names.size(); texture_index < num_textures; ++texture_index)
	{
		const ComponentVariableString &texture_name = texture_slot_names[texture_index];
		material->setTexture(texture_name, gui_texture);
	}
}

void GuiToTexture::update() const
{
	// Update gui if flag is set
	if (auto_update_enabled)
	{
		renderToTexture();
	}
}

```

## HeightSlicer.cpp

```cpp
#include "HeightSlicer.h"

#include <UnigineMaterials.h>


REGISTER_COMPONENT(HeightSlicer);

using namespace Unigine;
using namespace Math;

void HeightSlicer::enable()
{
	Landscape::getEventTextureDraw().connect(this, &HeightSlicer::texture_draw_callback);
}

void HeightSlicer::disable()
{
	disconnectAll();
}

void HeightSlicer::setSourceLmap(
	const Unigine::LandscapeLayerMapPtr &in_source_lmap)
{
	maps.clear();
	source_lmap = in_source_lmap;
	maps.push_back(source_lmap);
}

void HeightSlicer::run()
{
	if (state != State::IDLE)
		return;

	state = State::BEGIN_FETCH_HEIGHT;
}

void HeightSlicer::init()
{
	auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath(
		"landscape_height_slice.basemat"));

	if (guid.isValid())
		slice_material = Materials::findMaterialByFileGUID(guid)->inherit();
	else
		Log::warning(
			"HeightSlicer::init(): can not find \"landscape_height_slice.basemat\""
			"material\n");
}

void HeightSlicer::update()
{
	switch (state)
	{
		case State::IDLE:
			break;
		case State::BEGIN_FETCH_HEIGHT:
		{
			if (source_lmap->getResolution().x == 0 || source_lmap->getResolution().y == 0)
				return;

			if (!buffers)
			{
				buffers = LandscapeTextures::create(source_lmap->getResolution());
			}

			if (!source_lmap_height)
			{
				source_lmap_height = Texture::create();
				source_lmap_height->create2D(source_lmap->getResolution().x, source_lmap->getResolution().y,
					Texture::FORMAT_R32F,
					Texture::SAMPLER_FILTER_LINEAR | Texture::FORMAT_USAGE_RENDER | Texture::SAMPLER_FILTER_BILINEAR | Texture::FORMAT_USAGE_UNORDERED_ACCESS | Texture::SAMPLER_WRAP_MASK);
			}

			if (!buffers_rendered && Landscape::render(maps, buffers, Mat4_identity, source_lmap->getTexelSize().x, 0))
			{
				source_lmap_height->copy(buffers->getHeight());
				buffers_rendered = true;
			} else if (buffers_rendered)
			{
				state = State::BEGIN_DRAW;
			}
			break;
		}
		case State::BEGIN_DRAW:
		{
			state = State::DRAWING;
			Landscape::asyncTextureDraw(target_lmap->getGUID(), {0, 0},
				target_lmap->getResolution());
			break;
		}
		default:
			break;
	}
}

void HeightSlicer::texture_draw_callback(const Unigine::UGUID &guid, int id,
	const Unigine::LandscapeTexturesPtr &buffer, const Unigine::Math::ivec2 &coord, int data_mask)
{
	auto render_target = Render::getTemporaryRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	render_target->bindColorTexture(0, buffer->getAlbedo());
	render_target->bindColorTexture(1, buffer->getHeight());

	render_target->enable();
	{
		slice_material->setTexture("source_height", source_lmap_height);
		slice_material->setParameterFloat("slice_height", toFloat(slice_height * source_lmap->getExtremumHeight().y));
		slice_material->setParameterFloat("min_height", toFloat(source_lmap->getExtremumHeight().x));
		slice_material->setParameterFloat("max_height", toFloat(source_lmap->getExtremumHeight().y));

		slice_material->renderScreen("landscape_height_slice");
	}
	render_target->disable();
	render_target->unbindColorTexture(1);
	render_target->unbindColorTexture(0);

	RenderState::restoreState();
	Render::releaseTemporaryRenderTarget(render_target);

	state = State::IDLE;
}

```

## HttpImageRequestSample.cpp

```cpp
#include "HttpImageRequestSample.h"

#include <UnigineWidgets.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(HttpImageRequestSample);
REGISTER_COMPONENT(HttpImageToTexture);

using namespace Unigine;
using namespace Math;

void HttpImageRequestSample::init()
{
	ThreadQueue::get().run();
}

void HttpImageRequestSample::shutdown()
{
	ThreadQueue::get().stop();
}

void HttpImageToTexture::init()
{
	String host_str = host.get();
	String args_str = args.get();
	request = std::make_unique<AsyncTask<httplib::Result>>([host_str, args_str]() -> httplib::Result {
		httplib::Client cli(host_str.get());
		return cli.Get(args_str.get());
	});
}

void HttpImageToTexture::update()
{
	if (request && request->isCompleted())
	{
		if (httplib::Result &result = request->get())
		{
			if (result->status == 200)
			{
				unsigned char *data = (unsigned char *)result->body.data();

				image = Image::create();
				bool loaded = image->load(data, toInt(result->body.size()));
				if (!loaded)
				{
					Log::error("HttpImageToTexture can not load image\n");
					FilePtr file = File::create("wrong_image", "wb");
					file->write(data, result->body.size());
					file->close();
					Log::error("HttpImageToTexture save loaded image to 'data/wrong_image' file\n");
				}
				ObjectPtr object = checked_ptr_cast<Object>(node);
				if (!object)
					Log::error("HttpImageToTexture can be assigned only to Objects: %s(%d) is %s\n", node->getName(), node->getID(), node->getTypeName());
				auto mat = object->getMaterialInherit(surface.get());
				if (!mat)
					Log::error("HttpImageToTexture can not find any material on %d surface of %s(%d)\n", surface.get(), node->getName(), node->getID());
				int slot = mat->findTexture(texture.get());
				if (!mat)
					Log::error("HttpImageToTexture can not find texture slot '%s' in material on %d surface of %s(%d)\n", texture.get(), surface.get(), node->getName(), node->getID());
				mat->setTextureImage(slot, image);
			} else
				Log::message("%d %s\n", result->status, result->reason.c_str());

		} else
		{
			String error = httplib::to_string(result.error()).c_str();
			Log::error("%s\n", error.get());
		}

		request.reset();
	}
}

```

## HttpImageResponseSample.cpp

```cpp
#include "HttpImageResponseSample.h"

REGISTER_COMPONENT(HttpImageResponseSample);

using namespace Unigine;
using namespace Math;

void HttpImageResponseSample::init_gui()
{
	auto object_text = checked_ptr_cast<ObjectText>(pedestal_text.get());
	object_text->setFontRich(1);
	object_text->setText("<p>Open:</p><p>http://" + String(host_ip.get()) + ":" + String::itoa(port) + "/unigine.png</p>");
	auto prev_pos = object_text->getPosition();
	object_text->setPosition(Vec3(object_text->getTextWidth() / 2, prev_pos.y, prev_pos.z));
}

void HttpImageResponseSample::init()
{
	Engine::get()->setBackgroundUpdate(Engine::BACKGROUND_UPDATE_RENDER_ALWAYS);

	init_gui();

	auto window = WindowManager::getMainWindow();
	window->getEventFuncEndRender().connect(this, &HttpImageResponseSample::grab_engine_texture);

	texture = Texture::create();
	texture->create2D(window->getClientRenderSize().x, window->getClientRenderSize().y, Texture::FORMAT_RGBA8, Texture::FORMAT_USAGE_RENDER);

	window->getEventResized().connectUnsafe([this]() {
		auto window = WindowManager::getMainWindow();
		texture->create2D(window->getClientRenderSize().x, window->getClientRenderSize().y, Texture::FORMAT_RGBA8, Texture::FORMAT_USAGE_RENDER);
	});

	server = new HttpServer(host_ip.get(), port.get());

	server->get("/unigine.png", [this](const httplib::Request &req, httplib::Response &res) {
		// This function will be called from another thread because it is marked as asynchronous
		need_convert = true;

		while (!image_ready && !server->isStopped())
		{
			Thread::switchThread();
		}

		if (image_ready)
		{
			ScopedLock lock{ png_data_mutex };
			res.set_content(png_data.get(), png_data.size(), "image/png");
		}
		else
		{
			res.status = 500;
			res.set_content("Failed to convert to PNG", "text/plain");
		}

		image_ready = false;

	},
	true);

	server->run();
}

void HttpImageResponseSample::update()
{
	if (need_convert)
	{
		NodePtr check_node = node;
		Render::asyncTransferTextureToImage(nullptr, MakeCallback([this, check_node](ImagePtr& transfered) {
			// This callback will be called asynchronous from another thread
			if (!check_node)
				return;

			ScopedLock lock{ png_data_mutex };

			UGUID guid = FileSystem::addVirtualFile("unigine.png");
			FileSystem::addBlobFile(guid);

			transfered->convertToFormat(Image::FORMAT_RGB8);
			transfered->save(FileSystem::guidToPath(guid).get());

			FilePtr file = File::create(FileSystem::guidToPath(guid).get(), "rb");

			png_data.resize(toInt(file->getSize()));
			file->read(png_data.getRaw(), png_data.size());

			file->close();
			FileSystem::removeBlobFile(guid);
			FileSystem::removeVirtualFile(guid);


			image_ready = true;
		}),
		texture);

		need_convert = false;
	}
}

void HttpImageResponseSample::shutdown()
{
	server->stop();
	delete server;
	server = nullptr;
}

void HttpImageResponseSample::grab_engine_texture()
{
	texture->copy2D();
}

```

## HttpServer.cpp

```cpp
#include "HttpServer.h"

#include <UnigineEngine.h>

using namespace Unigine;

HttpServer::HttpServer(String host_ip, int server_port)
	: host(host_ip.get())
	, port(server_port)
{
	server.set_pre_routing_handler([](const httplib::Request& req, httplib::Response& res) {
		res.set_header("Access-Control-Allow-Origin", "*");
		res.set_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
		res.set_header("Access-Control-Allow-Headers", "Content-Type");
		return httplib::Server::HandlerResponse::Unhandled;
	});

	Engine::get()->getEventEndUpdate().connect(engine_update_connection, this, &HttpServer::process_tasks);
}

HttpServer::~HttpServer() = default;

void HttpServer::process()
{
	stopped = false;
	server.listen(host, port);
}

void HttpServer::process_tasks()
{
	// sync tasks should be executed only in main thread
	if (!Engine::get()->isMainThread())
		return;

	ScopedLock lock{ tasks_queue_mutex };
	for (int i = 0; i < tasks_queue.size(); ++i)
	{
		auto task = tasks_queue[i];
		task->handler(task->request, task->response);
		task->completed = true;
	}
	tasks_queue.clear();
}

void HttpServer::stop()
{
	server.stop();
	stopped = true;
	Thread::stop();
}

void HttpServer::get(const char* route, std::function<void(const httplib::Request &req, httplib::Response &res)> handler, bool async)
{
	server.Get(route, [this, handler, async](const httplib::Request &req, httplib::Response &res) {
		auto task = std::make_shared<TaskHandler>(handler, req, res);
		if (async)
		{
			task->handler(req, res);
			task->completed = true;
		}
		else
		{
			ScopedLock lock{ tasks_queue_mutex };
			tasks_queue.push_back(task);
		}

		// waiting for sync task complete
		while (!task->completed && !task->canceled)
		{
			Thread::switchThread();
		}

		task.reset();
	});
}
```

## IFpsMovementController.cpp

```cpp
#include "IFpsMovementController.h"

#include <Unigine.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(IFpsMovementController);

void IFpsMovementController::update()
{
	if (use_ifps)
	{
		node->translate(current_dir * movement_speed * Game::getIFps());
	}
	else {
		node->translate(current_dir * movement_speed);
	}

	if (node->getWorldPosition().x > 5)
		current_dir = Vec3_left;
	if (node->getWorldPosition().x < -5)
		current_dir = Vec3_right;
}
```

## IFpsMovementSample.cpp

```cpp
#include "IFpsMovementSample.h"

REGISTER_COMPONENT(IFpsMovementSample);

using namespace Unigine;
using namespace Math;


void IFpsMovementSample::init()
{
	window_sample.createWindow();

	WidgetSliderPtr fpsSlider = window_sample.addIntParameter("Max FPS", "Max FPS", 60, 15, 150, [this](int v) {
		Render::setMaxFPS(v);
		});
	Render::setMaxFPS(60);
}

void IFpsMovementSample::shutdown()
{
	window_sample.shutdown();
}

```

## Icon.cpp

```cpp
#include "Icon.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(Icon);

using namespace Unigine;
using namespace Math;

void Icon::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_icon = WidgetIcon::create(gui, icon_image.get());

	gui->addChild(widget_icon, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_icon->setPosition(position.get().x, position.get().y);
	widget_icon->setWidth(size.get().x);
	widget_icon->setHeight(size.get().y);
	widget_icon->setToggleable(true);

	widget_icon->getEventClicked().connect(*this, [this]() {
		String msg = String("Icon: ") + (widget_icon->isToggled() ? "True" : "False");
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void Icon::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_icon);

		widget_icon.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## ImagesSample.cpp

```cpp
#include "ImagesSample.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

/////////////////////////////////////////////////////////
// Image manipulation functions
/////////////////////////////////////////////////////////

void ImagesSample::image_init()
{
	positions.resize(num_fields);
	velocities.resize(num_fields);
	radiuses.resize(num_fields);

	for (int i = 0; i < num_fields; ++i)
	{
		positions[i].x = randFloat(0.f, size);
		positions[i].y = randFloat(0.f, size);
		positions[i].z = randFloat(0.f, size);

		velocities[i].x = randFloat(-velocity, velocity);
		velocities[i].y = randFloat(-velocity, velocity);
		velocities[i].z = randFloat(-velocity, velocity);

		radiuses[i] = randFloat(radius / 2, radius);
	}
}

void ImagesSample::image_update()
{
	float ifps = Game::getIFps();

	for (int i = 0; i < num_fields; ++i)
	{
		vec3 p = positions[i] + velocities[i] * ifps;
		if (p.x < 0.f || p.x > size)
		{
			velocities[i].x = -velocities[i].x;
		}
		if (p.y < 0.f || p.y > size)
		{
			velocities[i].y = -velocities[i].y;
		}
		if (p.z < 0.f || p.z > size)
		{
			velocities[i].z = -velocities[i].z;
		}

		positions[i] += velocities[i] * ifps;
	}

	int width = image->getWidth();
	int height = image->getHeight();
	int depth = image->getDepth();

	// here we get a raw representation of pixels
	// below you can find how we can change its values
	unsigned char *d = image->getPixels3D();

	vec3 position;
	float iwidth = size / width;
	float iheight = size / height;
	float idepth = size / depth;
	for (int z = 0; z < depth; ++z)
	{
		position.z = static_cast<float>(z) * idepth;
		for (int y = 0; y < height; ++y)
		{
			position.y = static_cast<float>(y) * iheight;
			for (int x = 0; x < width; x++)
			{
				position.x = static_cast<float>(x) * iwidth;
				float field = 0.f;
				for (int i = 0; i < num_fields; i++)
				{
					float distance = distance2(positions[i], position);
					if (distance < radiuses[i])
					{
						field += radiuses[i] - distance;
					}
				}

				if (field > 1.f)
				{
					field = 1.f;
				}
				// here we find color of pixel
				unsigned char density = static_cast<unsigned char>(field * 255.f);

				// "d" is a pointer to all pixels of image
				// each element in array, at which "d" is pointing at
				// is a value of color channel in pixel
				// here is a representation of how it looks like
				// chars   d
				//        
				// RGBARGBARGBARGBARGBA
				*d++ = density; // R
				*d++ = density; // G
				*d++ = density; // B
				*d++ = density; // A

				// now d points to an R channel of the next pixel
			}
		}
	}
}


// ----------------Sample Logic-----------------
REGISTER_COMPONENT(ImagesSample)

void ImagesSample::init()
{
	image = Image::create();
	image->create3D(32, 32, 32, Image::FORMAT_RGBA8);

	image_init();

	ObjectVolumeBoxPtr object = ObjectVolumeBox::create(vec3(20.f));
	object->setMaterial(Materials::findManualMaterial("Unigine::volume_cloud_base"), "*");
	object->setMaterialState("samples", 2, 0);
	object->setTransform(translate(Vec3(0.f, 0.f, 1.f)));
	material = object->getMaterialInherit(0);
}

void ImagesSample::update()
{
	image_update();

	material->setTextureImage(material->findTexture("density_3d"), image);
}

```

## InputManager.cpp

```cpp
#include "InputManager.h"
#include <UnigineGame.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(InputManager)

void InputManager::update()
{
	if (Console::isActive())
		return;

	int positive = 0;
	int negative = 0;
	
	positive = Input::isKeyPressed(static_cast<Input::KEY>(key_forward));
	negative = Input::isKeyPressed(static_cast<Input::KEY>(key_backward));
	trottle = static_cast<float>(positive - negative);

	positive = Input::isKeyPressed(static_cast<Input::KEY>(key_right));
	negative = Input::isKeyPressed(static_cast<Input::KEY>(key_left));
	turn = static_cast<float>(positive - negative);
}

```

## Interactable.cpp

```cpp
#include "Interactable.h"


const int Interactable::interactable_update_priority = 10;
```

## InteractableButtonComponent.cpp

```cpp
#include "InteractableButtonComponent.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(InteractableButtonComponent);

using namespace Unigine;
using namespace Math;

void InteractableButtonComponent::init()
{
	if (!transformation_node)
	{
		transformation_node = node;
	}

	button_state = default_state;
	rotation_axis = normalize(rotation_axis.get());
	rotation_off_quat = transformation_node->getRotation();
	rotation_on_quat = rotation_off_quat * quat(rotation_axis.get(), rotation_angle);

	position_off = transformation_node->getPosition();
	position_on = transformation_node->getPosition() + (Vec3)position;

	if (default_state)
	{
		time = anim_duration;
	}
}

void InteractableButtonComponent::update()
{
	if (!togglable && !used_current_frame)
	{
		button_state = default_state;
	}

	time = clamp((time - (Game::getIFps() * (button_state ? -1.0f : 1.0f))), 0.0f, anim_duration);

	if (has_animation_time)
	{
		value = (time / anim_duration.get());
	}
	else
	{
		value = button_state ? 1.0f : 0.0f;
	}

	Vec3 new_position = static_cast<Vec3>(lerp(position_off, position_on, value));
	quat new_rotation = slerp(rotation_off_quat, rotation_on_quat, value);

	transformation_node->setTransform(
		static_cast<Mat4>(rotate(new_rotation)) * translate(new_position));

	used_last_frame = used_current_frame;
	used_current_frame = false;
}

void InteractableButtonComponent::use(PlayerPtr player, Unigine::Math::vec3 intersection_point)
{
	used_current_frame = true;
	if (togglable)
	{
		if (!used_last_frame)
		{
			button_state = 1 - button_state;
		}
	}
	else
	{
		if (used_last_frame)
		{
			button_state = 1 - default_state;
		}
	}
}

float InteractableButtonComponent::getValue()
{
	if (has_animation_time)
	{
		return value;
	}
	else
	{
		return button_state ? 1.0f : 0.0f;
	}
}
```

## InteractableLeverComponent.cpp

```cpp
#include "InteractableLeverComponent.h"
#include "UnigineVisualizer.h"
REGISTER_COMPONENT(InteractableLeverComponent);

using namespace Unigine;
using namespace Math;


const float angle_eps = 0.05f;

void InteractableLeverComponent::init()
{
	if (!transformation_node)
		transformation_node = node;

	rotation_axis = normalize(rotation_axis.get());
	valve_plane_x = (vec3)transformation_node->getWorldDirection(AXIS_Z).normalize();
	valve_plane_normal = (transformation_node->getWorldRotation() * rotation_axis).normalize();
	valve_plane_y = cross(valve_plane_normal, valve_plane_x).normalize();
	initial_rotation = transformation_node->getWorldRotation();
}

void InteractableLeverComponent::use(Unigine::PlayerPtr player, Unigine::Math::vec3 intersection_point)
{
	used_current_frame = true;
	player_view_direction = player->getViewDirection();
	player_position = (vec3)player->getWorldPosition();
}

void InteractableLeverComponent::update()
{
	if (is_movable)
	{
		valve_plane_normal = (transformation_node->getWorldRotation() * rotation_axis).normalize();
		valve_plane_x = (quat(valve_plane_normal, -rotation_angle) * (vec3)transformation_node->getWorldDirection(AXIS_Z)).normalize();
		valve_plane_y = cross(valve_plane_normal, valve_plane_x).normalize();
	}

	if (used_current_frame)
	{
		lever_position = (vec3)transformation_node->getWorldPosition();
		player_vec = (player_position + player_view_direction * (player_position - lever_position).length()) - lever_position;

		rotation_vec = valve_plane_x * dot(valve_plane_x, player_vec) + valve_plane_y * dot(valve_plane_y, player_vec);
		rotation_vec.normalize();
	}

	if (Math::abs(rotation_angle - rotation_angle_target) > angle_eps || used_current_frame)
	{
		rotation_angle_target = getAngle(valve_plane_x, rotation_vec, vec3(valve_plane_normal));
		rotation_angle_target = clamp(rotation_angle_target, 0.0f, rotation_angle_range);
		rotation_angle = lerp(rotation_angle, rotation_angle_target, 0.2f);
		transformation_node->setRotation(initial_rotation * quat(rotation_axis, rotation_angle));
	}

	if (used_current_frame)
	{
		rotation_vec_old = rotation_vec;
		used_last_frame = used_current_frame;
		used_current_frame = false;
	}
}

float InteractableLeverComponent::getValue()
{
	return rotation_angle / rotation_angle_range;
}
```

## InteractableValveComponent.cpp

```cpp
#include "InteractableValveComponent.h"

#include "UnigineVisualizer.h"
REGISTER_COMPONENT(InteractableValveComponent);

using namespace Unigine;
using namespace Math;

const float angle_eps = 0.05f;

void InteractableValveComponent::init()
{
	if (!transformation_node)
	{
		transformation_node = node;
	}

	valve_plane_x = (vec3)transformation_node->getWorldDirection(AXIS_X).normalize();
	valve_plane_y = (vec3)transformation_node->getWorldDirection(AXIS_Y).normalize();
	valve_plane_normal = (vec3)transformation_node->getWorldDirection(AXIS_Z).normalize();

	player_view_direction = valve_plane_y;
	grab_point = (vec3)transformation_node->getWorldPosition();
}

void InteractableValveComponent::use(Unigine::PlayerPtr player,
	Unigine::Math::vec3 intersection_point)
{
	used_current_frame = true;
	player_view_direction = player->getViewDirection();
	player_position = (vec3)player->getWorldPosition();

	grab_point = intersection_point;
	if (!used_last_frame)
	{
		vec3 grab_vec = (grab_point - (vec3)transformation_node->getWorldPosition());
		grab_vec_old = valve_plane_x * dot(valve_plane_x, grab_vec)
			+ valve_plane_y * dot(valve_plane_y, grab_vec);
	}
}

void InteractableValveComponent::update()
{
	if (is_movable)
	{
		valve_plane_x = (vec3)transformation_node->getWorldDirection(AXIS_X).normalize();
		valve_plane_y = (vec3)transformation_node->getWorldDirection(AXIS_Y).normalize();
		valve_plane_normal = (vec3)transformation_node->getWorldDirection(AXIS_Z).normalize();
	}
	if (used_current_frame)
	{
		vec3 valve_position = (vec3)transformation_node->getWorldPosition();
		grab_vec = (player_position
					   + player_view_direction * (player_position - valve_position).length())
			- valve_position;

		rotation_vec = valve_plane_x * dot(valve_plane_x, grab_vec)
			+ valve_plane_y * dot(valve_plane_y, grab_vec);
		rotation_vec.normalize();
	}
	if (Math::abs(rotation_angle - rotation_angle_target) > angle_eps || used_current_frame)
	{
		rotation_angle_target += getAngle(vec3(grab_vec_old), vec3(rotation_vec),
			vec3(valve_plane_normal));
		rotation_angle_target = clamp(rotation_angle_target, 0.0f, rotation_angle_range);
		rotation_angle = lerp(rotation_angle, rotation_angle_target, 0.1f);

		transformation_node->setRotation(
			quat(vec3(transformation_node->getDirection(AXIS_Z)), rotation_angle));
	}
	grab_vec_old = rotation_vec;
	used_last_frame = used_current_frame;
	used_current_frame = false;
}

float InteractableValveComponent::getValue()
{
	return rotation_angle / rotation_angle_range;
}

```

## InteractorComponent.cpp

```cpp
#include "InteractorComponent.h"

#include "UnigineVisualizer.h"

REGISTER_COMPONENT(InteractorComponent);

using namespace Unigine;
using namespace Math;

const float interaction_distance = 10;

void InteractorComponent::init()
{
	mouse_handle = Input::getMouseHandle();
	Visualizer::setEnabled(true);

	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	player = checked_ptr_cast<Player>(node);
	if (!player)
	{
		Log::error("InteractorComponent::init: this component should be placed only on Player "
				   "node. '%s'%d\n",
			node->getName(), node->getID());
		return;
	}
}

void InteractorComponent::update()
{

	if (Input::isKeyDown(Input::KEY_F))
	{
		ivec2 mouse = Input::getMousePosition();
		Vec3 p0 = player->getWorldPosition();
		Vec3 p1 = p0
			+ Vec3(player->getDirectionFromMainWindow(mouse.x, mouse.y)) * interaction_distance;

		obj = World::getIntersection(p0, p1, interactable_intersection_mask.get(), intersection);
	}
	if (Input::isKeyPressed(Input::KEY_F))
	{
		if (obj)
		{
			ivec2 mouse = Input::getMousePosition();
			Vec3 p0 = player->getWorldPosition();
			Vec3 p1 = p0
				+ Vec3(player->getDirectionFromMainWindow(mouse.x, mouse.y)) * interaction_distance;

			World::getIntersection(p0, p1, ~0, intersection);
			comp_interactable = ComponentSystem::get()->getComponent<Interactable>(obj);
			if (comp_interactable)
			{
				comp_interactable->use(player, (vec3)intersection->getPoint());
			}
		}
	}
	if (Input::isKeyUp(Input::KEY_F))
	{
		obj = nullptr;
	}
}

void InteractorComponent::post_update()
{
	Visualizer::renderVector(player->getWorldPosition(),
		player->getWorldPosition() + (Vec3)player->getViewDirection(), vec4_white, 0.015f, false,
		0.0f, false);
}

void InteractorComponent::shutdown()
{
	Visualizer::setEnabled(false);
	Input::setMouseHandle(mouse_handle);
}

```

## Intersections.cpp

```cpp
#include "Intersections.h"
#include <UnigineEngine.h>

using namespace Unigine;
using namespace Math;

////////////////////////////////////////////////////////
// Intersection Request
////////////////////////////////////////////////////////

void IntersectionRequestCPUShader::process(int thread_num, int threads_count)
{
	while (true)
	{
		int num = AtomicAdd(&counter, 1);
		if (num >= requests.size())
			return;

		if (is_force)
			requests[num]->getForce();
		else
			requests[num]->getAsync();
	}
}

void IntersectionRequestCPUShader::run(int threads_count)
{
	counter = 0;
	runSync(threads_count);
}

IntersectionRequest::IntersectionRequest(int async_world_check)
{
	flags.async_mode = async_world_check;
	flags.async_stage = ASYNC_IS_COMPLETED;
	flags.is_critical_async = false;
	flags.is_world_intersection = false;

	world_intersection = WorldIntersectionNormal::create();

	landscape_fetch = LandscapeFetch::create();
	landscape_fetch->setUses(0);
	landscape_fetch->setUsesNormal(true);
	landscape_fetch->getEventEnd().connect(this, &IntersectionRequest::on_landscape_async_end);


	if (flags.async_mode == ASYNC_MODE_RENDER_BEGIN)
			Engine::get()->getEventBeginRender().connect(on_begin_render_id, this, &IntersectionRequest::on_engine_begin_render);
}

// async
bool IntersectionRequest::isAsyncCompleted()
{
	if (flags.async_stage == ASYNC_PROCESSING_STAGE && landscape_fetch->isAsyncCompleted())
		flags.async_stage = ASYNC_IS_COMPLETED;

	return flags.async_stage == ASYNC_IS_COMPLETED;
}

void IntersectionRequest::wait()
{
	if (flags.async_mode == ASYNC_MODE_RENDER_BEGIN && flags.async_stage != ASYNC_PROCESSING_STAGE)
		async_intersection();

	landscape_fetch->wait();
	flags.async_stage = ASYNC_IS_COMPLETED;
}

// results
bool IntersectionRequest::isIntersection()
{
	if (flags.async_stage != ASYNC_NOT_USED)
		return (flags.is_world_intersection || landscape_fetch->isIntersection()) && isAsyncCompleted();

	return flags.is_world_intersection;
}

NodePtr IntersectionRequest::getNode()
{
	if (flags.async_stage != ASYNC_NOT_USED && isAsyncCompleted() && landscape_fetch->isIntersection())
		return Landscape::getActiveTerrain();

	return world_node;
}

Vec3 IntersectionRequest::getPoint()
{
	if (flags.async_stage != ASYNC_NOT_USED && isAsyncCompleted() && landscape_fetch->isIntersection())
		return landscape_fetch->getPosition();

	if (flags.is_world_intersection)
		return world_intersection->getPoint();

	return Vec3_zero;
}

vec3 IntersectionRequest::getNormal()
{
	if (flags.async_stage != ASYNC_NOT_USED && isAsyncCompleted() && landscape_fetch->isIntersection())
		return landscape_fetch->getNormal();

	if (flags.is_world_intersection)
		return world_intersection->getNormal();

	return vec3_up;
}

// requests
bool IntersectionRequest::getForce()
{
	// update async
	flags.async_stage = ASYNC_NOT_USED;

	// clear results
	flags.is_world_intersection = false;
	world_node = nullptr;

	// check intersection
	world_node = World::getIntersection(position_begin, position_end, mask, exclude, world_intersection);
	if (world_node)
		flags.is_world_intersection = true;

	return flags.is_world_intersection;
}

bool IntersectionRequest::getForce(const Vec3 &p0, const Vec3 &p1)
{
	position_begin = p0;
	position_end = p1;
	return getForce();
}

bool IntersectionRequest::getForce(const Vec3 &p0, const Vec3 &p1, int in_mask)
{
	mask = in_mask;
	return getForce(p0, p1);
}

bool IntersectionRequest::getForce(const Vec3 &p0, const Vec3 &p1, int in_mask, const Vector<NodePtr> &exclude_nodes)
{
	exclude = exclude_nodes;
	return getForce(p0, p1, in_mask);
}

void IntersectionRequest::getAsync(bool is_critical)
{
	// update async
	flags.async_stage = ASYNC_PREPARE_STAGE;
	flags.is_critical_async = is_critical;
	async_begin_frame = Engine::get()->getFrame();

	// clear results
	flags.is_world_intersection = false;
	world_node = nullptr;

	if (flags.async_mode == ASYNC_MODE_RENDER_BEGIN)
		return;

	async_intersection();
}

void IntersectionRequest::getAsync(const Vec3 &p0, const Vec3 &p1, bool is_critical)
{
	position_begin = p0;
	position_end = p1;
	getAsync(is_critical);
}

void IntersectionRequest::getAsync(const Vec3 &p0, const Vec3 &p1, int in_mask, bool is_critical)
{
	mask = in_mask;
	getAsync(p0, p1, is_critical);
}

void IntersectionRequest::getAsync(const Vec3 &p0, const Vec3 &p1, int in_mask, const Vector<NodePtr> &exclude_nodes, bool is_critical)
{
	exclude = exclude_nodes;
	getAsync(p0, p1, in_mask, is_critical);
}

// internal
void IntersectionRequest::on_engine_begin_render()
{
	if (flags.async_mode != ASYNC_MODE_RENDER_BEGIN)
		return;

	// we can use wait after getAsync
	// in this case invoke immediately world check
	if (flags.async_stage != ASYNC_PREPARE_STAGE)
		return;

	async_intersection();
}

void IntersectionRequest::async_intersection()
{
	bool is_terrain_exluded = exclude.contains(Landscape::getActiveTerrain());
	if (!is_terrain_exluded)
		exclude.append(Landscape::getActiveTerrain());

	flags.async_stage = ASYNC_PROCESSING_STAGE;

	world_node = World::getIntersection(position_begin, position_end, mask, exclude, world_intersection);
	if (world_node)
		flags.is_world_intersection = true;

	if (!is_terrain_exluded)
	{
		exclude.removeOne(Landscape::getActiveTerrain());
		landscape_fetch->intersectionAsync(position_begin, flags.is_world_intersection ? world_intersection->getPoint() : position_end, flags.is_critical_async);
	} else
	{
		flags.async_stage = ASYNC_IS_COMPLETED;
		on_landscape_async_end();
	}
}

void IntersectionRequest::on_landscape_async_end()
{
	async_end_frame = Engine::get()->getFrame();
	async_end_signal.invoke(this);
}

////////////////////////////////////////////////////////
// Intersections
////////////////////////////////////////////////////////

Intersections::~Intersections()
{
	for (int i = 0; i < async_requests.size(); i++)
	{
		async_requests[i].request->landscape_fetch->wait();
		delete async_requests[i].request;
		delete async_requests[i].func;
	}
	async_requests.clear();
}

bool Intersections::getForce(const Vec3 &p0, const Vec3 &p1, int mask)
{
	return get().force_request.getForce(p0, p1, mask);
}

bool Intersections::getForce(const Vec3 &p0, const Vec3 &p1, int mask, const Vector<NodePtr> &exclude_nodes)
{
	return get().force_request.getForce(p0, p1, mask, exclude_nodes);
}

void *Intersections::getAsync(const Vec3 &p0, const Vec3 &p1, int mask, CallbackBase1<IntersectionRequest *> *func, int invoke_stage, bool is_critical)
{
	get().set_callbacks();
	AsyncData *data = grab_request_data();

	data->invoke_stage = invoke_stage;
	data->func = func;
	data->request->getAsync(p0, p1, mask, is_critical);

	return data->request;
}

void *Intersections::getAsync(const Vec3 &p0, const Vec3 &p1, int mask, const Vector<NodePtr> &exclude_nodes, CallbackBase1<IntersectionRequest *> *func, int invoke_stage, bool is_critical)
{
	get().set_callbacks();
	AsyncData *data = grab_request_data();

	data->invoke_stage = invoke_stage;
	data->func = func;
	data->request->getAsync(p0, p1, mask, exclude_nodes, is_critical);

	return data->request;
}

void Intersections::getForce(const Vector<IntersectionRequest *> &requests)
{
	IntersectionRequestCPUShader shader(requests, true);
	shader.run(get().threads_count);
}

void Intersections::getAsync(const Unigine::Vector<IntersectionRequest *> &requests)
{
	IntersectionRequestCPUShader shader(requests, false);
	shader.run(get().threads_count);
}

void Intersections::wait(const Unigine::Vector<IntersectionRequest *> &requests)
{
	for (auto r : requests)
		r->wait();
}

void Intersections::set_callbacks()
{
	if (!connections.empty())
		return;

	Engine::get()->getEventBeginUpdate().connect(connections, &Intersections::on_engine_update);
	Engine::get()->getEventBeginRender().connect(connections, &Intersections::on_engine_render);
	Engine::get()->getEventBeginSwap().connect(connections, &Intersections::on_engine_swap);
}

Intersections::AsyncData *Intersections::grab_request_data()
{
	Vector<AsyncData> &async_requests = get().async_requests;

	AsyncData *data = nullptr;
	for (int i = 0; i < async_requests.size(); i++)
	{
		if (async_requests[i].is_free)
		{
			data = &async_requests[i];
			data->is_free = false;
			break;
		}
	}

	if (!data)
	{
		data = &async_requests.append();
		data->request = new IntersectionRequest(IntersectionRequest::ASYNC_MODE_RENDER_BEGIN);
	}

	return data;
}

void Intersections::check_request(Intersections::AsyncData *data)
{
	if (!data)
		return;

	if (!data->is_free && data->request->isAsyncCompleted())
	{
		if (data->func)
			data->func->run(data->request);

		data->is_free = true;
		delete data->func;
		data->func = nullptr;
	}
}

void Intersections::on_engine_update()
{
	Vector<AsyncData> &async_requests = get().async_requests;

	for (int i = 0; i < async_requests.size(); i++)
	{
		if (async_requests[i].invoke_stage == INVOKE_STAGE_UPDATE)
			check_request(&async_requests[i]);
	}
}

void Intersections::on_engine_render()
{
	Vector<AsyncData> &async_requests = get().async_requests;

	for (int i = 0; i < async_requests.size(); i++)
	{
		if (async_requests[i].invoke_stage == INVOKE_STAGE_RENDER)
			check_request(&async_requests[i]);
	}
}

void Intersections::on_engine_swap()
{
	Vector<AsyncData> &async_requests = get().async_requests;

	for (int i = 0; i < async_requests.size(); i++)
	{
		if (async_requests[i].invoke_stage == INVOKE_STAGE_SWAP)
			check_request(&async_requests[i]);
	}
}

```

## JointCallbacks.cpp

```cpp
#include "JointCallbacks.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(JointCallbacks)


void JointCallbacks::init()
{
	// parameters validation
	auto file_path = mesh_file.get();
	if (String::isEmpty(file_path))
	{
		Log::error("JointCallbacks::init(): Mesh File parameter is empty!\n");
		return;
	}

	broken_mat = broken_materal.get();
	if (!broken_mat)
	{
		Log::error("JointCallbacks::init(): Broken Matreial parameter is empty!\n");
		return;
	}

	joint_mat = joint_materal.get();
	if (!joint_mat)
	{
		Log::error("JointCallbacks::init(): Joint Matreial parameter is empty!\n");
		return;
	}

	// general Physics settings
	Physics::setFrozenLinearVelocity(0.1f);
	Physics::setFrozenAngularVelocity(0.1f);

	// create object from mesh file
	ObjectMeshStaticPtr orig_object = ObjectMeshStatic::create(file_path);

	// create weights to break bridge
	BodyRigidPtr body = BodyRigid::create(orig_object);
	ShapeBoxPtr shape = ShapeBox::create(body, vec3(1.f));
	shape->setDensity(80.0f);
	for (int i = 0; i < 3; i++)
	{
		auto object = static_ptr_cast<ObjectMeshStatic>(orig_object->clone());
		object->setWorldTransform(translate(Vec3(3.0f * (i - 1), 0.f, 12.0f)));
		objects.append(object);
	}

	// remove body from object
	orig_object->setBody(nullptr);
	body.deleteLater();

	// create bridge via boxes and joints
	orig_object->setMaterial(joint_mat, "*");
	BodyPtr b0, b1;
	for (int i = 0; i < bridge_sections; i++)
	{
		auto object = static_ptr_cast<ObjectMeshStatic>(orig_object->clone());
		float pos = space * (i - (bridge_sections - 1) / 2.f);
		object->setWorldTransform(translate(Vec3(pos, 0.f, 8.f)));

		// set first and last bridge section as BodyDummy so they won't fall
		if (i == 0 || i == bridge_sections - 1)
			b1 = BodyDummy::create(object);
		else
			b1 = BodyRigid::create(object);
		ShapeBoxPtr shape2 = ShapeBox::create(b1, vec3(1.f));
		objects.append(object);

		// create joint between two neighbour boxes
		if (b0)
		{
			JointHingePtr joint = JointHinge::create(b0, b1, Vec3(pos - space, 0.f, 8.f),
				vec3_right);
			joint->setAngularDamping(8.f);
			joint->setNumIterations(4);
			joint->setLinearRestitution(0.02f);
			joint->setAngularRestitution(0.02f);
			joint->setMaxForce(1000.f);
			joint->setMaxTorque(16000.f);
			// subscribind to joint breaking event
			joint->getEventBroken().connect(joint_connections, this,
				&JointCallbacks::broken_callback);
		}

		b0 = b1;
	}

	orig_object.deleteLater();
}

void JointCallbacks::shutdown()
{
	// remove all connections
	joint_connections.disconnectAll();
	objects.clear();
}

void JointCallbacks::broken_callback(const Unigine::JointPtr &joint)
{
	// change material of broken parts
	joint->getBody0()->getObject()->setMaterial(broken_mat, "*");
	joint->getBody1()->getObject()->setMaterial(broken_mat, "*");
}

```

## JoysticksInput.cpp

```cpp
#include "JoysticksInput.h"

#include "../../utils/Math.h"
#include "../../utils/SimpleInformationBox.h"

#include <UnigineControls.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(JoysticksInput);

using namespace Unigine;
using namespace Math;

void JoysticksInput::init()
{
	Input::getEventJoyConnected().connect(event_connections, this,
		&JoysticksInput::on_joystick_connected);
	Input::getEventJoyDisconnected().connect(event_connections, this,
		&JoysticksInput::on_joystick_disconnected);

	for (int i = 0; i < Input::getNumJoysticks(); i++)
	{

		joysticks_info.append({Input::getJoystick(i), "",
			Unigine::VectorStack<FFBEffectData>(static_cast<int>(Input::NUM_JOYSTICK_FORCE_FEEDBACKS))});
	}

	info = getComponent<SimpleInformationBox>(node);

	info->setWindowTitle("Joystick Controls Sample");
	info->setWidth(300);
	info->pushBackAboutInfo("This sample demostrates the simple usage of multiple Joystick input.");
}

void JoysticksInput::create_ffb_ui(int info_column, Unigine::InputJoystickPtr &joystick)
{

	if (!is_ffb_supported(joystick))
		return;

	const auto ffb_container = WidgetGroupBox::create("Force Feedback Effects");
	const auto scroll = WidgetScrollBox::create();
	ffb_container->addChild(scroll);
	// scroll->setWidth(350);
	scroll->setHeight(400);
	scroll->setHScrollEnabled(false);
	scroll->setBorder(0);
	scroll->setPadding(10,10,10,10);
	scroll->setSpace(10,10);
	const auto container = info->getColumn(info_column);
	container->addChild(ffb_container, Gui::ALIGN_EXPAND);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_CONSTANT))
		create_ffb_effect_ui("Constant", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_CONSTANT,
			true, false, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_FRICTION))
		create_ffb_effect_ui("Friction", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_FRICTION,
			false, false, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_DAMPER))
		create_ffb_effect_ui("Damper", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_DAMPER,
			false, false, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_INERTIA))
		create_ffb_effect_ui("Inertia", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_INERTIA,
			false, false, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_RAMP))
		create_ffb_effect_ui("Ramp", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_RAMP, true,
			true, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_SPRING))
		create_ffb_effect_ui("Spring", joysticks_info[info_column], Input::JOYSTICK_FORCE_FEEDBACK_SPRING,
			false, false, false, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_SINEWAVE))
		create_ffb_effect_ui("Sine Wave", joysticks_info[info_column],
			Input::JOYSTICK_FORCE_FEEDBACK_SINEWAVE, false, false, true, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_SQUAREWAVE))
		create_ffb_effect_ui("Square Wave", joysticks_info[info_column],
			Input::JOYSTICK_FORCE_FEEDBACK_SQUAREWAVE, false, false, true, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_TRIANGLEWAVE))
		create_ffb_effect_ui("Triangle Wave", joysticks_info[info_column],
			Input::JOYSTICK_FORCE_FEEDBACK_TRIANGLEWAVE, false, false, true, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHUPWAVE))
		create_ffb_effect_ui("Saw Tooth Up", joysticks_info[info_column],
			Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHUPWAVE, false, false, true, scroll);

	if (joystick->isForceFeedbackEffectSupported(Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHDOWNWAVE))
		create_ffb_effect_ui("Saw Tooth Down", joysticks_info[info_column],
			Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHDOWNWAVE, false, false, true, scroll);
}
void JoysticksInput::update()
{
	int joysticks_count = 0;
	for (const auto &info : joysticks_info)
	{
		if (info.joystick && info.joystick->isAvailable())
		{
			++joysticks_count;
		}
	}

	if (info->getColumnsCount() != joysticks_count)
	{
		info->setColumnsCount(joysticks_count);
		for (int i = 0; i < joysticks_info.size(); i++)
		{
			if (!joysticks_info[i].joystick && joysticks_info[i].joystick->isAvailable())
				continue;

			auto &joystick = joysticks_info[i].joystick;

			auto filter = info->addSlider(i, "Filter", 0.01f, "Buttons sensitivity threshold");
			filter->setValue(joysticks_info[i].joystick->getFilter() * 100);
			filter->getEventChanged().connect(filter_connections, [this, filter, i]() {
				joysticks_info[i].joystick->setFilter(filter->getValue() * 0.01f);
			});

			create_ffb_ui(i, joystick);
		}
	}

	for (int i = 0, column_index = 0; i < joysticks_info.size(); i++)
	{
		if (!joysticks_info[i].joystick && joysticks_info[i].joystick->isAvailable())
			continue;

		// getting information about the joystick
		const auto &joystick = joysticks_info[i].joystick;

		String name = joystick->getName();
		int number = joystick->getNumber();

		int num_axes = joystick->getNumAxes();
		Vector<String> axis_names;
		Vector<float> axis_values;
		for (int j = 0; j < num_axes; j++)
		{
			axis_names.push_back(joystick->getAxisName(j));
			axis_values.push_back(joystick->getAxis(j));
		}

		int num_povs = joystick->getNumPovs();
		Vector<String> pov_names;
		Vector<Input::JOYSTICK_POV> pov_values;
		for (int j = 0; j < num_povs; j++)
		{
			pov_names.push_back(joystick->getPovName(j));
			pov_values.push_back(joystick->getPov(j));
		}

		int num_buttons = joystick->getNumButtons();
		for (int j = 0; j < num_buttons; j++)
			if (joystick->isButtonPressed(j) != 0)
				joysticks_info[i].last_pressed_button = joystick->getButtonName(j);

		// filling information about the joystick
		info->clearParametersInfo(column_index);

		info->pushBackParametersInfo(column_index, name.get(),
			SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackParametersInfo(column_index, "Number", String::itoa(number),
			SimpleInformationBox::INFO_ALIGN::LEFT);
		info->pushBackWhiteSpaceLineParametersInfo(column_index);

		info->pushBackParametersInfo(column_index, "Axes " + String::itoa(num_axes),
			SimpleInformationBox::INFO_ALIGN::CENTER);
		for (int j = 0; j < num_axes; j++)
			info->pushBackParametersInfo(column_index, axis_names[j], String::format("%.2f",axis_values[j]));
		info->pushBackWhiteSpaceLineParametersInfo(column_index);

		info->pushBackParametersInfo(column_index, "POVs " + String::itoa(num_povs),
			SimpleInformationBox::INFO_ALIGN::CENTER);
		for (int j = 0; j < num_povs; j++)
			info->pushBackParametersInfo(column_index, pov_names[j], String::itoa(pov_values[j]));
		info->pushBackWhiteSpaceLineParametersInfo(column_index);

		info->pushBackParametersInfo(column_index, "Buttons Count", String::itoa(num_buttons),
			SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(column_index);

		info->pushBackParametersInfo(column_index, "Last Pressed Button",
			joysticks_info[i].last_pressed_button);
		info->pushBackParametersInfo(column_index, "                   ",
			SimpleInformationBox::INFO_ALIGN::CENTER);
		info->pushBackWhiteSpaceLineParametersInfo(column_index);

		String ffb_status = is_ffb_supported(joystick) ? "Supported" : "Unsupported";
		info->pushBackParametersInfo(column_index, "FFB Status", ffb_status,
			SimpleInformationBox::INFO_ALIGN::LEFT);
		info->pushBackParametersInfo(column_index, "                   ",
			SimpleInformationBox::INFO_ALIGN::RIGHT);
		info->pushBackWhiteSpaceLineParametersInfo(column_index);


		++column_index;
	}

	for (auto& info : joysticks_info)
		info.ramp_effect_data.update();
}

void JoysticksInput::shutdown()
{
	filter_connections.disconnectAll();
	joysticks_info.clear();
}

void JoysticksInput::on_joystick_connected(int num)
{
	joysticks_info.push_back({Input::getJoystick(num), "",
		Unigine::VectorStack<FFBEffectData>(
			static_cast<int>(Input::NUM_JOYSTICK_FORCE_FEEDBACKS))});
}

void JoysticksInput::on_joystick_disconnected(int num)
{
	for (int i = 0; i < joysticks_info.size(); i++)
	{
		if (joysticks_info[i].joystick && joysticks_info[i].joystick->getNumber() == num)
		{
			joysticks_info.remove(i);
			break;
		}
	}
}
WidgetPtr JoysticksInput::create_ffb_effect_ui(const String &name, JoystickInfo &info,
	Input::JOYSTICK_FORCE_FEEDBACK_EFFECT effect_type, bool need_magnitude, bool need_duration,
	bool need_frequency, const WidgetPtr &parent)
{
	const auto play_button = WidgetButton::create("Play");

	const auto create_labeled_slider_float = [this](const String &name, const WidgetPtr &slider_parent,
												 float initial_value, float min, float max,
												 const std::function<void(float)> &on_change) {
		const auto name_label = WidgetLabel::create(name);
		name_label->setWidth(100);
		slider_parent->addChild(name_label);
		auto slider = WidgetSlider::create();
		slider_parent->addChild(slider);

		slider->setMinValue(0);
		slider->setMaxValue(1000);
		slider->setValue(ftoi(Utils::mapRange(initial_value, min, max, 0.f, 1000.f)));

		slider->setWidth(150);
		auto label = WidgetLabel::create(String::format("%.2f", initial_value));
		label->setWidth(40);
		slider_parent->addChild(label, Gui::ALIGN_RIGHT);
		on_change(initial_value);

		slider->getEventChanged().connect(ffb_connections, [slider, label, min, max, on_change] {
			const auto value = Utils::mapRange(float(slider->getValue()), 0.0f, 1000.0f, min, max);
			label->setText(String::format("%.2f", value));
			on_change(value);
		});
	};
	auto container = WidgetGroupBox::create(name);
	container->setSpace(5,5);
	parent->addChild(container);
	const auto grid = WidgetGridBox::create(3);
	container->addChild(grid);

	create_labeled_slider_float("Force", grid, 0.f, 0.f, 1.f,
		[effect_type, &info, play_button, this, need_duration](float value) {
			info.ffb_effect_data[effect_type].force = value;

			if (!info.joystick || !info.joystick->isAvailable())
				return;
			if (!info.joystick->isForceFeedbackEffectSupported(effect_type))
				return;

			if (!play_button->isToggled())
				return;

			if (need_duration)
			{
				info.ramp_effect_data.desired_time = info.ffb_effect_data[effect_type].duration
					/ 1000000.f;
				info.ramp_effect_data.current_time = 0;
			}
			play_ffb_effect(info.ffb_effect_data[effect_type], effect_type, info.joystick);
		});

	if (need_magnitude)
	{
		create_labeled_slider_float("Magnitude", grid, 0.f, -1.f, 1.f,
			[effect_type, &info, play_button, need_duration, this](float value) {
				info.ffb_effect_data[effect_type].magnitude = value;

				if (!info.joystick || !info.joystick->isAvailable())
					return;
				if (!info.joystick->isForceFeedbackEffectSupported(effect_type))
					return;

				if (!play_button->isToggled())
					return;

				if (need_duration)
				{
					info.ramp_effect_data.desired_time = info.ffb_effect_data[effect_type].duration
						/ 1000000.f;
					info.ramp_effect_data.current_time = 0;
				}
				play_ffb_effect(info.ffb_effect_data[effect_type], effect_type, info.joystick);
			});
	}

	if (need_duration)
	{
		create_labeled_slider_float("Duration", grid, 0.f, 0.f, 10.f,
			[effect_type, &info, play_button, need_duration](float value) {
				info.ffb_effect_data[effect_type].duration = static_cast<unsigned long long>(
					value * 1000000.f);

				if (!info.joystick || !info.joystick->isAvailable())
					return;
				if (!info.joystick->isForceFeedbackEffectSupported(effect_type))
					return;

				if (!play_button->isToggled())
					return;

				if (need_duration)
				{
					info.ramp_effect_data.desired_time = info.ffb_effect_data[effect_type].duration
						/ 1000000.f;
					info.ramp_effect_data.current_time = 0;
				}
				play_ffb_effect(info.ffb_effect_data[effect_type], effect_type, info.joystick);
			});
	}

	if (need_frequency)
	{
		create_labeled_slider_float("Frequency", grid, 0.f, 0.f, 10.f,
			[effect_type, &info, play_button](float value) {
				info.ffb_effect_data[effect_type].frequency = value;

				if (!info.joystick || !info.joystick->isAvailable())
					return;
				if (!info.joystick->isForceFeedbackEffectSupported(effect_type))
					return;

				if (!play_button->isToggled())
					return;

				play_ffb_effect(info.ffb_effect_data[effect_type], effect_type, info.joystick);
			});
	}

	container->addChild(play_button, Gui::ALIGN_EXPAND);

	play_button->setToggleable(true);
	play_button->getEventClicked().connect(ffb_connections,
		[this, &info, effect_type, play_button, need_duration] {
			if (!play_button->isToggled())
			{
				if (!info.joystick->isForceFeedbackEffectPlaying(effect_type))
				{
					Log::error("JoystickInput::create_ffb_effect_ui(): effect is not playing\n");
				}
				stop_ffb_effect(effect_type, info.joystick);
			}
			else
			{
				if (info.joystick->isForceFeedbackEffectPlaying(effect_type))
				{
					Log::error("JoystickInput::create_ffb_effect_ui(): effect is playing\n");
				}
				if (need_duration)
				{
					info.ramp_effect_data.button = play_button;
					info.ramp_effect_data.desired_time = info.ffb_effect_data[effect_type].duration
						/ 1000000.f;
					info.ramp_effect_data.current_time = 0;
				}
				play_ffb_effect(info.ffb_effect_data[effect_type], effect_type, info.joystick);
			}
		});

	return container;
}


void JoysticksInput::play_ffb_effect(const FFBEffectData &data,
	Input::JOYSTICK_FORCE_FEEDBACK_EFFECT effect_type, const InputJoystickPtr &joystick)
{
	if (!joystick || !joystick->isAvailable())
		return;

	switch (effect_type)
	{
	case Input::JOYSTICK_FORCE_FEEDBACK_CONSTANT:
	{
		joystick->playForceFeedbackEffectConstant(data.force);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_FRICTION:
	{
		joystick->playForceFeedbackEffectFriction(data.force);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_DAMPER:
	{
		joystick->playForceFeedbackEffectDamper(data.force);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_INERTIA:
	{
		joystick->playForceFeedbackEffectInertia(data.force);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_RAMP:
	{
		joystick->playForceFeedbackEffectRamp(data.force, data.duration);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_SPRING:
	{
		joystick->playForceFeedbackEffectSpring(data.force);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_SINEWAVE:
	{
		joystick->playForceFeedbackEffectSineWave(data.force, data.frequency);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_SQUAREWAVE:
	{
		joystick->playForceFeedbackEffectSquareWave(data.force, data.frequency);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_TRIANGLEWAVE:
	{
		joystick->playForceFeedbackEffectTriangleWave(data.force, data.frequency);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHDOWNWAVE:
	{
		joystick->playForceFeedbackEffectSawtoothDownWave(data.force, data.frequency);
		break;
	}
	case Input::JOYSTICK_FORCE_FEEDBACK_SAWTOOTHUPWAVE:
	{
		joystick->playForceFeedbackEffectSawtoothUpWave(data.force, data.frequency);
		break;
	}
	default:
	{
		return;
	}
	}
}

void JoysticksInput::stop_ffb_effect(Input::JOYSTICK_FORCE_FEEDBACK_EFFECT effect_type,
	const InputJoystickPtr &joystick)
{
	if (joystick->isForceFeedbackEffectSupported(effect_type)
		&& joystick->isForceFeedbackEffectPlaying(effect_type))
	{
		joystick->stopForceFeedbackEffect(effect_type);
	}
	else
	{
		Log::error("JoysticksInput::stop_ffb_effect: couldn't stop ffb effect");
	}
}

bool JoysticksInput::is_ffb_supported(const InputJoystickPtr &joystick)
{
	for (int i = 0; i < static_cast<int>(Input::NUM_JOYSTICK_FORCE_FEEDBACKS); ++i)
	{
		auto effect_type = static_cast<Input::JOYSTICK_FORCE_FEEDBACK_EFFECT>(i);
		if (joystick->isForceFeedbackEffectSupported(effect_type))
		{
			return true;
		}
	}
	return false;
}

void JoysticksInput::DurationEffectData::update()
{
	if (!button)
		return;

	if (current_time >= desired_time)
		return;

	current_time += Game::getIFps();
	if (current_time >= desired_time)
	{
		button->setToggled(false);
	}
}

```

## JsonSample.cpp

```cpp
#include "JsonSample.h"

#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;


// here is an example of how to create JSON file
JsonPtr JsonSample::json_create()
{
	JsonPtr json = Json::create("node");
	JsonPtr json_1 = json->addChild();
	json_1->setObject();
	json_1->setName("object");
	json_1->addChild("child", "hello from json");
	JsonPtr array = json->addChild("array");
	array->setArray();
	JsonPtr array_1 = array->addChild("array_child_0");
	array_1->setObject();
	array_1->addChild("object_child_number", 12);

	JsonPtr array_2 = array->addChild("array_child_1");
	array_2->addChild("object_child_string", "some string");
	JsonPtr array_3 = array->addChild("array_child_2");
	JsonPtr bool_child = array_3->addChild("object_child_bool");
	bool_child->setBool(true);
	JsonPtr array_4 = array->addChild("array_child_3");
	JsonPtr null_child = array_4->addChild("object_child_null", false);
	null_child->setNull();

	json->setAPIInterfaceOwner(false);
	return json;
}

void JsonSample::json_print(const JsonPtr &json)
{
	json_print_node(json, 0);
}


// here is an example of how you can access JSON data
void JsonSample::json_print_node(const JsonPtr &json, int offset, int index, bool print_name)
{
	bool is_comma_needed = false;
	JsonPtr parent = json->getParent();
	if (parent)
	{
		is_comma_needed = parent->getNumChildren() != index;
	}

	if (json->isObject())
	{
		if (print_name)
		{
			print_string_offset(String::format("%s: {", json->getName()).get(), offset);
		}
		else
		{
			print_string_offset("{", offset);
		}
		const int num_children = json->getNumChildren();
		for (int i = 0; i < num_children; i++)
		{
			json_print_node(json->getChild(i), offset + 1, i + 1);
		}
		print_string_offset("}", offset, is_comma_needed);
	}

	if (json->isArray())
	{
		if (print_name)
		{
			print_string_offset(String::format("%s: [", json->getName()).get(), offset);
		}
		else
		{
			print_string_offset("[", offset);
		}
		const int num_children = json->getNumChildren();
		for (int i = 0; i < num_children; i++)
		{
			JsonPtr child = json->getChild(i);
			json_print_node(child, offset + 1, i + 1, false);
		}
		print_string_offset("]", offset, is_comma_needed);
	}

	if (json->isNumber())
	{
		if (print_name)
		{
			print_string_offset(
				String::format("%s: %.2f", json->getName(), json->getNumber()).get(), offset,
				is_comma_needed);
		}
		else
		{
			print_string_offset(String::format("%.2f", json->getNumber()).get(), is_comma_needed);
		}
	}
	if (json->isString())
	{
		if (print_name)
		{
			print_string_offset(
				String::format("%s: \"%s\"", json->getName(), json->getString().get()).get(),
				offset, is_comma_needed);
		}
		else
		{
			print_string_offset(String::format("\"%s\"", json->getString().get()).get(), offset,
				is_comma_needed);
		}
	}
	if (json->isBool())
	{
		String value = json->getBool() ? "true" : "false";
		if (print_name)
		{
			print_string_offset(String::format("%s: %s", json->getName(), value.get()).get(),
				offset, is_comma_needed);
		}
		else
		{
			print_string_offset(String::format("%s", value.get()).get(), offset, is_comma_needed);
		}
	}
	if (json->isNull())
	{
		if (print_name)
		{
			print_string_offset(String::format("%s: null", json->getName()).get(), offset,
				is_comma_needed);
		}
		else
		{
			print_string_offset("null", offset, is_comma_needed);
		}
	}
}

void JsonSample::print_string_offset(const Unigine::String &value, int offset, bool print_comma)
{
	for (int i = 0; i < offset; ++i)
	{
		Log::message("\t");
	}
	Log::message("%s", value.get());
	if (print_comma)
	{
		Log::message(",");
	}
	Log::message("\n");
}

//------------------------Sample Logic-----------------------

REGISTER_COMPONENT(JsonSample)

void JsonSample::init()
{
	is_console_onscreen = Console::isOnscreen();
	Console::setOnscreen(true);

	{
		// create the JSON
		const JsonPtr json = json_create();

		// print JSON tree
		json_print(json);
	}
}

void JsonSample::shutdown()
{
	Console::setOnscreen(is_console_onscreen);
}

```

## KeyboardAndMouseInput.cpp

```cpp
#include "KeyboardAndMouseInput.h"
#include "../../utils/SimpleInformationBox.h"
#include <UnigineWidgets.h>

REGISTER_COMPONENT(KeyboardAndMouseInput);

using namespace Unigine;
using namespace Math;

void KeyboardAndMouseInput::init()
{
	info = getComponent<SimpleInformationBox>(node);

	info->setWindowTitle("Keyboar and Mouse Input Sample");
	info->setColumnsCount(1);
	info->setWidth(300);
	info->pushBackAboutInfo("This sample demostrates the simple usage of Keyboard and Mouse input.");
	auto combobox = info->addCombobox(0, "Change Mouse Handle ");
	combobox->getEventChanged().connect(widget_connections, [combobox]() {
		Input::setMouseHandle((Input::MOUSE_HANDLE)combobox->getCurrentItem());
		});
	combobox->addItem("GRAB");
	combobox->addItem("SOFT");
	combobox->addItem("USER");

	Input::getEventTextPress().connect(widget_connections, this, &KeyboardAndMouseInput::on_text_pressed);
}

void KeyboardAndMouseInput::update()
{
	info->clearParametersInfo(0);

	// reset keys info
	check_last_mouse_button();
	info->pushBackParametersInfo(0, "Last Mouse Button Down", last_mouse_button_down);
	info->pushBackParametersInfo(0, "Last Mouse Button Pressed", last_mouse_button_pressed);
	info->pushBackParametersInfo(0, "Last Mouse Button Up", last_mouse_button_up);
	info->pushBackWhiteSpaceLineParametersInfo(0);

	check_last_key();
	info->pushBackParametersInfo(0, "Last Input Symbol", last_input_symbol);
	info->pushBackParametersInfo(0, "Last Down Key Code", last_key_down);
	info->pushBackParametersInfo(0, "Last Pressed Key Code", last_key_pressed);
	info->pushBackParametersInfo(0, "Last Up Key Code", last_key_up);
	info->pushBackWhiteSpaceLineParametersInfo(0);

	// reset window position coordinates
	info->pushBackParametersInfo(0, "Window Position X", String::itoa(WindowManager::getMainWindow()->getPosition().x));
	info->pushBackParametersInfo(0, "Window Position Y", String::itoa(WindowManager::getMainWindow()->getPosition().y));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	// reset mouse position coordinates in screen space
	info->pushBackParametersInfo(0, "Screen Space Mouse Position X", String::itoa(Input::getMousePosition().x));
	info->pushBackParametersInfo(0, "Screen Space Mouse Position Y", String::itoa(Input::getMousePosition().y));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	// reset mouse position coordinates in window space
	info->pushBackParametersInfo(0, "Window Space Mouse Position X", String::itoa(Gui::getCurrent()->getMouseX()));
	info->pushBackParametersInfo(0, "Window Space Mouse Position Y", String::itoa(Gui::getCurrent()->getMouseY()));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	// reset mouse deltas
	if (Input::getMouseDeltaPosition().length2() > 0)
		last_mouse_delta_coordinates = Input::getMouseDeltaPosition();

	info->pushBackParametersInfo(0, "Last Mouse Coordinates Delta X", String::itoa(last_mouse_delta_coordinates.x));
	info->pushBackParametersInfo(0, "Last Mouse Coordinates Delta Y", String::itoa(last_mouse_delta_coordinates.y));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	if (Input::getMouseDeltaRaw().length2() > 0)
		last_mouse_delta = vec2(Input::getMouseDeltaRaw());

	info->pushBackParametersInfo(0, "Last Mouse Delta X", String::ftoa(last_mouse_delta.x));
	info->pushBackParametersInfo(0, "Last Mouse Delta Y", String::ftoa(last_mouse_delta.y));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	// reset mouse axes direction
	if (Input::getMouseWheel() != 0)
		last_mouse_wheel = Input::getMouseWheel();

	if (Input::getMouseWheelHorizontal() != 0)
		last_mouse_wheel_horizontal = Input::getMouseWheelHorizontal();

	info->pushBackParametersInfo(0, "Last Mouse Wheel", String::itoa(last_mouse_wheel));
	info->pushBackParametersInfo(0, "Last Mouse Wheel Horizontal", String::itoa(last_mouse_wheel_horizontal));
	info->pushBackWhiteSpaceLineParametersInfo(0);

	if (Input::getMouseHandle() == Input::MOUSE_HANDLE_GRAB)
	{
		if(Input::isMouseGrab())
			info->pushBackParametersInfo(0, "Mouse Handle: GRAB (press ESC to show cursor)");
		else
			info->pushBackParametersInfo(0, "Mouse Handle: GRAB");
	}
	if (Input::getMouseHandle() == Input::MOUSE_HANDLE_SOFT)
		info->pushBackParametersInfo(0, "Mouse Handle: SOFT");
	if (Input::getMouseHandle() == Input::MOUSE_HANDLE_USER)
		info->pushBackParametersInfo(0, "Mouse Handle: USER");
}

void KeyboardAndMouseInput::shutdown()
{
	widget_connections.disconnectAll();
}

void KeyboardAndMouseInput::check_last_mouse_button()
{
	for (int i = 0; i < Input::MOUSE_NUM_BUTTONS; i++)
	{
		if (Input::isMouseButtonDown((Input::MOUSE_BUTTON)i))
			last_mouse_button_down = Input::getMouseButtonName((Input::MOUSE_BUTTON)i);

		if (Input::isMouseButtonPressed((Input::MOUSE_BUTTON)i) && !pressed_mouse_buttons.contains(i))
		{
			pressed_mouse_buttons.append(i);
			last_mouse_button_pressed = Input::getMouseButtonName((Input::MOUSE_BUTTON)i);
		}

		if (Input::isMouseButtonUp((Input::MOUSE_BUTTON)i))
		{
			pressed_mouse_buttons.remove(i);
			last_mouse_button_up = Input::getMouseButtonName((Input::MOUSE_BUTTON)i);
		}
	}
}

void KeyboardAndMouseInput::check_last_key()
{
	for (unsigned int i = 0; i < Input::KEY_ANY_SHIFT; i++)
	{
		if (Input::isKeyDown((Input::KEY)i))
			last_key_down = Input::getKeyName((Input::KEY)i);

		if (Input::isKeyPressed((Input::KEY)i) && !pressed_keys.contains(i))
		{
			pressed_keys.append(i);
			last_key_pressed = Input::getKeyName((Input::KEY)i);
		}

		if (Input::isKeyUp((Input::KEY)i))
		{
			pressed_keys.remove(i);
			last_key_up = Input::getKeyName((Input::KEY)i);
		}
	}
}

void KeyboardAndMouseInput::on_text_pressed(unsigned int unicode)
{
	last_input_symbol = String::unicodeToUtf8(unicode);
}

```

## Label.cpp

```cpp
#include "Label.h"

REGISTER_COMPONENT(Label);

using namespace Unigine;
using namespace Math;

void Label::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_label = WidgetLabel::create(gui, text.get());

	gui->addChild(widget_label, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_label->setPosition(position.get().x, position.get().y);
	widget_label->setFontSize(font_size.get());
}

void Label::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_label);

		widget_label.deleteLater();
	}
}

```

## LandscapeAlbedoPainter.cpp

```cpp
#include "LandscapeAlbedoPainter.h"

#include <UnigineMaterials.h>

REGISTER_COMPONENT(LandscapeAlbedoPainter)

using namespace Unigine;
using namespace Math;

void LandscapeAlbedoPainter::enable()
{
	if (callback_handle.isValid())
		return;

	Landscape::getEventTextureDraw().connect(callback_handle, this, &LandscapeAlbedoPainter::texture_draw_callback);
}

void LandscapeAlbedoPainter::disable()
{
	if (!callback_handle.isValid())
		return;

	callback_handle.disconnect();
}

void LandscapeAlbedoPainter::paintAt(const Unigine::Math::Vec3 &world_position)
{
	auto distance = (world_position - last_paint_position).length();
	if (distance < brush_spacing * brush_size)
		return;
	last_paint_position = world_position;


	Vec3 brush_local_position = landscape_layer_map->getIWorldTransform() * world_position;
	quat brush_world_rotation = quat(vec3_up, brush_angle);
	quat brush_local_rotation = brush_world_rotation * inverse(landscape_layer_map->getWorldRotation());

	float half_size = brush_size / 2.0f;
	Vec3 brush_local_corners[4] = {
		brush_local_position + brush_local_rotation * Vec3(-half_size, -half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3( half_size, -half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3(-half_size,  half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3( half_size,  half_size, 0.0)
	};
	auto brush_local_bbox_min = Vec2{
		min(min(brush_local_corners[0].x, brush_local_corners[1].x), min(brush_local_corners[2].x, brush_local_corners[3].x)),
		min(min(brush_local_corners[0].y, brush_local_corners[1].y), min(brush_local_corners[2].y, brush_local_corners[3].y))
	};
	auto brush_local_bbox_max = Vec2{
		max(max(brush_local_corners[0].x, brush_local_corners[1].x), max(brush_local_corners[2].x, brush_local_corners[3].x)),
		max(max(brush_local_corners[0].y, brush_local_corners[1].y), max(brush_local_corners[2].y, brush_local_corners[3].y))
	};


	auto pixels_per_unit = Vec2{ landscape_layer_map->getResolution() } / Vec2{ landscape_layer_map->getSize() };
	auto drawing_region_coord = ivec2{ pixels_per_unit * brush_local_bbox_min };
	auto drawing_region_resolution = ivec2{ pixels_per_unit * (brush_local_bbox_max - brush_local_bbox_min) };
	auto local_brush_angle = brush_local_rotation.getAngle(vec3_up);


	auto id = Landscape::generateOperationID();
	per_operation_draw_data.insert(id, DrawData{
		brush_texture,
		brush_mask,
		local_brush_angle,
		brush_opacity,
		brush_color.xyz
	});

	Landscape::asyncTextureDraw(id, landscape_layer_map->getGUID(), drawing_region_coord,
		drawing_region_resolution, Landscape::FLAGS_DATA_ALBEDO);
}

void LandscapeAlbedoPainter::init()
{
	auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath("landscape_albedo_brush.basemat"));
	if (!guid.isValid())
	{
		Log::warning("LandscapeAlbedoPainter::init(): can not find \"landscape_albedo_brush.basemat\" material\n");
		return;
	}

	brush_material = Materials::findMaterialByFileGUID(guid)->inherit();
}

void LandscapeAlbedoPainter::texture_draw_callback(const Unigine::UGUID &guid, int id, const Unigine::LandscapeTexturesPtr &buffer, const Unigine::Math::ivec2 &coord, int data_mask)
{
	auto it = per_operation_draw_data.find(id);
	if (it == per_operation_draw_data.end())
		return;

	auto render_target = Render::getTemporaryRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	render_target->bindUnorderedAccessTexture(0, buffer->getAlbedo());
	render_target->enable();
	{
		brush_material->setTexture("brush_texture", it->data.brush_texture);
		brush_material->setTexture("brush_mask", it->data.brush_mask);
		brush_material->setParameterFloat("brush_angle", it->data.brush_angle);
		brush_material->setParameterFloat("brush_opacity", it->data.brush_opacity);
		brush_material->setParameterFloat3("brush_color", it->data.brush_color);

		brush_material->renderScreen("landscape_albedo_brush");

	}
	render_target->disable();
	render_target->unbindUnorderedAccessTexture(0);

	RenderState::restoreState();

	Render::releaseTemporaryRenderTarget(render_target);

	per_operation_draw_data.erase(it);
}

```

## LandscapeHeightPainter.cpp

```cpp
#include "LandscapeHeightPainter.h"

#include <UnigineMaterials.h>

REGISTER_COMPONENT(LandscapeHeightPainter);

using namespace Unigine;
using namespace Math;

void LandscapeHeightPainter::enable()
{
	if (callback_handle.isValid())
		return;

	Landscape::getEventTextureDraw().connect(callback_handle, this, &LandscapeHeightPainter::texture_draw_callback);
}

void LandscapeHeightPainter::disable()
{
	if (!callback_handle.isValid())
		return;

	callback_handle.disconnect();
}

void LandscapeHeightPainter::paintAt(const Unigine::Math::Vec3 & world_position)
{
	auto distance = (world_position - last_paint_position).length();
	if (distance < brush_spacing * brush_size)
		return;
	last_paint_position = world_position;


	Vec3 brush_local_position = landscape_layer_map->getIWorldTransform() * world_position;
	quat brush_world_rotation = quat(vec3_up, brush_angle);
	quat brush_local_rotation = brush_world_rotation * inverse(landscape_layer_map->getWorldRotation());

	float half_size = brush_size / 2.0f;
	Vec3 brush_local_corners[4] = {
		brush_local_position + brush_local_rotation * Vec3(-half_size, -half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3( half_size, -half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3(-half_size,  half_size, 0.0),
		brush_local_position + brush_local_rotation * Vec3( half_size,  half_size, 0.0)
	};
	auto brush_local_bbox_min = Vec2{
		min(min(brush_local_corners[0].x, brush_local_corners[1].x), min(brush_local_corners[2].x, brush_local_corners[3].x)),
		min(min(brush_local_corners[0].y, brush_local_corners[1].y), min(brush_local_corners[2].y, brush_local_corners[3].y))
	};
	auto brush_local_bbox_max = Vec2{
		max(max(brush_local_corners[0].x, brush_local_corners[1].x), max(brush_local_corners[2].x, brush_local_corners[3].x)),
		max(max(brush_local_corners[0].y, brush_local_corners[1].y), max(brush_local_corners[2].y, brush_local_corners[3].y))
	};


	auto pixels_per_unit = Vec2{ landscape_layer_map->getResolution() } / Vec2{ landscape_layer_map->getSize() };
	auto drawing_region_coord = ivec2{ pixels_per_unit * brush_local_bbox_min };
	auto drawing_region_resolution = ivec2{ pixels_per_unit * (brush_local_bbox_max - brush_local_bbox_min) };
	auto local_brush_angle = brush_local_rotation.getAngle(vec3_up);


	auto id = Landscape::generateOperationID();
	per_operation_draw_data.insert(id, DrawData{
		blend_mode,
		brush_texture,
		brush_mask,
		local_brush_angle,
		brush_opacity,
		brush_height,
		brush_height_scale
	});
	Landscape::asyncTextureDraw(id, landscape_layer_map->getGUID(), drawing_region_coord,
		drawing_region_resolution, Landscape::FLAGS_DATA_HEIGHT);
}

void LandscapeHeightPainter::init()
{
	auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath("landscape_height_brush.basemat"));
	if (!guid.isValid())
	{
		Log::warning("LandscapeHeightPainter::init(): can not find \"landscape_height_brush.basemat\" material\n");
		return;
	}

	brush_material = Materials::findMaterialByFileGUID(guid)->inherit();
}

void LandscapeHeightPainter::texture_draw_callback(const UGUID &guid, int id, const LandscapeTexturesPtr &buffer, const ivec2 &coord, int data_mask)
{
	auto it = per_operation_draw_data.find(id);
	if (it == per_operation_draw_data.end())
		return;

	auto render_target = Render::getTemporaryRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	render_target->bindUnorderedAccessTexture(0, buffer->getHeight());
	render_target->enable();
	{
		brush_material->setState("blend_mode", static_cast<int>(it->data.blend_mode));
		brush_material->setTexture("brush_texture", it->data.brush_texture);
		brush_material->setTexture("brush_mask", it->data.brush_mask);
		brush_material->setParameterFloat("brush_angle", it->data.brush_angle);
		brush_material->setParameterFloat("brush_opacity", it->data.brush_opacity);
		brush_material->setParameterFloat("brush_height", it->data.brush_height);
		brush_material->setParameterFloat("brush_height_scale", it->data.brush_height_scale);

		brush_material->renderScreen("landscape_height_brush");

	}
	render_target->disable();
	render_target->unbindUnorderedAccessTexture(0);

	RenderState::restoreState();

	Render::releaseTemporaryRenderTarget(render_target);

	per_operation_draw_data.erase(it);
}

```

## LandscapeHeightToAlbedo.cpp

```cpp
#include "LandscapeHeightToAlbedo.h"

#include <UnigineMaterials.h>

REGISTER_COMPONENT(LandscapeHeightToAlbedo);

using namespace Unigine;
using namespace Math;

void LandscapeHeightToAlbedo::enable()
{
	if (callback_handle.isValid())
		return;

	Landscape::getEventTextureDraw().connect(callback_handle, this, &LandscapeHeightToAlbedo::texture_draw_callback);
}

void LandscapeHeightToAlbedo::disable()
{
	if (!callback_handle.isValid())
		return;

	callback_handle.disconnect();
}

void LandscapeHeightToAlbedo::run()
{
	auto id = Landscape::generateOperationID();
	per_operation_draw_data.insert(id, DrawData{
		gradient,
		min_height,
		max_height
	});
	Landscape::asyncTextureDraw(id, landscape_layer_map->getGUID(), { 0, 0 },
		landscape_layer_map->getResolution(), Landscape::FLAGS_DATA_ALBEDO | Landscape::FLAGS_DATA_HEIGHT);
}

void LandscapeHeightToAlbedo::init()
{
	auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath("landscape_height_to_albedo.basemat"));
	if (!guid.isValid())
	{
		Log::warning("LandscapeHeightToAlbedo::init(): can not find \"landscape_height_to_albedo.basemat\" material\n");
		return;
	}

	material = Materials::findMaterialByFileGUID(guid)->inherit();
}

void LandscapeHeightToAlbedo::texture_draw_callback(const Unigine::UGUID &guid, int id, const Unigine::LandscapeTexturesPtr &buffer, const Unigine::Math::ivec2 &coord, int data_mask)
{
	auto it = per_operation_draw_data.find(id);
	if (it == per_operation_draw_data.end())
		return;

	auto render_target = Render::getTemporaryRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	render_target->bindColorTexture(0, buffer->getAlbedo());
	render_target->enable();
	{

		material->setTexture("height", buffer->getHeight());
		material->setTexture("gradient", it->data.gradient);
		material->setParameterFloat("min_height", it->data.min_height);
		material->setParameterFloat("max_height", it->data.max_height);

		material->renderScreen("landscape_height_to_albedo");

	}
	render_target->disable();
	render_target->unbindColorTexture(0);

	RenderState::restoreState();

	Render::releaseTemporaryRenderTarget(render_target);

	per_operation_draw_data.erase(it);
}

```

## LandscapeMaskPainter.cpp

```cpp
#include "LandscapeMaskPainter.h"

#include <UnigineMaterials.h>

REGISTER_COMPONENT(LandscapeMaskPainter);

using namespace Unigine;
using namespace Math;

void LandscapeMaskPainter::enable()
{
	if (callback_handle.isValid())
	{
		return;
	}

	Landscape::getEventTextureDraw().connect(callback_handle, this,
		&LandscapeMaskPainter::texture_draw_callback);
}

void LandscapeMaskPainter::disable()
{
	if (!callback_handle.isValid())
	{
		return;
	}

	callback_handle.disconnect();
}

void LandscapeMaskPainter::paintAt(const Unigine::Math::Vec3 &world_position)
{
	auto distance = (world_position - last_paint_position).length();
	if (distance < brush_spacing * brush_size)
	{
		return;
	}

	last_paint_position = world_position;

	Vec3 brush_local_position = landscape_layer_map->getIWorldTransform() * world_position;
	quat brush_world_rotation = quat(vec3_up, brush_angle);
	quat brush_local_rotation = brush_world_rotation
		* inverse(landscape_layer_map->getWorldRotation());
	float half_size = brush_size / 2.0f;
	Vec3 brush_local_corners[4]
		= {brush_local_position + brush_local_rotation * Vec3(-half_size, -half_size, 0.0),
			brush_local_position + brush_local_rotation * Vec3(half_size, -half_size, 0.0),
			brush_local_position + brush_local_rotation * Vec3(-half_size, half_size, 0.0),
			brush_local_position + brush_local_rotation * Vec3(half_size, half_size, 0.0)};
	auto brush_local_bbox_min = Vec2{min(min(brush_local_corners[0].x, brush_local_corners[1].x),
										 min(brush_local_corners[2].x, brush_local_corners[3].x)),
		min(min(brush_local_corners[0].y, brush_local_corners[1].y),
			min(brush_local_corners[2].y, brush_local_corners[3].y))};
	auto brush_local_bbox_max = Vec2{max(max(brush_local_corners[0].x, brush_local_corners[1].x),
										 max(brush_local_corners[2].x, brush_local_corners[3].x)),
		max(max(brush_local_corners[0].y, brush_local_corners[1].y),
			max(brush_local_corners[2].y, brush_local_corners[3].y))};

	auto pixels_per_unit = Vec2{landscape_layer_map->getResolution()}
		/ Vec2{landscape_layer_map->getSize()};
	auto drawing_region_coord = ivec2{pixels_per_unit * brush_local_bbox_min};
	auto drawing_region_resolution = ivec2{
		pixels_per_unit * (brush_local_bbox_max - brush_local_bbox_min)};
	auto local_brush_angle = brush_local_rotation.getAngle(vec3_up);

	auto id = Landscape::generateOperationID();
	per_operation_draw_data.insert(id,
		DrawData{brush_texture, brush_mask, local_brush_angle, brush_opacity, brush_color});

	Landscape::asyncTextureDraw(id, landscape_layer_map->getGUID(), drawing_region_coord,
		drawing_region_resolution,
		static_cast<int>(Landscape::FLAGS_DATA_MASK_0)
			| static_cast<int>(Landscape::FLAGS_FILE_DATA_OPACITY_MASK_0));
}

void LandscapeMaskPainter::init()
{
	auto guid = FileSystem::getGUID(
		FileSystem::resolvePartialVirtualPath("landscape_mask_brush.basemat"));
	if (!guid.isValid())
	{
		Log::error(
			"LandscapePainter::init(): can not find \"landscape_mask_brush.basemat\" material");
		return;
	}
	brush_material = Materials::findMaterialByFileGUID(guid)->inherit();

	if (!clutter_param.get())
	{
		Log::error("LandscapePainter::init(): attached node is not clutter");
		return;
	}

	clutter = checked_ptr_cast<ObjectMeshClutter>(clutter_param.get());
}

void LandscapeMaskPainter::texture_draw_callback(const Unigine::UGUID &guid, int id,
	const Unigine::LandscapeTexturesPtr &buffer, const Unigine::Math::ivec2 &coord, int data_mask)
{
	auto it = per_operation_draw_data.find(id);
	if (it == per_operation_draw_data.end())
	{
		return;
	}

	auto render_target = Render::getTemporaryRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	render_target->bindUnorderedAccessTexture(0, buffer->getMask(0));
	render_target->bindUnorderedAccessTexture(1, buffer->getOpacityMask(0));
	render_target->enable();
	{
		brush_material->setTexture("brush_texture", it->data.brush_texture);
		brush_material->setTexture("brush_mask", it->data.brush_mask);
		brush_material->setParameterFloat("brush_angle", it->data.brush_angle);
		brush_material->setParameterFloat("brush_opacity", it->data.brush_opacity);
		brush_material->setParameterFloat4("brush_color", it->data.brush_color);

		brush_material->renderScreen("landscape_mask_brush");
	}
	render_target->disable();
	render_target->unbindUnorderedAccessTexture(0);
	render_target->unbindUnorderedAccessTexture(1);

	RenderState::restoreState();

	Render::releaseTemporaryRenderTarget(render_target);
	per_operation_draw_data.erase(it);
	if (clutter_param.get())
	{
		clutter->invalidate();
	}
}

```

## Las.cpp

```cpp
#include "Las.h"

#include <UnigineFileSystem.h>
#include <UnigineMathLib.h>

using namespace Unigine;
using namespace Math;

namespace
{
	void fill(void *dst, size_t dst_size, uint8_t value)
	{
		memset(dst, value, dst_size);
	}

	void zero(void *dst, size_t dst_size)
	{
		fill(dst, dst_size, 0);
	}

	void store(void *dst, size_t dst_size, void const *src, size_t src_size)
	{
		#ifdef _WIN32
			memcpy_s(dst, dst_size, src, src_size);
		#else
			if (dst && src && src_size <= dst_size)
			{
				memcpy(dst, src, src_size);
			}
		#endif
	}

	void store(char *dst, size_t dst_size, char const *src)
	{
		#ifdef _WIN32
			strcpy_s(dst, dst_size, src);
		#else
			if (dst && src)
			{
				size_t src_size = strlen(src) + 1;
				src_size = src_size < dst_size ? src_size : dst_size;
				memcpy(dst, src, src_size);
			}
		#endif
	}

	template<typename T, std::enable_if_t<std::is_fundamental<T>::value, bool> = true>
	void store(void *dst, T value)
	{
		store(dst, sizeof(T), &value, sizeof(T));
	}

	template<typename T, std::enable_if_t<std::is_fundamental<T>::value, bool> = true>
	T load(void const *src)
	{
		T result;
		store(&result, sizeof(T), src, sizeof(T));
		return result;
	}

	template<typename T, std::enable_if_t<std::is_fundamental<T>::value, bool> = true>
	void store_bits(void *dst, T bits, int offset, int length)
	{
		T value = load<T>(dst);
		T mask = ((T(1) << T(length)) - T(1)) << T(offset);
		T result = (value & (~mask)) | ((bits << T(offset)) & mask);
		store<T>(dst, result);
	}

	template<typename T, std::enable_if_t<std::is_fundamental<T>::value, bool> = true>
	T load_bits(void const *src, int offset, int length)
	{
		T value = load<T>(src);
		T mask = (T(1) << T(length)) - T(1);
		T result = (value >> T(offset)) & mask;
		return result;
	}
}

namespace Las
{

void LasWriter_v1_4::init()
{
	::zero(&header, sizeof(header));

	::store(header.file_signature, sizeof(header.file_signature), "LASF", 4);

	// header.file_source_id
	// header.global_encoding
	// header.project_id_guid_data_1
	// header.project_id_guid_data_2
	// header.project_id_guid_data_3
	// header.project_id_guid_data_4

	::store(&header.version_major, U8(1));
	::store(&header.version_minor, U8(4));
	::store(header.system_identifier, sizeof(header.system_identifier), "unigine");
	::store(header.generating_software, sizeof(header.generating_software), "cpp_samples/complex/lidar");

	// header.file_creation_day_of_year
	// header.file_creation_year

	::store(&header.header_size, U16(sizeof(header)));
	::store(&header.offset_to_point_data, U32(header.header_size));
	::store(&header.number_of_variable_length_records, U32(0));
	::store(&header.point_data_record_format, U8(0));
	::store(&header.point_data_record_length, U16(sizeof(LasPointDataRecordFormat0_v1_4)));

	// header.legacy_number_of_point_records
	// header.legacy_number_of_point_by_return

	{
		scale = vec3(0.001f);
		iscale = vec3(Math::rcp(scale.x), Math::rcp(scale.y), Math::rcp(scale.z));

		::store(&header.x_scale_factor, F64(scale.x));
		::store(&header.y_scale_factor, F64(scale.y));
		::store(&header.z_scale_factor, F64(scale.z));
	}

	::store(&header.x_offset, F64(0.));
	::store(&header.y_offset, F64(0.));
	::store(&header.z_offset, F64(0.));

	::store(&header.max_x, F64(0.));
	::store(&header.max_y, F64(0.));
	::store(&header.max_z, F64(0.));
	::store(&header.min_x, F64(0.));
	::store(&header.min_y, F64(0.));
	::store(&header.min_z, F64(0.));

	// header.start_of_waveform_data_packet_record
	// header.start_of_first_extended_variable_length_record
	// header.number_of_extended_variable_length_records
	// header.number_of_point_records
	// header.number_of_points_by_return
}

void LasWriter_v1_4::add_point(Unigine::Math::vec3 const& position, float intensity)
{
	auto& record = points.append();

	{
		::zero(&record, sizeof(record));

		::store(&record.x, S32(position.x * iscale.x));
		::store(&record.y, S32(position.y * iscale.y));
		::store(&record.z, S32(position.z * iscale.z));

		{
			using intensity_t = decltype(record.intensity);
			float constexpr max_intensity = static_cast<float>(std::numeric_limits<intensity_t>::max());
			intensity_t converted_intensity = intensity_t(Math::saturate(intensity) * max_intensity);
			::store(&record.intensity, intensity_t(converted_intensity));
		}

		{
			U8 return_number = 1;
			::store_bits(&record.flags, return_number, 0, 3);
		}
		{
			U8 number_of_returns = 1;
			::store_bits(&record.flags, number_of_returns, 3, 3);
		}
		{
			U8 scan_direction_flag = 0;
			::store_bits(&record.flags, scan_direction_flag, 6, 1);
		}
		{
			U8 edge_of_flight_line = 0;
			::store_bits(&record.flags, edge_of_flight_line, 7, 1);
		}

		::store(&record.classification, U8(0));
		::store(&record.scan_angle_rank, S8(0));
		::store(&record.user_data, U8(0));
		::store(&record.point_source_id, U16(0));
	}

	{
		bbox.expand(position);
	}
}

void LasWriter_v1_4::save(Unigine::StringStack<> const& path)
{
	{
		::store(&header.max_x, F64(bbox.maximum.x));
		::store(&header.max_y, F64(bbox.maximum.y));
		::store(&header.max_z, F64(bbox.maximum.z));
		::store(&header.min_x, F64(bbox.minimum.x));
		::store(&header.min_y, F64(bbox.minimum.y));
		::store(&header.min_z, F64(bbox.minimum.z));

		::store(&header.number_of_point_records, U64(points.size()));
		::store(&header.number_of_points_by_return[0], U64(points.size()));
	}

	{
		FilePtr file = File::create();

		file->open(path , "wb+");
		file->write(&header, sizeof(header));

		for (auto const& point : points)
		{
			file->write(&point, sizeof(point));
		}

		file->close();
	}
}

}

```

## Laser.cpp

```cpp
#include "Laser.h"

#include <UnigineGame.h>
#include <UnigineObjects.h>

REGISTER_COMPONENT(Laser);

using namespace Unigine;
using namespace Math;

void Laser::update()
{
	// convert mouse coordinates to direction from the camera
	PlayerPtr player = Game::getPlayer();
	ivec2 mouse_coord = Input::getMousePosition();
	Vec3 mouse_dir = Vec3(player->getDirectionFromMainWindow(mouse_coord.x, mouse_coord.y));

	// find intersection point at mouse position
	Vec3 cam_pos = player->getWorldPosition();
	if (World::getIntersection(cam_pos, cam_pos + mouse_dir * player->getZFar(), ~0, intersection))
	{
		Vec3 point = intersection->getPoint();
		point.z = node->getWorldPosition().z;
		node->setWorldPosition(point);
	}
}

```

## Lidar.cpp

```cpp
#include "Lidar.h"

#include <UnigineGame.h>
#include <UnigineConsole.h>
#include <UnigineProfiler.h>
#include <UnigineVisualizer.h>

#include "Las.h"

REGISTER_COMPONENT(Lidar)

using namespace Unigine;
using namespace Math;

void Lidar::init()
{
	// setup the perspective projection frustum that is used when rendering each view
	{
		frustum.near = Math::min(0.1f, distance_range.get().x);
		frustum.far = distance_range.get().y;
		frustum.left = frustum.near * Math::tan(-Consts::PI / float(num_views));
		frustum.right = frustum.near * Math::tan(Consts::PI / float(num_views));
		frustum.bottom = frustum.near * Math::tan(-50.f * Consts::DEG2RAD);
		frustum.top = frustum.near * Math::tan(50 * Consts::DEG2RAD);
	}

	// create camera
	{
		camera = Camera::create();
		camera->setProjection(Math::frustum(
			frustum.left,
			frustum.right,
			frustum.bottom,
			frustum.top,
			frustum.near,
			frustum.far
		));
	}

	// create viewport and render target that will be used for rendering views
	{
		viewport = Viewport::create();
		viewport->setSkipFlags(~0); // set all skip flags - i.e. we don't want posteffects, shadows, etc.
		viewport->setLifetime(60 * 60); // set a large lifetime so that viewport doesn't free tmp resources between renders
		viewport->setRenderMode(Viewport::RENDER_DEPTH_GBUFFER); // we will need depth and gbuffer
		viewport->getEventEndOpacityGBuffer().connect(connections, this, &Lidar::on_gbuffer_ready);

		render_target = RenderTarget::create();
	}

	{
		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(is_debug.get() > 0);

		console_on_screen = Console::isOnscreen();
		Console::setOnscreen(true);
	}

	init_views();
	init_rays();
}

void Lidar::update()
{
	// update all views when none are awaiting texture-to-image transfer
	if (std::all_of(views.begin(), views.end(), [](auto const& view) { return view.state == View::IDLE || view.state == View::UNUSED; }))
		update_views();

	// update all rays when all views' textures have been updated and transfered to cpu
	if (std::all_of(views.begin(), views.end(), [](auto const& view) { return view.state == View::UPDATED || view.state == View::UNUSED; }))
		update_rays();

	if (is_debug)
	{
		if (is_debug_render_points)
			debug_render_dots();

		if (is_debug_render_frustums)
			debug_render_frustums();

		debug_update_sprites();
	}
}

void Lidar::shutdown()
{
	for (auto& view : views)
	{
		view.debug_sprite.deleteLater();
	}

	Visualizer::setEnabled(visualizer_enabled);
	Console::setOnscreen(console_on_screen);
}

void Lidar::init_views()
{
	views.resize(num_views);

	for (int i = 0; i < num_views; i += 1)
	{
		auto& view = views[i];

		{
			// assume the view is unused by default
			view.state = View::UNUSED;
		}

		// calculate view / plane transform
		{
			float turn = float(i) / float(num_views);
			float plane_angle = (turn - .25f) * Consts::PI2;
			view.plane = vec4(Math::cos(plane_angle), Math::sin(plane_angle), 0.f, frustum.near);
			view.transform = rotateZ(360.f * turn) * rotateX(90.f);
		}

		{
			// the texture will contain depth and intensity information in two 32-bit float channels:
			// R channel for linear depth, and G channel for intensity
			int format = Texture::FORMAT_RG32F;
			int flags = Texture::FORMAT_USAGE_RENDER; // set FORMAT_USAGE_RENDER flag because we will be rendering to this texture

			view.texture = Texture::create();
			view.texture->create2D(resolution.get().x, resolution.get().y, format, flags);
		}

		{
			view.image = Image::create();
		}

		// create a debug sprite for rendering the texture with depth/intensity data
		{
			int sprite_size = ftoi(itof(WindowManager::getMainWindow()->getSize().x) * 0.65f / num_views);

			view.debug_sprite = WidgetSprite::create("core/textures/common/black.texture");
			view.debug_sprite->setPosition(i * (sprite_size + 5), WindowManager::getMainWindow()->getSize().y - sprite_size);
			view.debug_sprite->setWidth(sprite_size);
			view.debug_sprite->setHeight(sprite_size);
			view.debug_sprite->setRender(view.texture, 0);
			view.debug_sprite->setHidden(!(is_debug && is_debug_render_textures));

			Gui::getCurrent()->addChild(view.debug_sprite, Gui::ALIGN_OVERLAP);
		}
	}
}

void Lidar::init_rays()
{
	// set up ray direction vectors and find their corresponding locations on the view planes

	rays.resize(yaw_rays * pitch_rays);

	int num_stacks = pitch_rays;
	int num_slices = yaw_rays;

	int ray_idx = 0;

	for (int stack_idx = 0; stack_idx < num_stacks; stack_idx += 1)
	{
		float phi_time = float(stack_idx) / float(num_stacks - 1);
		float phi = lerp(pitch_angle_range.get().x, pitch_angle_range.get().y, phi_time) * Consts::DEG2RAD;

		for (int slice_idx = 0; slice_idx < num_slices; slice_idx += 1)
		{
			float theta_time = float(slice_idx) / float(num_slices - 1);
			float theta = lerp(yaw_angle_range.get().x, yaw_angle_range.get().y, theta_time) * Consts::DEG2RAD - Consts::PI05;

			vec3 direction = vec3(Math::cos(phi) * Math::cos(theta), -Math::cos(phi) * Math::sin(theta), Math::sin(phi));

			{
				Ray& ray = rays[ray_idx];

				ray.direction = direction;
				ray.location = cast_ray_onto_view(direction);
				ray.distance = 0.f;
				ray.intensity = 0.f;
			}

			ray_idx += 1;
		}
	}

	// sort the rays based on their image/pixel location to ensure (more or less) linear memory access
	// later on in Lidar::refresh_rays() when reading image pixel data to extract depth and intensity --
	// a predictable memory access pattern will help performance a bit

	quickSort<Ray>(rays.get(), rays.size(), [](Ray const& l, Ray const& r) { return l.location < r.location; });
}

void Lidar::update_views()
{
	last_transform = node->getWorldTransform();

	render_views();
}

void Lidar::render_views()
{
	// render all views to textures and schedule texture-to-image transfers

	UNIGINE_PROFILER_FUNCTION;

	for (int i = 0; i < num_views; i += 1)
	{
		auto& view = views[i];

		// skip unused views
		if (view.state == View::UNUSED)
			continue;

		// render the view
		{
			active_view_idx = i;
			camera->setModelview(inverse(last_transform * Mat4(view.transform)));

			RenderState::saveState();
			RenderState::clearStates();
			RenderState::setViewport(0, 0, resolution.get().x, resolution.get().y);

			render_target->enable();

			{
				// calls Lidar::on_gbuffer_ready
				viewport->render(camera);
			}

			render_target->disable();

			RenderState::restoreState();
		}

		// transfer the rendered texture to image
		{
			auto on_transfered = [&view, pnode = node](ImagePtr)
			{
				// because this is an async callback
				// check that the node is still alive
				if (pnode.isDeleted())
					return;

				// set the view state to 'UPDATED' in the main thread
				view.state = View::UPDATED;
			};

			auto on_transfered_async = [&view, pnode = node](ImagePtr image)
			{
				// because this is an async callback
				// check that the node is still alive
				if (pnode.isDeleted())
					return;

				// grab the new image and clear the old image

				// deleting a large image can take a while
				// so we do this here in the async thread

				view.image->swap(image);
				image->clear();
			};

			view.state = View::TRANSFER;

			Render::asyncTransferTextureToImage(
				MakeCallback(on_transfered),
				MakeCallback(on_transfered_async),
				view.texture
			);
		}
	}
}

void Lidar::on_gbuffer_ready()
{
	// when the gbuffer is ready we run our post material (fragment shader) that:
	// a) stores the linear depth for each fragment in the R-channel as 32-bit float
	// b) calculates intensity for each fragment using the metalness, roughness and normal textures from gbuffer

	// see "lidar_post.basemat" for further details

	auto& view = views[active_view_idx];

	// use the existing post render target for rendering
	auto post_render_target = Renderer::getPostRenderTarget();

	RenderState::saveState();
	RenderState::clearStates();

	// bind textures that our post material will use as input
	RenderState::setTexture(RenderState::BIND_FRAGMENT, 0, Renderer::getTextureOpacityDepth()); // depth
	RenderState::setTexture(RenderState::BIND_FRAGMENT, 1, Renderer::getTextureGBufferNormal()); // normal, roughness
	RenderState::setTexture(RenderState::BIND_FRAGMENT, 2, Renderer::getTextureGBufferShading()); // metalness

	// bind our view's RG32F texture that will be used as output by our material
	post_render_target->bindColorTexture(0, view.texture);
	post_render_target->enable();

	{
		lidar_post_material->renderScreen(Render::PASS_POST);
	}

	post_render_target->disable();
	post_render_target->unbindColorTextures();

	RenderState::restoreState();
}

void Lidar::update_rays()
{
	// update each ray's distance (depth) and intesity data
	// by reading the corresponding pixel data in the view images

	UNIGINE_PROFILER_FUNCTION;

	for (auto& ray : rays)
	{
		if (ray.location)
		{
			ray.distance = read_depth(ray.location);
			ray.intensity = read_intensity(ray.location);
			views[ray.location.view_idx].state = View::IDLE;
		}
	}
}

float Lidar::read_depth(View::Location location) const
{
	// read the pixel data at the R 32-bit float channel: depth

	return * reinterpret_cast<float *>(views[location.view_idx].image->getPixels() + location.pixel_offset);
}

float Lidar::read_intensity(View::Location location) const
{
	// read the pixel data at the G 32-bit float channel: intensity

	return * reinterpret_cast<float *>(views[location.view_idx].image->getPixels() + location.pixel_offset + sizeof(float));
}

Lidar::View::Location Lidar::cast_ray_onto_view(vec3 const& direction)
{
	// find the intersection of a ray (with the given direction vector) with the view planes
	// and return the location of the intersection point as view(image) id + pixel offset

	View::Location result;

	for (int i = 0; i < num_views; i += 1)
	{
		View& view = views[i];

		// try to intersect the view plane
		vec3 point;

		if (!rayPlaneIntersection(vec3_zero, direction, view.plane, point))
			continue;

		// get coordinates from the plane's center
		float x = dot(point, cross(vec3_up, vec3(view.plane)));
		float y = dot(point, vec3_up);

		if (x < frustum.left || x > frustum.right || y < frustum.bottom || y > frustum.top)
			continue;

		{
			// ray hit a plane

			// normalize coordinates [0, 1]
			x = (x - frustum.left) / (frustum.right - frustum.left);
			y = (y - frustum.bottom) / (frustum.top - frustum.bottom);

			// flip y
			y = 1.f - y;

			// clear the "unused" flag
			view.state = View::IDLE;

			// store the view index
			result.view_idx = uint32_t(i);

			// find and store pixel offset in the view texture/image
			{
				uint32_t pixel_size = sizeof(float /* depth */) + sizeof(float /* intensity */);

				result.pixel_offset = {
					uint32_t(resolution.get().x) * (uint32_t(y * float(resolution.get().y)) * pixel_size) +
					uint32_t(x * float(resolution.get().x)) * pixel_size
				};
			}

			break;
		}
	}

	return result;
}

void Lidar::save_lidar_data_to_las(StringStack<> const& path) const
{
	// save rays as point cloud where each ray, if it hit anything, is
	// described as a hit point with position vector (x, y, z) and intensity

	// the point cloud is saved in the LAS format

	Las::LasWriter las_writer;
	las_writer.init();

	for (auto const& ray : rays)
	{
		if (ray.distance < distance_range.get().x || ray.distance > distance_range.get().y)
			continue;

		vec3 ray_position = ray.direction * ray.distance;
		las_writer.add_point(ray_position, ray.intensity);
	}

	las_writer.save(path);

	Log::message("Saved lidar data to %s\n", FileSystem::getAbsolutePath(path).get());
}

void Lidar::debug_render_dots() const
{
	for (auto const& ray : rays)
	{
		bool is_valid = {
			ray.location &&
			ray.distance > distance_range.get().x &&
			ray.distance < distance_range.get().y
		};

		if (!is_valid)
			continue;

		Vec3 position = last_transform * Vec3(ray.direction * ray.distance);
		Visualizer::renderPoint3D(position, 0.0075f, vec4(vec3(ray.intensity), 1.f));
	}
}

void Lidar::debug_render_frustums() const
{
	mat4 projection = camera->getProjection();

	for (int i = 0; i < num_views; i += 1)
	{
		Mat4 transform = node->getWorldTransform() * Mat4(views[i].transform);

		Visualizer::renderFrustum(projection, transform, vec4(itof(i) / num_views, 1, itof(4 - i) / num_views, 1));

		{
			// float arrow_size = .6f;
			// float arrow_end_size = .15f;
			// float arrow_opacity = .8f;

			Vec3 position = transform.getTranslate();
			// Vec3 axis_x = transform.getAxisX();
			// Vec3 axis_y = transform.getAxisY();
			Vec3 axis_z = transform.getAxisZ();

			// Visualizer::renderVector(position, position + axis_x * arrow_size, vec4_red * vec4(vec3(1.f), arrow_opacity), arrow_end_size);
			// Visualizer::renderVector(position, position + axis_y * arrow_size, vec4_green * vec4(vec3(1.f), arrow_opacity), arrow_end_size);
			// Visualizer::renderVector(position, position + axis_z * arrow_size, vec4_blue * vec4(vec3(1.f), arrow_opacity), arrow_end_size);

			Visualizer::renderMessage3D(position - axis_z, vec3(0.f), String::format("%d", i), vec4_white);
		}
	}
}

void Lidar::debug_update_sprites()
{
	for (int i = 0; i < num_views; i += 1)
	{
		auto& view = views[i];
		float sprite_size = float(view.debug_sprite->getWidth());
		view.debug_sprite->setPosition(i * (sprite_size + 5), WindowManager::getMainWindow()->getSize().y - sprite_size);
		view.debug_sprite->setHidden(!is_debug_render_textures);
	}
}

```

## LidarSample.cpp

```cpp
#include "Lidar.h"

#include <UnigineGame.h>
#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class LidarSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(LidarSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

	PROP_PARAM(Node, lidar_node);
	PROP_PARAM(Node, sun);

	PROP_PARAM(Float, rotation_speed, 2.f);

private:
	void init()
	{
		lidar = getComponent<Lidar>(lidar_node);
		window.createWindow(Gui::ALIGN_LEFT);

		window.addBoolParameter("Debug Render Points", "", lidar->is_debug_render_points > 0, [this](bool value) { lidar->is_debug_render_points = (int)value; });
		window.addBoolParameter("Debug Render Textures", "", lidar->is_debug_render_textures > 0, [this](bool value) { lidar->is_debug_render_textures = (int)value; });
		window.addBoolParameter("Debug Render Frustums", "", lidar->is_debug_render_frustums > 0, [this](bool value) { lidar->is_debug_render_frustums = (int)value; });
		window.addBoolParameter("Lights Enabled", "", true, [this](bool value) { sun->setEnabled(value); });

		auto group_box = window.getParameterGroupBox();
		auto save_button = WidgetButton::create("Save Lidar Data");
		save_button->getEventClicked().connect(this, &LidarSample::on_save_button_clicked);
		group_box->addChild(save_button, Gui::ALIGN_LEFT);
	}

	void update()
	{
		lidar->getNode()->rotate(quat(vec3_up, rotation_speed * Game::getIFps()));
	}

	void shutdown()
	{
		window.shutdown();
	}

	void on_save_button_clicked(WidgetPtr const&, int)
	{
		lidar->save_lidar_data_to_las(joinPaths(getWorldRootPath(), "lidar.las"));
	}

	SampleDescriptionWindow window;
	Lidar *lidar = nullptr;
};

REGISTER_COMPONENT(LidarSample);

```

## LightsSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineVisualizer.h>
#include <UnigineLights.h>

#include "../../menu_ui/SampleDescriptionWindow.h"

using namespace Unigine;
using namespace Math;

class LightSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(LightSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		create_world_light();
		create_omni_light();
		create_projected_light();

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);

		gui.init(this);
	}

	void update()
	{
		omni_light->renderVisualizer();
		proj_light->renderVisualizer();
	}

	void shutdown()
	{
		gui.shutdown();
		Visualizer::setEnabled(visualizer_enabled);
	}

	void create_world_light()
	{
		world_light = LightWorld::create(vec4_white);

		world_light->setColorMode(Light::COLOR_MODE_TEMPERATURE);
		world_light->setColorTemperature(6500.f);
		world_light->setIntensity(1.f);

		world_light->setScattering(LightWorld::SCATTERING_SUN);

		world_light->setWorldRotation(quat(273.f, 330.f, 120.f));
	}

	void create_omni_light()
	{
		omni_light = LightOmni::create(vec4_white, 20.f, "omni");

		omni_light->setShapeType(Light::SHAPE_SPHERE);
		omni_light->setShapeRadius(0.17f);

		omni_light->setAttenuationDistance(20.f);

		// set the shadow color texture mode to ies for the omni light
		omni_light->setShadowColorTextureMode(Light::SHADOW_COLOR_MODE_IES);

		// set the projected texture by its path, alternatively you can use LightOmni::setTexture and LightOmni::setTextureImage
		omni_light->setTextureFilePath(FileSystem::resolvePartialVirtualPath("white.texture"));

		omni_light->setColorMode(Light::COLOR_MODE_TEMPERATURE);
		omni_light->setColorTemperature(3165.f);
		omni_light->setIntensity(1.3f);

		omni_light->setWorldPosition(Vec3(1.1f, -1.3f, 2.2f));
	}

	void create_projected_light()
	{
		proj_light = LightProj::create(vec4_white, 20.f, 70.f, "proj");

		proj_light->setColorMode(Light::COLOR_MODE_TEMPERATURE);
		proj_light->setColorTemperature(4000.f);
		proj_light->setIntensity(1.3f);

		proj_light->setShapeType(Light::SHAPE_POINT);

		proj_light->setFov(70.f);

		proj_light->setAttenuationDistance(20.f);
		proj_light->setPenumbra(0.15f);

		// set the shadow color texture mode to SHADOW_COLOR_MODE_SIMPLE to be able to use any 2D texture
		proj_light->setShadowColorTextureMode(Light::SHADOW_COLOR_MODE_SIMPLE);

		proj_light->setTextureFilePath(FileSystem::resolvePartialVirtualPath("white.texture"));

		proj_light->setWorldPosition(Vec3(-0.8f, -1.1f, 2.3f));
		proj_light->setWorldRotation(quat(30.f, 343.f, 331.f));
	}

	// ========================================================================================

	struct SampleGui
	{
		void init(LightSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			sample_description_window.addFloatParameter(
				"world light angle",
				"Change the rotation of the LightWorld.",
				273.f,
				273.f,
				360.f,
				[sample](float value) {
					sample->world_light->setWorldRotation(quat(value, 330.f, 120.f));
				}
			);

			sample_description_window.addParameterSpacer();

			sample_description_window.addFloatParameter(
				"omni light intensity",
				"Change the light intensity of the LightOmni.",
				1.3f,
				0.f,
				2.f,
				[sample](float value) {
					sample->omni_light->setIntensity(value);
				}
			);

			sample_description_window.addFloatParameter(
				"omni light color temperature",
				"Change the color temperature of the LightOmni.",
				3165.f,
				1000.f,
				10'000.f,
				[sample](float value) {
					sample->omni_light->setColorTemperature(value);
				}
			);

			sample_description_window.addParameterSpacer();

			sample_description_window.addFloatParameter(
				"projected light penumbra",
				"Change the penumbra parameter of the LightProj.",
				.15f,
				0.f,
				1.f,
				[sample](float value) {
					sample->proj_light->setPenumbra(value);
				}
			);

			sample_description_window.addFloatParameter(
				"projected light fov",
				"Change the FOV of the LightProj.",
				75.f,
				0.f,
				120.f,
				[sample](float value) {
					sample->proj_light->setFov(value);
				}
			);
		}

		void shutdown() { sample_description_window.shutdown(); }

		SampleDescriptionWindow sample_description_window;
		LightSample *sample = nullptr;
	};

	// ========================================================================================

	LightWorldPtr world_light;
	LightOmniPtr omni_light;
	LightProjPtr proj_light;

	bool visualizer_enabled = false;

	SampleGui gui;
};

REGISTER_COMPONENT(LightSample);

```

## LinearMotion.cpp

```cpp
#include "LinearMotion.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(LinearMotion);

using namespace Unigine;
using namespace Math;

void LinearMotion::update()
{
	Vec3 cur_pos = persecutor->getPosition();
	Vec3 target_pos = targetNode.get()->getWorldPosition();
	// align target to persecutor's plane
	target_pos.z = cur_pos.z;

	bool finished = true;
	Vec3 target_dir;
	float step = speed * Game::getIFps();
	cur_pos = move_towards(cur_pos, target_pos, step, finished, target_dir);

	// apply calculations to persecutor
	if (!finished)
		persecutor->setRotation(target_dir);

	persecutor->setPosition(cur_pos);
	persecutor->setAnimation(speed, finished);
}

Vec3 LinearMotion::move_towards(const Vec3 &src, const Vec3 &dst, float step, bool &out_finished,
	Vec3 &out_dir)
{
	// find distance and direction to destination
	Vec3 offset = dst - src;
	float dist = (float)length(offset);
	if (dist <= step)
	{
		out_finished = true;
		if (dist > 0)
			out_dir = offset / dist;
		return dst;
	}

	out_finished = false;
	out_dir = offset / dist;
	return src + out_dir * step;
}
```

## ListBox.cpp

```cpp
#include "ListBox.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(ListBox);

using namespace Unigine;
using namespace Math;

void ListBox::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_listbox = WidgetListBox::create(gui);

	gui->addChild(widget_listbox, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_listbox->setPosition(position.get().x, position.get().y);
	widget_listbox->setFontSize(font_size.get());
	widget_listbox->setFontOutline(1);
	widget_listbox->addItem("item 0");
	widget_listbox->addItem("item 1");
	widget_listbox->addItem("item 2");

	widget_listbox->getEventChanged().connect(*this, [this]() {
		String msg = String("ListBox: ") + widget_listbox->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void ListBox::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_listbox);

		widget_listbox.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## MainMenu.cpp

```cpp
#include "MainMenu.h"

#include <UnigineXml.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(MainMenu);

using namespace Unigine;
using namespace Math;


BlobPtr MainMenu::saved_state = Blob::create();

void MainMenu::init()
{
	// parse meta
	SamplesManager::get()->parseMetaXml(ui_configuration->path_to_meta.get());

	const Vector<Category> categories = SamplesManager::get()->getCategories();
	const Vector<String> tags = SamplesManager::get()->getTags();

	Tag::setTagConfig(ui_configuration->tag_style.get());

	// samples list
	samples_and_tags_hbox = WidgetHBox::create();

	create_sample_list(categories);
	samples_and_tags_hbox->addChild(sample_list->getWidget(), Gui::ALIGN_LEFT | Gui::ALIGN_EXPAND);

	create_side_panel();
	samples_and_tags_hbox->addChild(side_panel_vbox, Gui::ALIGN_LEFT);

	// create search field
	search_field = std::make_unique<WidgetSearchField>(ui_configuration.get());
	side_panel_vbox->addChild(search_field->getWidget(), Gui::ALIGN_TOP);

	// tags area
	create_tag_cloud(tags);
	side_panel_vbox->addChild(tag_cloud->getWidget(), Gui::ALIGN_EXPAND);

	// setup main window
	auto main_window = WindowManager::getMainWindow();
	main_window->addChild(samples_and_tags_hbox, Gui::ALIGN_EXPAND);
	main_window->setMinSize(ivec2(ui_configuration->sample_list->sample_list_min_width.get()
			+ ui_configuration->search_section->width,
		ui_configuration->common->min_window_height));

	// setup callbacks
	search_field->getEventSearchRequest().connect(*this, sample_list.get(), &WidgetSampleList::filter);
	search_field->getEventTagRemoved().connect(*this, [this](const String &str) {
		tag_cloud->setTagSelected(str, false);
		sample_list->setTagSelected(str, false);
	});
	search_field->getEventTagAdded().connect(*this, [this](const String &str) {
		tag_cloud->setTagSelected(str, true);
		sample_list->setTagSelected(str, true);
	});

	Tag::getEventClicked().connect(*this, [this](const String &str) {
		search_field->changeTagState(str, ui_configuration->tag_style.get());
	});
	expand_button_sprite->getEventClicked().connect(*this, [this]() { sample_list->setCollapseAll(false); });
	collaps_button_sprite->getEventClicked().connect(*this, [this]() { sample_list->setCollapseAll(true); });

	Input::setMouseHandle(Input::MOUSE_HANDLE_USER);

	if (saved_state.isValid())
		restore(saved_state);
}

void MainMenu::update()
{
	EngineWindowViewportPtr window = WindowManager::getMainWindow();
	int window_height = window->getClientSize().y;

	tag_cloud->update();
	sample_list->update();
	search_field->update();

	side_panel_vbox->setHeight(window_height);
	search_field->getWidget()->setHeight(side_panel_vbox->getHeight()
		* ui_configuration->search_section->search_field_releative_size.get());

	update_close_button();
}

void MainMenu::shutdown()
{
	save(saved_state);
	samples_and_tags_hbox.deleteLater();
}

void MainMenu::save(const Unigine::BlobPtr &blob)
{
	blob->clear();
	search_field->save(blob);
	sample_list->save(blob);
}

void MainMenu::restore(const Unigine::BlobPtr &blob)
{
	if (blob->getSize() <= 0)
		return;

	blob->seekSet(0);
	search_field->restore(blob);
	sample_list->restore(blob);
}

void MainMenu::update_close_button()
{
	bool down = Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT);
	bool up = Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT);

	bool hovered = MenuUtils::isHovered(close_button);

	if (!hovered && !up)
		return;

	if (close_button_pressed && up)
	{
		close_button_pressed = false;
		if (hovered)
		{
			Engine::get()->quit();
		}
	}

	if (!close_button_pressed && down && hovered)
	{
		close_button_pressed = true;
	}

	close_button->setBackgroundColor(close_button_pressed ? close_pressed_color : close_color);
}

void MainMenu::parse_meta_xml(String path_relative_to_data, Vector<Category> &categories, Vector<String> &tags)
{
	String cpp_samples_xml_path = FileSystem::getAbsolutePath(String::joinPaths(Engine::get()->getDataPath(), path_relative_to_data));

	XmlPtr cpp_samples_xml = Xml::create();
	if (!cpp_samples_xml->load(cpp_samples_xml_path))
	{
		Unigine::Log::warning("MainMenu::parse_meta_xml(): cannot open %s file\n", cpp_samples_xml_path.get());
		return;
	}

	XmlPtr cpp_samples_samples_pack = cpp_samples_xml->getChild("samples_pack");
	XmlPtr categories_xml = cpp_samples_samples_pack->getChild("categories");
	XmlPtr samples_xml = cpp_samples_samples_pack->getChild("samples");

	HashMap<String, Category> categories_map;
	Vector<String> categories_id;
	HashSet<String> tags_set;

	for (int i = 0; i < categories_xml->getNumChildren(); ++i)
	{
		XmlPtr category_xml = categories_xml->getChild(i);

		String icon_path = category_xml->getArg("img");
		icon_path = icon_path.trimFirst("data/");

		Category c;
		c.icon = Image::create(icon_path.get());
		c.title = category_xml->getArg("name");

		String category_id = category_xml->getArg("id");

		categories_id.append(category_id);
		categories_map[category_id] = c;
	}

	for (int i = 0; i < samples_xml->getNumChildren(); ++i)
	{
		XmlPtr sample_xml = samples_xml->getChild(i);

		Sample s;
		s.title = sample_xml->getArg("title");
		s.description = sample_xml->getChild("sdk_desc")->getData();
		s.world_name = sample_xml->getArg("id");

		XmlPtr tags_xml = sample_xml->getChild("tags");
		for (int j = 0; j < tags_xml->getNumChildren(); ++j)
		{
			String tag = tags_xml->getChild(j)->getData();

			if (!tags_set.contains(tag))
				tags_set.insert(tag);

			s.tags.push_back(tag);
		}

		String category_id = sample_xml->getArg("category_id");

		if (categories_map.contains(category_id))
			categories_map[category_id].samples.push_back(s);
		else
			Unigine::Log::error("Category with id %s don't exists in .sample file\n", category_id.get());
	}

	categories.clear();

	for (const auto &id : categories_id)
	{
		if (categories_map.contains(id) && categories_map.value(id).samples.size() > 0)
			categories.push_back(categories_map.value(id));
	}
	categories_id.clear();

	tags.clear();
	for (const auto &t : tags_set)
	{
		tags.push_back(t.key);
	}

}

void MainMenu::create_side_panel()
{
	int space_y = ui_configuration->search_section->space_between_child_sections;
	side_panel_vbox = WidgetVBox::create(0, space_y);
	side_panel_vbox->setBackground(1);
	side_panel_vbox->setBackgroundTexture(ui_configuration->search_section->background.get());
	side_panel_vbox->setBackgroundColor(ui_configuration->search_section->background_color.get());
	side_panel_vbox->setBackground9Sliced(true);
	vec4 offsets = ui_configuration->search_section->background_offsets.get();
	side_panel_vbox->setBackground9SliceOffsets(offsets.x, offsets.y, offsets.z, offsets.w);
	side_panel_vbox->setBackground9SliceScale(ui_configuration->search_section->background_slice_scale.get());
	side_panel_vbox->setWidth(ui_configuration->search_section->width);
	ivec4 padding = ui_configuration->search_section->padding.get();
	side_panel_vbox->setPadding(padding.x, padding.y, padding.z - space_y, padding.w - space_y);

	// create control buttons box
	auto& control_config = ui_configuration->search_section->control_panel;
	int space_x = control_config->control_panel_space_x;
	auto control_hbox = WidgetHBox::create(space_x, 0);
	control_hbox->setPadding(-space_x, -space_x, 0, 0);
	control_hbox->setWidth(ui_configuration->search_section->width - padding.x - padding.y);
	control_hbox->setHeight(control_config->close_button_height.get());
	side_panel_vbox->addChild(control_hbox, Gui::ALIGN_TOP);

	// create expand button
	expand_button_sprite = WidgetSprite::create();
	expand_button_sprite->setTexture(control_config->expand_button_icon.get());
	expand_button_sprite->setWidth(control_config->expand_button_size.get());
	expand_button_sprite->setHeight(control_config->expand_button_size.get());
	expand_button_sprite->setToolTip("Expand all categories");

	expand_button_sprite->getEventEnter().connect(*this, [this]() { expand_button_sprite->setTexture(ui_configuration->search_section->control_panel->expand_button_hovered_icon.get()); });
	expand_button_sprite->getEventLeave().connect(*this, [this]() { expand_button_sprite->setTexture(ui_configuration->search_section->control_panel->expand_button_icon.get()); });
	control_hbox->addChild(expand_button_sprite, Gui::ALIGN_LEFT);

	// create collapse button
	collaps_button_sprite = WidgetSprite::create();
	collaps_button_sprite->setTexture(control_config->collaps_button_icon.get());
	collaps_button_sprite->setWidth(control_config->collaps_button_size.get());
	collaps_button_sprite->setHeight(control_config->collaps_button_size.get());
	collaps_button_sprite->setToolTip("Collapse all categories");

	collaps_button_sprite->getEventEnter().connect(*this, [this]() { collaps_button_sprite->setTexture(ui_configuration->search_section->control_panel->collaps_button_hovered_icon.get()); });
	collaps_button_sprite->getEventLeave().connect(*this, [this]() { collaps_button_sprite->setTexture(ui_configuration->search_section->control_panel->collaps_button_icon.get()); });
	control_hbox->addChild(collaps_button_sprite, Gui::ALIGN_LEFT);

	// create close button
	close_color = control_config->close_button_background_color.get();
	close_pressed_color = close_color * control_config->close_button_tint_color.get();

	auto close_label = WidgetLabel::create(control_config->close_button_text);
	close_label->setFont(control_config->close_font.get());
	close_label->setFontSize(control_config->close_font_size);
	close_label->setFontColor(control_config->close_font_color);

	close_button = WidgetHBox::create();
	close_button->setBackground(1);
	close_button->setBackgroundTexture(control_config->close_button_background.get());
	close_button->setBackgroundColor(control_config->close_button_background_color.get());
	close_button->setWidth(control_config->close_button_width.get());
	close_button->setHeight(control_config->close_button_height.get());

	close_button->addChild(close_label, Gui::ALIGN_CENTER);
	control_hbox->addChild(close_button, Gui::ALIGN_RIGHT | Gui::ALIGN_TOP);
}

void MainMenu::create_sample_list(const Vector<Category> &categories)
{
	sample_list = std::make_unique<WidgetSampleList>(categories, ui_configuration.get());
	sample_list->getWidget()->arrange();
}

void MainMenu::create_tag_cloud(const Vector<String> &tags)
{
	tag_cloud = std::make_unique<WidgetTagCloud>(tags, ui_configuration.get());
	tag_cloud->getWidget()->arrange();
}

WidgetSearchField::WidgetSearchField(MainMenu::UIConfiguration &config)
{
	tag_config = config.tag_style.get();

	auto &search_field_params = config.search_section->search_field;
	space_between_tags_in_row = search_field_params->space_between_tags_in_row.get();

	auto auxiliary_hbox = WidgetHBox::create(0, 0);
	auxiliary_hbox->setBackground(1);
	auxiliary_hbox->setBackgroundTexture(search_field_params->background.get());
	auxiliary_hbox->setBackgroundColor(search_field_params->background_color.get());
	auxiliary_hbox->setBackground9Sliced(true);
	vec4 offsets = search_field_params->background_offsets.get();
	auxiliary_hbox->setBackground9SliceOffsets(offsets.x, offsets.y, offsets.z, offsets.w);
	auxiliary_hbox->setBackground9SliceScale(search_field_params->background_slice_scale.get());

	ivec4 padding = search_field_params->padding.get();
	auxiliary_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	editline = WidgetEditLine::create();
	editline->setHeight(search_field_params->height.get() - padding.z - padding.w - 5);
	editline->setBorderColor(vec4(0.0f, 0.0f, 0.0f, 0.0f));
	editline->setBackground(0);
	editline->setSelectionColor(search_field_params->selection_color.get());
	editline->setFont(search_field_params->font.get());
	editline->setFontSize(search_field_params->font_size.get());
	editline->setFontColor(search_field_params->font_color.get());

	auxiliary_hbox->addChild(editline, Gui::ALIGN_EXPAND);

	icon_sprite = WidgetSprite::create();
	icon_sprite->setTexture(search_field_params->icon.get());
	icon_sprite->setWidth(search_field_params->icon_size.get());
	icon_sprite->setHeight(search_field_params->icon_size.get());
	icon_sprite->setColor(search_field_params->icon_color.get());

	auxiliary_hbox->addChild(icon_sprite, Gui::ALIGN_RIGHT);
	auxiliary_hbox->setHeight(search_field_params->height.get());
	padding = config.search_section->padding.get();
	auxiliary_hbox->setWidth(config.search_section->width - padding.x - padding.y);

	int space_y = search_field_params->space_between_rows_of_tags.get();
	main_vbox = WidgetVBox::create(0, space_y);
	main_vbox->addChild(auxiliary_hbox, Gui::ALIGN_TOP);
	main_vbox->setPadding(0, 0, -space_y, -space_y);

	tags_scrollbox = WidgetScrollBox::create(0,
		search_field_params->space_between_rows_of_tags.get());
	tags_scrollbox->setHScrollEnabled(false);
	tags_scrollbox->setVScrollHidden(WidgetScrollBox::SCROLL_RENDER_MODE::ALWAYS_HIDE_NO_BOUNDS);
	tags_scrollbox->setBorder(0);
	tags_scrollbox->setPadding(0, 0, -space_y, -space_y);
	main_vbox->addChild(tags_scrollbox, Gui::ALIGN_EXPAND);
	main_vbox->arrange();
	tags_scrollbox->setWidth(main_vbox->getWidth());

	editline->getEventFocusOut().connect(editline_callback_connections, this, &WidgetSearchField::run_event_search_request);
	editline->getEventFocusOut().connect(editline_callback_connections,
		[this]() { event_editline_focus.run(false); });
	editline->getEventFocusIn().connect(editline_callback_connections,
		[this]() { event_editline_focus.run(true); });
	editline->getEventChanged().connect(editline_callback_connections, this, &WidgetSearchField::run_event_search_request);
}

WidgetSearchField::~WidgetSearchField()
{
	main_vbox.deleteLater();
	editline_callback_connections.disconnectAll();
	tag_remove_button_connections.disconnectAll();
}

void WidgetSearchField::changeTagState(const Unigine::String &str, MainMenu::UITagStyle &config)
{
	if (tag_widgets.contains(str))
		removeTagFromSearch(str);
	else
		addTagToSerach(str, config);
}

void WidgetSearchField::addTagToSerach(const Unigine::String &str, MainMenu::UITagStyle &config)
{
	if (tag_widgets.contains(str))
		return;

	WidgetPtr tag = MenuUtils::createTagWidget(str, config, MenuUtils::SEARCH_FIELD);

	tag_widgets_ordered.push_back(tag);
	tag_widgets[str] = tag;

	for (int i = 0; i < tag->getNumChildren(); ++i)
	{
		WidgetSpritePtr sprite = checked_ptr_cast<WidgetSprite>(tag->getChild(i));

		if (sprite)
		{
			sprite->getEventPressed().connect(tag_remove_button_connections, [this, sprite, &config]() {
				pressed = true;
				sprite->setLayerColor(1,
					config.remove_button_icon_color.get() * config.remove_button_tint_color.get());
			});
			sprite->getEventReleased().connect(tag_remove_button_connections, [this, sprite, &config]() {
				pressed = false;
				sprite->setLayerColor(1, config.remove_button_icon_color.get());
			});
			sprite->getEventClicked().connect(tag_remove_button_connections,
				[this, str]() { removeTagFromSearch(str); });

			break;
		}
	}

	event_tag_added.run(str);
	arrange_tags();
	run_event_search_request();
}

void WidgetSearchField::removeTagFromSearch(const Unigine::String &str)
{
	auto it = tag_widgets.find(str);
	if (it == tag_widgets.end())
		return;

	auto it_ordered = tag_widgets_ordered.find((*it).data);
	tag_widgets_ordered.remove(it_ordered);
	tag_widgets.remove(it);

	event_tag_removed.run(str);
	arrange_tags();
	run_event_search_request();
}

void WidgetSearchField::update()
{
	if (pressed)
		return;

	if (editline->isFocused()
		&& (Input::isKeyDown(Input::KEY_ESC) || Input::isKeyDown(Input::KEY_ENTER)))
		editline->removeFocus();

	if (MenuUtils::isHovered(tags_scrollbox))
	{
		int wheel = Input::getMouseWheel();
		if (wheel)
		{
			int value = tags_scrollbox->getVScrollValue();
			int step = tags_scrollbox->getVScrollStepSize();
			tags_scrollbox->setVScrollValue(value - wheel * step * 4);
		}
	}
	else
		tags_scrollbox->removeFocus();
}

void WidgetSearchField::save(const Unigine::BlobPtr &blob)
{
	blob->writeInt(tag_widgets.size());
	for (const auto &it : tag_widgets)
		blob->writeString(it.key);

	blob->writeString(editline->getText());
}

void WidgetSearchField::restore(const Unigine::BlobPtr &blob)
{
	event_search_request.setEnabled(false);

	int tags_size = blob->readInt();
	for (int i = 0; i < tags_size; i++)
		addTagToSerach(blob->readString(), tag_config);

	editline->getEventChanged().setEnabled(false);
	editline->setText(blob->readString());
	editline->getEventChanged().setEnabled(true);

	event_search_request.setEnabled(true);
	run_event_search_request();
}

void WidgetSearchField::arrange_tags()
{
	for (int i = tags_scrollbox->getNumChildren(); i > 0; --i)
	{
		auto child = tags_scrollbox->getChild(i - 1);
		tags_scrollbox->removeChild(child);
		child.deleteLater();
	}

	auto current_tags_hbox = WidgetHBox::create(space_between_tags_in_row);
	current_tags_hbox->setPadding(-space_between_tags_in_row, -space_between_tags_in_row, 0, 0);
	tags_scrollbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);

	for (int i = 0; i < tag_widgets_ordered.size(); ++i)
	{
		WidgetPtr tag = tag_widgets_ordered[i];

		current_tags_hbox->arrange();
		tag->arrange();
		int current_width = current_tags_hbox->getWidth() + tag->getWidth()
			+ space_between_tags_in_row;
		if (current_width < tags_scrollbox->getWidth())
		{
			current_tags_hbox->addChild(tag);
		}
		else
		{
			current_tags_hbox = WidgetHBox::create(space_between_tags_in_row);
			current_tags_hbox->setPadding(-space_between_tags_in_row, -space_between_tags_in_row, 0,
				0);
			tags_scrollbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);
			current_tags_hbox->addChild(tag);
		}
	}
	current_tags_hbox->arrange();
}

void WidgetSearchField::run_event_search_request()
{
	String str = editline->getText();

	Vector<String> words;
	String buffer = "";
	for (int i = 0; i < str.size(); ++i)
	{
		char c = String::toLower(str[i]);
		if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))
		{
			buffer += c;
		}
		else
		{
			if (!buffer.empty())
				words.push_back(buffer);
			buffer.clear();
		}
	}

	if (!buffer.empty())
		words.push_back(buffer);


	Vector<String> tags;
	for (const auto &it : tag_widgets)
	{
		String lower_tag = it.key;
		tags.push_back(lower_tag.lower());
	}

	event_search_request.run(words, tags);
}

WidgetTagCloud::WidgetTagCloud(const Vector<String> &tags, MainMenu::UIConfiguration &config)
{
	auto &tag_cloud_params = config.search_section->tag_cloud;
	main_vbox = WidgetVBox::create();

	auto title = WidgetLabel::create("TAGS");
	title->setFont(tag_cloud_params->font);
	title->setFontSize(tag_cloud_params->font_size);
	title->setFontColor(tag_cloud_params->font_color.get());
	main_vbox->addChild(title, Gui::ALIGN_LEFT);

	main_scrollbox = WidgetScrollBox::create(0, tag_cloud_params->space_between_rows.get());
	main_scrollbox->setHScrollEnabled(false);
	main_scrollbox->setVScrollHidden(WidgetScrollBox::SCROLL_RENDER_MODE::ALWAYS_HIDE_NO_BOUNDS);
	main_scrollbox->setBorder(0);
	main_vbox->addChild(main_scrollbox, Gui::ALIGN_EXPAND);

	ivec4 padding = config.search_section->padding.get();
	int max_tags_hbox_size = config.search_section->width.get() - padding.x - padding.y;
	
	int x_space = tag_cloud_params->space_between_tags_in_row.get();
	auto current_tags_hbox = WidgetHBox::create(x_space);
	current_tags_hbox->setPadding(-x_space, -x_space, 0, 0);
	main_scrollbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);

	for (int i = 0; i < tags.size(); ++i)
	{
		auto tag = new Tag(tags[i], MenuUtils::TAGS_CLOUD);
		tag_widgets[tags[i]] = tag;
		pressed_tags[tags[i]] = false;

		main_scrollbox->arrange();
		current_tags_hbox->arrange();
		auto tag_widget = tag->getWidget();
		tag_widget->arrange();
		int current_width = current_tags_hbox->getWidth() + tag_widget->getWidth() + x_space;
		if (current_width < max_tags_hbox_size)
		{
			current_tags_hbox->addChild(tag_widget, Gui::ALIGN_LEFT);
		}
		else
		{
			// create new
			current_tags_hbox = WidgetHBox::create(x_space);
			current_tags_hbox->setPadding(-x_space, -x_space, 0, 0);
			main_scrollbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);
			current_tags_hbox->addChild(tag_widget);
		}
	}
}

WidgetTagCloud::~WidgetTagCloud()
{
	for (auto &tag : tag_widgets)
		delete tag.data;
	tag_widgets.clear();

	main_scrollbox.deleteLater();
}

void WidgetTagCloud::update()
{
	if (Console::isActive())
		return;

	bool down = Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT);
	bool up = Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT);

	for (const auto &tag_widget : tag_widgets)
	{
		tag_widget.data->update(up, down);
	}

	if (MenuUtils::isHovered(main_scrollbox))
	{
		int wheel = Input::getMouseWheel();
		if (wheel)
		{
			int value = main_scrollbox->getVScrollValue();
			int step = main_scrollbox->getVScrollStepSize();
			main_scrollbox->setVScrollValue(value - wheel * step * 4);
		}
	}
	else
		main_scrollbox->removeFocus();
}

void WidgetTagCloud::setTagSelected(const Unigine::String &str, bool selected)
{
	if (!tag_widgets.contains(str))
		return;

	auto &widget = tag_widgets[str];
	widget->setTagSelected(selected);
}

WidgetSampleListNode::WidgetSampleListNode(MainMenu::UIConfiguration &config)
{
	main_vbox = WidgetVBox::create();
	header_hbox = WidgetHBox::create();
	children_container_vbox = WidgetVBox::create();

	main_vbox->addChild(header_hbox, Gui::ALIGN_EXPAND);
	main_vbox->addChild(children_container_vbox, Gui::ALIGN_EXPAND);

	tint_color = config.sample_list->tint_color.get();
}

WidgetSampleListNode::~WidgetSampleListNode()
{
	for (int i = 0; i < children.size(); ++i)
		delete children[i];

	main_vbox.deleteLater();
}

void WidgetSampleListNode::addChild(WidgetSampleListNode *node)
{
	children_container_vbox->addChild(node->getWidget(), Gui::ALIGN_EXPAND);
	children.push_back(node);
	node->parent = this;
}

void WidgetSampleListNode::setHidden(bool hide)
{
	if (hide == is_hidden)
		return;

	is_hidden = hide;

	main_vbox->setHidden(is_hidden);
	main_vbox->setEnabled(!is_hidden);
}

void WidgetSampleListNode::setChildrenHidden(bool hide)
{
	if (hide == is_children_hidden)
		return;

	is_children_hidden = hide;

	children_container_vbox->setHidden(is_children_hidden);
	children_container_vbox->setEnabled(!is_children_hidden);
}

void WidgetSampleListNode::show_press_effect(bool show)
{
	header_hbox->setColor(show ? tint_color : vec4_white);
}

void WidgetSampleListNode::update()
{
	if (!isChildrenHidden())
		for (int i = 0; i < children.size(); ++i)
			children[i]->update();

	if (Console::isActive())
		return;

	bool hovered = MenuUtils::isHovered(header_hbox);

	bool down = Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT);
	bool up = Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT);

	if (pressed && up)
	{
		pressed = false;
		if (hovered)
			on_clicked();
	}

	if (!pressed && down && hovered)
		pressed = true;

	show_press_effect(pressed);
}

WidgetSample::WidgetSample(const Sample &sample, MainMenu::UIConfiguration &config)
	: WidgetSampleListNode(config)
{
	auto &sample_params = config.sample_list->sample;
	sample_info = sample;

	header_hbox->setBackground(1);
	header_hbox->setBackgroundTexture(sample_params->background.get());
	header_hbox->setBackgroundColor(sample_params->background_color.get());
	header_hbox->setBackground9Sliced(true);
	vec4 offsets = sample_params->background_offsets.get();
	header_hbox->setBackground9SliceOffsets(offsets.x, offsets.y, offsets.z, offsets.w);
	header_hbox->setBackground9SliceScale(sample_params->background_slice_scale.get());

	ivec4 padding = sample_params->background_padding.get();
	header_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	header_vbox = WidgetVBox::create();
	header_vbox->setSpace(0, sample_params->content_vertical_spacing.get());
	header_hbox->addChild(header_vbox, Gui::ALIGN_EXPAND);

	auto title_hbox = WidgetHBox::create();

	title_label = WidgetLabel::create(sample_info.title);
	title_label->setFont(sample_params->title_font.get());
	title_label->setFontSize(sample_params->title_font_size.get());
	title_label->setFontColor(sample_params->title_font_color.get());
	title_hbox->addChild(title_label, Gui::ALIGN_CENTER);
	header_vbox->addChild(title_hbox, Gui::ALIGN_LEFT);

	auto description_hbox = WidgetHBox::create();
	description_label = WidgetLabel::create(sample_info.description);
	description_label->setFont(sample_params->description_font.get());
	description_label->setFontSize(sample_params->description_font_size.get());
	description_label->setFontColor(sample_params->description_font_color.get());
	description_label->setFontRich(1);
	description_label->setFontWrap(1);
	description_label->setFontVSpacing(sample_params->description_font_vspacing);
	description_hbox->addChild(description_label, Gui::ALIGN_EXPAND);
	header_vbox->addChild(description_hbox, Gui::ALIGN_EXPAND);

	Unigine::String tag_info;
	auto tags_vbox = WidgetVBox::create(0, sample_params->space_between_rows_of_tags.get());
	int x_space = sample_params->space_between_tags_in_row.get();
	auto current_tags_hbox = WidgetHBox::create(x_space);
	current_tags_hbox->setPadding(-x_space, -x_space, 0, 0);
	tags_vbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);
	int max_tags_hbox_width = config.sample_list->sample_list_min_width.get()
		- config.sample_list->padding.get().x - config.sample_list->padding.get().y
		- sample_params->side_offset.get() - sample_params->background_padding.get().x
		- sample_params->background_padding.get().y;
	for (int i = 0; i < sample.tags.size(); ++i)
	{
		tag_info += " " + sample.tags[i];
		auto tag = new Tag(sample.tags[i], MenuUtils::SAMPLES_LIST);
		auto tag_widget = tag->getWidget();
		tag_widgets[sample.tags[i]] = tag;
		tag_widget->arrange();
		current_tags_hbox->arrange();

		if (tag_widget->getWidth() + current_tags_hbox->getWidth() < max_tags_hbox_width)
		{
			current_tags_hbox->addChild(tag_widget, Gui::ALIGN_LEFT);
		}
		else
		{
			current_tags_hbox = WidgetHBox::create(x_space);
			current_tags_hbox->setPadding(-x_space, -x_space, 0, 0);
			tags_vbox->addChild(current_tags_hbox, Gui::ALIGN_LEFT);
			current_tags_hbox->addChild(tag_widget, Gui::ALIGN_LEFT);
		}
	}
	header_vbox->addChild(tags_vbox, Gui::ALIGN_LEFT);

	search_info += sample_info.title.lower();
	search_info += " ";
	search_info += sample_info.description.lower();
	search_info += " ";
	search_info += tag_info.lower();
}

WidgetSample::~WidgetSample()
{
	for (auto &tag : tag_widgets)
		delete tag.data;
	tag_widgets.clear();
}

void WidgetSample::getSearchInfo(Unigine::String &main_info,
	Unigine::Vector<Unigine::String> &tags) const
{
	String category_search_info;
	Vector<String> empty;
	parent->getSearchInfo(category_search_info, empty);

	main_info.clear();
	main_info += search_info;
	main_info += category_search_info.lower();

	tags.clear();
	tags = sample_info.tags;
}

void WidgetSample::update()
{
	if (isHidden())
		return;

	if (pressed)
	{
		WidgetSampleListNode::update();
		return;
	}

	bool some_hovered = false;

	bool down = Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT);
	bool up = Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT);

	for (const auto &tag_widget : tag_widgets)
	{
		some_hovered |= MenuUtils::isHovered(tag_widget.data->getWidget());
		tag_widget.data->update(up, down);
	}

	if(!some_hovered)
		WidgetSampleListNode::update();
}

void WidgetSample::setTagSelected(const Unigine::String &str, bool selected)
{
	if (!tag_widgets.contains(str))
		return;

	auto &widget = tag_widgets[str];
	widget->setTagSelected(selected);
}

void WidgetSample::on_clicked()
{
	World::loadWorld(sample_info.world_name, true);
}

WidgetCategory::WidgetCategory(const Category &category, MainMenu::UIConfiguration &config)
	: WidgetSampleListNode(config)
{
	auto &category_params = config.sample_list->category;
	category_info = category;

	header_hbox->setBackground(1);
	header_hbox->setBackgroundTexture(category_params->background.get());
	header_hbox->setBackgroundColor(category_params->background_color.get());
	header_hbox->setBackground9Sliced(true);
	vec4 offsets = category_params->background_offsets.get();
	header_hbox->setBackground9SliceOffsets(offsets.x, offsets.y, offsets.z, offsets.w);
	header_hbox->setBackground9SliceScale(category_params->background_slice_scale.get());

	ivec4 padding = category_params->background_padding.get();
	header_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	children_container_vbox->setSpace(0, category_params->vertical_spacing.get());
	children_container_vbox->setPadding(config.sample_list->sample->side_offset.get(), 0, 0, 0);

	icon_sprite = WidgetSprite::create();
	icon_sprite->setImage(category_info.icon);
	icon_sprite->setHeight(category_params->icon_size.get().y);
	icon_sprite->setWidth(category_params->icon_size.get().x);
	header_hbox->addChild(icon_sprite, Gui::ALIGN_LEFT);

	title_label = WidgetLabel::create(category_info.title);
	title_label->setFont(category_params->title_font.get());
	title_label->setFontSize(category_params->title_font_size.get());
	title_label->setFontColor(category_params->title_font_color.get());
	auto title_box = WidgetVBox::create();
	title_box->setPadding(category_params->title_offset,0,0,0);
	title_box->addChild(title_label, Gui::ALIGN_LEFT);
	header_hbox->addChild(title_box, Gui::ALIGN_LEFT);

	arrow_sprite = WidgetSprite::create();
	arrow_sprite->setTexture(category_params->arrow_icon.get());
	arrow_sprite->setColor(category_params->arrow_icon_color.get());
	arrow_sprite->setWidth(category_params->arrow_icon_size.get());
	arrow_sprite->setHeight(category_params->arrow_icon_size.get());
	auto icon_padding = category_params->arrow_offset.get();
	auto arrow_box = WidgetVBox::create();
	arrow_box->setPadding(icon_padding.x, icon_padding.y, icon_padding.z, icon_padding.w);
	arrow_box->addChild(arrow_sprite, Gui::ALIGN_CENTER);
	header_hbox->addChild(arrow_box, Gui::ALIGN_RIGHT);

	const Vector<Sample> &samples = category.samples;
	for (int i = 0; i < samples.size(); ++i)
	{
		const Sample &sample = samples[i];

		WidgetSample *widget = new WidgetSample(sample, config);
		addChild(widget);
	}
}

WidgetCategory::~WidgetCategory()
{
}

void WidgetCategory::getSearchInfo(Unigine::String &main_info, Unigine::Vector<Unigine::String> &tags) const
{
	main_info.clear();
	tags.clear();

	main_info += title_label->getText();
}

void WidgetCategory::setTagSelected(const Unigine::String &str, bool selected)
{
	for (int i = 0; i < children.size(); ++i)
		children[i]->setTagSelected(str, selected);
}

void WidgetCategory::setChildrenHidden(bool hide)
{
	WidgetSampleListNode::setChildrenHidden(hide);

	if (!children_container_vbox->isHidden())
		arrow_sprite->setTexCoord(vec4(0.0f, 1.0f, 1.0f, 0.0f));
	else
		arrow_sprite->setTexCoord(vec4(0.0f, 0.0f, 1.0f, 1.0f));
}

void WidgetCategory::on_clicked()
{
	setChildrenHidden(!isChildrenHidden());
}

WidgetSampleList::WidgetSampleList(const Vector<Category> &categories, MainMenu::UIConfiguration &config)
{
	main_scrollbox = WidgetScrollBox::create(0, config.sample_list->vertical_spacing.get());
	main_scrollbox->setHScrollEnabled(false);
	main_scrollbox->setWidth(config.sample_list->sample_list_min_width.get());
	main_scrollbox->setVScrollHidden(WidgetScrollBox::SCROLL_RENDER_MODE::ALWAYS_HIDE_NO_BOUNDS);
	main_scrollbox->setBorder(0);

	ivec4 padding = config.sample_list->padding.get();
	main_scrollbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	// temp widget to get scrollbox vbox widget
	auto temp = WidgetVBox::create();
	main_scrollbox->addChild(temp);

	auto background_vbox = checked_ptr_cast<WidgetVBox>(temp->getParent());
	background_vbox->setBackground(1);
	background_vbox->setBackgroundTexture(config.common->white_image.get());
	background_vbox->setBackgroundColor(config.sample_list->sample_list_background_color.get());

	for (int i = 0; i < categories.size(); ++i)
	{
		const Category &category = categories[i];
	
		WidgetCategory *widget = new WidgetCategory(category, config);
		widget->setChildrenHidden(true);

		background_vbox->addChild(widget->getWidget());

		roots.push_back(widget);
	}

	main_scrollbox->removeChild(temp);
	temp.deleteLater();
}

WidgetSampleList::~WidgetSampleList()
{
	for (int i = 0; i < roots.size(); ++i)
		delete roots[i];

	roots.clear();

	main_scrollbox.deleteLater();
}

void WidgetSampleList::setTagSelected(const Unigine::String &str, bool selected)
{
	for (int i = 0; i < roots.size(); ++i)
		roots[i]->setTagSelected(str, selected);
}

void WidgetSampleList::update()
{
	for (int i = 0; i < roots.size(); ++i)
		roots[i]->update();

	bool hovered = MenuUtils::isHovered(main_scrollbox);

	if (hovered)
	{
		int wheel = Input::getMouseWheel();
		if (wheel)
		{
			int value = main_scrollbox->getVScrollValue();
			int step = main_scrollbox->getVScrollStepSize();
			main_scrollbox->setVScrollValue(value - wheel * step * 4);
		}
	}
	else
		main_scrollbox->removeFocus();
}

void WidgetSampleList::setCollapseAll(bool collapse)
{
	for (int i = 0; i < roots.size(); ++i)
		roots[i]->setChildrenHidden(collapse);
}

void WidgetSampleList::save(const Unigine::BlobPtr &blob)
{
	int num_roots = roots.size();
	blob->writeInt(num_roots);

	for (auto const &root : roots)
	{
		blob->writeString(root->getTitle());
		blob->writeBool(root->isChildrenHidden());
	}

	int scroll = main_scrollbox->getVScrollValue();
	blob->writeInt(scroll);
}

void WidgetSampleList::restore(const Unigine::BlobPtr &blob)
{
	int num_roots = blob->readInt();

	HashMap<String, bool> hidden_children;
	hidden_children.clear();
	hidden_children.reserve(num_roots);

	for (int i = 0; i < num_roots; i++)
	{
		String title = blob->readString();
		bool is_hidden = blob->readBool();
		hidden_children[title] = is_hidden;
	}

	for (auto &root : roots)
	{
		String title = root->getTitle();
		if (hidden_children.contains(title))
		{
			root->setChildrenHidden(hidden_children[title]);
		}
	}

	int scroll_value = blob->readInt();
	main_scrollbox->arrange();
	main_scrollbox->setVScrollValue(scroll_value);
}

void WidgetSampleList::filter(const Unigine::Vector<Unigine::String> &search_words, const Unigine::Vector<Unigine::String> &search_tags)
{
	for (int i = 0; i < roots.size(); ++i)
		filter_node(roots[i], search_words, search_tags);
}

void WidgetSampleList::filter_node(WidgetSampleListNode *node, const Unigine::Vector<Unigine::String> &search_words, const Unigine::Vector<Unigine::String> &search_tags)
{
	int num_children = node->getNumChildren();

	if (num_children > 0)
	{
		int num_enabled = 0;
		for (int i = 0; i < num_children; ++i)
		{
			filter_node(node->getChild(i), search_words, search_tags);

			if (!node->getChild(i)->isHidden())
				++num_enabled;
		}

		node->setHidden(num_enabled == 0);
		if (!node->isHidden())
			node->setChildrenHidden(false);
	}
	else
	{
		String main_info;
		Vector<String> node_tags;
		node->getSearchInfo(main_info, node_tags);

		if (search_words.empty() && search_tags.empty())
		{
			node->setHidden(false);
			return;
		}

		int num_tag_matches = 0;
		// check tags
		for (int i = 0; i < node_tags.size(); ++i)
		{
			auto node_tag = node_tags[i];
			node_tag.lower();
			for (int j = 0; j < search_tags.size(); ++j)
			{
				String tag = search_tags[j];
				tag.lower();
				if (!String::compare(node_tag, tag))
				{
					++num_tag_matches;
					break;
				}
			}
		}

		bool tags_search = num_tag_matches == search_tags.size();
		if (!tags_search)
		{
			node->setHidden(true);
			return;
		}

		bool words_search = search_words.empty();
		// check words
		for (int i = 0; i < search_words.size(); ++i)
		{
			if (MenuUtils::isWordSuitable(main_info, search_words[i]))
			{
				words_search = true;
				break;
			}
		}

		node->setHidden(!words_search);
	}
}

WidgetHBoxPtr MenuUtils::createTagWidget(const String &text, const MainMenu::UITagStyle &config, TAG_PLACE place)
{
	auto main_hbox = WidgetHBox::create();

	ivec4 padding = config.background_padding.get();
	switch (place)
	{
	case TAG_PLACE::SEARCH_FIELD:
		padding = ivec4(toInt(padding.x * config.search_field_scale.get()),
			toInt(padding.y * config.search_field_scale.get()),
			toInt(padding.z * config.search_field_scale.get()),
			toInt(padding.w * config.search_field_scale.get()));
		break;
	case TAG_PLACE::SAMPLES_LIST:
		padding = ivec4(toInt(padding.x * config.sample_list_scale.get()),
			toInt(padding.y * config.sample_list_scale.get()),
			toInt(padding.z * config.sample_list_scale.get()),
			toInt(padding.w * config.sample_list_scale.get()));
		break;
	case TAG_PLACE::TAGS_CLOUD:
		padding = ivec4(toInt(padding.x * config.tag_cloud_scale.get()),
			toInt(padding.y * config.tag_cloud_scale.get()),
			toInt(padding.z * config.tag_cloud_scale.get()),
			toInt(padding.w * config.tag_cloud_scale.get()));
		break;
	}

	main_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	main_hbox->setBackground(1);
	main_hbox->setBackgroundColor(config.background_color.get());
	main_hbox->setBackgroundTexture(config.background.get());
	main_hbox->setBackground9Sliced(true);
	vec4 offsets = config.background_offsets.get();
	main_hbox->setBackground9SliceOffsets(offsets.x, offsets.y, offsets.z, offsets.w);
	main_hbox->setBackground9SliceScale(config.background_slice_scale.get());

	auto label = WidgetLabel::create(text.get());
	label->setFont(config.font.get());
	int font_size = config.font_size.get();
	auto font_color = config.font_color.get();
	switch (place)
	{
	case TAG_PLACE::SEARCH_FIELD:
		font_size *= config.search_field_scale.get();
		font_color = config.selected_font_color.get();
		label->setFont(config.selected_font.get());
		break;
	case TAG_PLACE::SAMPLES_LIST:
		font_size *= config.sample_list_scale.get();
		break;
	case TAG_PLACE::TAGS_CLOUD:
		font_size *= config.tag_cloud_scale.get();
		break;
	}
	label->setFontSize(font_size);
	label->setFontColor(font_color);

	main_hbox->addChild(label);

	if (place == TAG_PLACE::SEARCH_FIELD)
	{
		main_hbox->setBackgroundTexture(config.selected_background.get());
		main_hbox->setSpace(5, 0);
		main_hbox->setPadding(padding.x, padding.y - 5, padding.z, padding.w);

		auto remove_button_sprite = WidgetSprite::create();
		remove_button_sprite->setLayerTexture(0, config.remove_button_background.get());
		remove_button_sprite->setLayerColor(0, config.remove_button_background_color.get());
		remove_button_sprite->addLayer();
		remove_button_sprite->setLayerTexture(1, config.remove_button_icon.get());
		remove_button_sprite->setLayerColor(1, config.remove_button_icon_color.get());
		remove_button_sprite->setWidth(config.remove_button_size.get() * config.search_field_scale.get());
		remove_button_sprite->setHeight(config.remove_button_size.get() * config.search_field_scale.get());

		main_hbox->addChild(remove_button_sprite, Gui::ALIGN_RIGHT);
	}

	return main_hbox;
}

bool MenuUtils::isWordSuitable(const String &text, const String &word)
{
	for (int i = 0; i < text.size() - word.size() + 1; ++i)
	{
		int num_matches = 0;
		for (int j = 0; j < word.size(); ++j)
		{
			if (text[i + j] == word[j])
				++num_matches;
			else
				break;
		}

		if (num_matches == word.size())
			return true;
	}

	return false;
}

bool MenuUtils::isHovered(const Unigine::WidgetPtr widget)
{
	bool hovered = widget->getMouseX() >= 0 && widget->getMouseX() < widget->getWidth()
		&& widget->getMouseY() >= 0 && widget->getMouseY() < widget->getHeight();
	return hovered;
}


MainMenu::UITagStyle Tag::config;
Unigine::EventInvoker<const Unigine::String &> Tag::event_clicked;

Tag::Tag(const Unigine::String &text_, MenuUtils::TAG_PLACE place)
	: text(text_)
{
	tag_widget = MenuUtils::createTagWidget(text_, config, place);
	for (int i = 0; i < tag_widget->getNumChildren(); i++)
	{
		auto child = checked_ptr_cast<WidgetLabel>(tag_widget->getChild(i));
		if (child)
		{
			label = child;
			break;
		}
	}
}

void Tag::setTagSelected(bool selected)
{
	if (is_selected == selected)
		return;

	is_selected = selected;
	vec4 color = config.font_color.get();
	if (selected)
	{
		tag_widget->setBackgroundTexture(config.selected_background.get());
		color = config.selected_font_color.get();
	}
	else
	{
		tag_widget->setBackgroundTexture(config.background.get());
	}

	if (label)
		label->setFontColor(color);
}

void Tag::update(bool up, bool down)
{
	bool hovered = MenuUtils::isHovered(tag_widget);
	if (!hovered && !up)
		return;

	if (is_pressed && up)
	{
		is_pressed = false;
		if (hovered)
		{
			event_clicked.run(text);
//			setTagSelected(!is_selected);
		}
	}

	if (!is_pressed && down && hovered)
	{
		is_pressed = true;
	}

	tag_widget->setColor(is_pressed ? config.tint_color : vec4_white);
}

```

## Manipulators.cpp

```cpp
#include "Manipulators.h"
#include <UnigineWidgets.h>
#include <UnigineGame.h>
#include <UnigineWorld.h>
#include <UniginePlayers.h>

REGISTER_COMPONENT(Manipulators);

using namespace Unigine;
using namespace Math;

void get_mesh_bs(const NodePtr& node, WorldBoundSphere& bs)
{
	if (!node) return;

	if (node->isObject())
		bs.expand(node->getWorldBoundSphere());

	if (node->getType() == Node::NODE_REFERENCE)
		get_mesh_bs(checked_ptr_cast<NodeReference>(node)->getReference(), bs);
	for (int i = 0; i < node->getNumChildren(); i++)
		get_mesh_bs(node->getChild(i), bs);
}

void Manipulators::init()
{
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	// by default all axes are available for each manipulator
	is_x_axis_rotation = true;
	is_y_axis_rotation = true;
	is_z_axis_rotation = true;
	is_x_axis_translation = true;
	is_y_axis_translation = true;
	is_z_axis_translation = true;
	is_x_axis_scale = true;
	is_y_axis_scale = true;
	is_z_axis_scale = true;

	// by default manipulators work in world basis
	is_local_basis = false;

	// creating manipulators
	gui = Gui::getCurrent();
	object_translator = WidgetManipulatorTranslator::create(gui);
	object_rotator = WidgetManipulatorRotator::create(gui);
	object_scaler = WidgetManipulatorScaler::create(gui);

	gui->addChild(object_translator);
	gui->addChild(object_rotator);
	gui->addChild(object_scaler);

	object_translator->setHidden(true);
	object_rotator->setHidden(true);
	object_scaler->setHidden(true);
	current_object_manipulator = object_translator;

	object_translator->getEventChanged().connect(this, &Manipulators::apply_transform);
	object_rotator->getEventChanged().connect(this, &Manipulators::apply_transform);
	object_scaler->getEventChanged().connect(this, &Manipulators::apply_transform);

	auto player = Game::getPlayer();
	player->setControlled(false);
}

void Manipulators::update()
{
	auto player = Game::getPlayer();

	// if mouse is grabbed, we enable player control making hotkeys for switching manipulators unavailable
	if (Input::isMouseGrab())
		player->setControlled(true);

	// reset projection and view matrices for correct rendering of the widget
	if (player)
	{
		object_translator->setProjection(player->getProjection());
		object_rotator->setProjection(player->getProjection());
		object_scaler->setProjection(player->getProjection());

		object_translator->setModelview(player->getCamera()->getModelview());
		object_rotator->setModelview(player->getCamera()->getModelview());
		object_scaler->setModelview(player->getCamera()->getModelview());
	}

	// trying to get an object to manipulate
	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON::MOUSE_BUTTON_RIGHT) && !Input::isMouseGrab())
	{
		obj = get_node_under_cursor();
		if (obj)
		{
			switch_manipulator(current_object_manipulator);
		}
		else
		{
			unselect();
		}
	}

	// if some object is selected and it is not a ComponentLogic node
	if (obj)
	{
		// reset manipulator's transform matrix, after moving the object
		if (Input::isMouseButtonUp(Input::MOUSE_BUTTON::MOUSE_BUTTON_LEFT))
		{
			switch_manipulator(current_object_manipulator);
		}

		// if mouse is not grabbed, disable player control and enable hotkeys to switch manipulators
		if (!Input::isMouseGrab())
		{
			player->setControlled(false);

			if (Input::isKeyDown(Input::KEY::KEY_W))
				switch_manipulator(object_translator);

			if (Input::isKeyDown(Input::KEY::KEY_E))
				switch_manipulator(object_rotator);

			if (Input::isKeyDown(Input::KEY::KEY_R))
				switch_manipulator(object_scaler);
		}

		// hotkey to focus on an object at focus_distance distance
		if (Input::isKeyDown(Input::KEY::KEY_F))
		{
			vec3 inversePlayerViewDirection = -player->getViewDirection();
			WorldBoundSphere bs;
			get_mesh_bs(obj, bs);
			player->setWorldPosition(bs.center + Vec3(inversePlayerViewDirection * ((float)bs.radius * 2.0f)));
		}

		// hotkeys to unselect an object
		if (Input::isKeyDown(Input::KEY::KEY_U) || Input::isKeyDown(Input::KEY::KEY_ESC)) // || Input::isMouseCursorHide())
		{
			unselect();
		}
	}
}

void Manipulators::shutdown()
{
	// destroy widgets
	object_translator.deleteLater();
	object_rotator.deleteLater();
	object_scaler.deleteLater();
}

void Manipulators::apply_transform()
{
	// applying transformation of the widget to the object
	if (obj)
	{
		NodePtr manipulate_node = obj;

		if (transform_parent && manipulate_node->getParent())
			manipulate_node = manipulate_node->getParent();

		manipulate_node->setWorldTransform(current_object_manipulator->getTransform());
	}
}

Unigine::ObjectPtr Manipulators::get_node_under_cursor()
{
	auto player = Game::getPlayer();
	ivec2 mouse = Input::getMousePosition();

	// returns the first object intersected by the ray casted from the player in the forward direction at a distance of 10000 units
	return World::getIntersection(player->getWorldPosition(), player->getWorldPosition() + Vec3(player->getDirectionFromMainWindow(mouse.x, mouse.y) * 10000), intersection_mask.get());
}

void Manipulators::switch_manipulator(const Unigine::WidgetManipulatorPtr &currentManipulator)
{
	if (obj)
	{
		set_manipulators_basis();

		current_object_manipulator = currentManipulator;
		current_object_manipulator->setHidden(false);

		NodePtr manipulate_node = obj;

		if (transform_parent && manipulate_node->getParent())
			manipulate_node = manipulate_node->getParent();

		current_object_manipulator->setTransform(manipulate_node->getWorldTransform());


		// show only selected manipulator
		if (object_translator != current_object_manipulator)
			object_translator->setHidden(true);
		if (object_rotator != current_object_manipulator)
			object_rotator->setHidden(true);
		if (object_scaler != current_object_manipulator)
			object_scaler->setHidden(true);
	}
}

void Manipulators::unselect()
{
	// reset selection to the DummyNode(ComponentLogic node in the world)
	obj = ObjectPtr();

	// hide all manipulators
	object_translator->setHidden(true);
	object_rotator->setHidden(true);
	object_scaler->setHidden(true);
}

void Manipulators::set_manipulators_basis()
{
	if (obj)
	{
		if (is_local_basis)
		{
			// reset the basis of manipulators to object's local basis
			object_rotator->setBasis(obj->getWorldTransform());
			object_translator->setBasis(obj->getWorldTransform());
			object_scaler->setBasis(obj->getWorldTransform());
		}
		else
		{
			// resets the basis of manipulators to world basis
			object_rotator->setBasis(Mat4_identity);
			object_translator->setBasis(Mat4_identity);
			object_scaler->setBasis(Mat4_identity);
		}
	}
}

// enables or disables the corresponding axis for each manipulator
void Manipulators::setXAxisRotation(bool value)
{
	is_x_axis_rotation = value;
	if (is_x_axis_rotation)
		object_rotator->setMask(object_rotator->getMask() | WidgetManipulator::MASK_X);
	else
		object_rotator->setMask(object_rotator->getMask() & ~(WidgetManipulator::MASK_X));
}

void Manipulators::setYAxisRotation(bool value)
{
	is_y_axis_rotation = value;
	if (is_y_axis_rotation)
		object_rotator->setMask(object_rotator->getMask() | WidgetManipulator::MASK_Y);
	else
		object_rotator->setMask(object_rotator->getMask() & ~(WidgetManipulator::MASK_Y));
}

void Manipulators::setZAxisRotation(bool value)
{
	is_z_axis_rotation = value;
	if (is_z_axis_rotation)
		object_rotator->setMask(object_rotator->getMask() | WidgetManipulator::MASK_Z);
	else
		object_rotator->setMask(object_rotator->getMask() & ~(WidgetManipulator::MASK_Z));
}

void Manipulators::setXAxisTranslation(bool value)
{
	is_x_axis_translation = value;
	if (is_x_axis_translation)
		object_translator->setMask(object_translator->getMask() | WidgetManipulator::MASK_X);
	else
		object_translator->setMask(object_translator->getMask() & ~(WidgetManipulator::MASK_X));
}

void Manipulators::setYAxisTranslation(bool value)
{
	is_y_axis_translation = value;
	if (is_y_axis_translation)
		object_translator->setMask(object_translator->getMask() | WidgetManipulator::MASK_Y);
	else
		object_translator->setMask(object_translator->getMask() & ~(WidgetManipulator::MASK_Y));
}

void Manipulators::setZAxisTranslation(bool value)
{
	is_z_axis_translation = value;
	if (is_z_axis_translation)
		object_translator->setMask(object_translator->getMask() | WidgetManipulator::MASK_Z);
	else
		object_translator->setMask(object_translator->getMask() & ~(WidgetManipulator::MASK_Z));
}

void Manipulators::setXAxisScale(bool value)
{
	is_x_axis_scale = value;
	if (is_x_axis_scale)
		object_scaler->setMask(object_scaler->getMask() | WidgetManipulator::MASK_X);
	else
		object_scaler->setMask(object_scaler->getMask() & ~(WidgetManipulator::MASK_X));
}

void Manipulators::setYAxisScale(bool value)
{
	is_y_axis_scale = value;
	if (is_y_axis_scale)
		object_scaler->setMask(object_scaler->getMask() | WidgetManipulator::MASK_Y);
	else
		object_scaler->setMask(object_scaler->getMask() & ~(WidgetManipulator::MASK_Y));
}

void Manipulators::setZAxisScale(bool value)
{
	is_z_axis_scale = value;
	if (is_z_axis_scale)
		object_scaler->setMask(object_scaler->getMask() | WidgetManipulator::MASK_Z);
	else
		object_scaler->setMask(object_scaler->getMask() & ~(WidgetManipulator::MASK_Z));
}

// switches the basis for manipulators from local to world and back from world to local
void Manipulators::setLocalBasis(bool value)
{
	is_local_basis = value;
	set_manipulators_basis();
}

```

## ManipulatorsSample.cpp

```cpp
#include "ManipulatorsSample.h"

#include "Manipulators.h"

REGISTER_COMPONENT(ManipulatorsSample);

using namespace Unigine;
using namespace Math;

void ManipulatorsSample::init()
{
	previous_handle = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	component = getComponent<Manipulators>(node);
	if (!component)
	{
		Log::error(
			"ManipulatorsSample::init: cannot find WidgetManipulators component!\n");
	}

	is_local_basis = false;
	sample_description_window.createWindow();
	WidgetWindowPtr window = sample_description_window.getWindow();

	auto group_box = WidgetGroupBox::create("Parameters", 8, 2);
	window->addChild(group_box, Gui::ALIGN_LEFT);

	auto hBox = WidgetHBox::create(10);
	group_box->addChild(hBox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create("Translation:");
	label->setFontWrap(1);
	label->setFontRich(1);
	label->setWidth(100);
	hBox->addChild(label, Gui::ALIGN_LEFT);
	x_axis_translation_check_box = WidgetCheckBox::create("X");
	x_axis_translation_check_box->setChecked(true);
	x_axis_translation_check_box->getEventChanged().connect(this, &ManipulatorsSample::x_axis_translation_check_box_callback);
	hBox->addChild(x_axis_translation_check_box, Gui::ALIGN_LEFT);
	y_axis_translation_check_box = WidgetCheckBox::create("Y");
	y_axis_translation_check_box->setChecked(true);
	y_axis_translation_check_box->getEventChanged().connect(this, &ManipulatorsSample::y_axis_translation_check_box_callback);
	hBox->addChild(y_axis_translation_check_box, Gui::ALIGN_LEFT);
	z_axis_translation_check_box = WidgetCheckBox::create("Z");
	z_axis_translation_check_box->setChecked(true);
	z_axis_translation_check_box->getEventChanged().connect(this, &ManipulatorsSample::z_axis_translation_check_box_callback);
	hBox->addChild(z_axis_translation_check_box, Gui::ALIGN_LEFT);

	hBox = WidgetHBox::create(10);
	group_box->addChild(hBox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Rotation:");
	label->setFontWrap(1);
	label->setFontRich(1);
	label->setWidth(100);
	hBox->addChild(label, Gui::ALIGN_LEFT);
	x_axis_rotation_check_box = WidgetCheckBox::create("X");
	x_axis_rotation_check_box->setChecked(true);
	x_axis_rotation_check_box->getEventChanged().connect(this, &ManipulatorsSample::x_axis_rotation_check_box_callback);
	hBox->addChild(x_axis_rotation_check_box, Gui::ALIGN_LEFT);
	y_axis_rotation_check_box = WidgetCheckBox::create("Y");
	y_axis_rotation_check_box->setChecked(true);
	y_axis_rotation_check_box->getEventChanged().connect(this, &ManipulatorsSample::y_axis_rotation_check_box_callback);
	hBox->addChild(y_axis_rotation_check_box, Gui::ALIGN_LEFT);
	z_axis_rotation_check_box = WidgetCheckBox::create("Z");
	z_axis_rotation_check_box->setChecked(true);
	z_axis_rotation_check_box->getEventChanged().connect(this, &ManipulatorsSample::z_axis_rotation_check_box_callback);
	hBox->addChild(z_axis_rotation_check_box, Gui::ALIGN_LEFT);

	hBox = WidgetHBox::create(10);
	group_box->addChild(hBox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Scale:");
	label->setFontWrap(1);
	label->setFontRich(1);
	label->setWidth(100);
	hBox->addChild(label, Gui::ALIGN_LEFT);
	x_axis_scale_check_box = WidgetCheckBox::create("X");
	x_axis_scale_check_box->setChecked(true);
	x_axis_scale_check_box->getEventChanged().connect(this, &ManipulatorsSample::x_axis_scale_check_box_callback);
	hBox->addChild(x_axis_scale_check_box, Gui::ALIGN_LEFT);
	y_axis_scale_check_box = WidgetCheckBox::create("Y");
	y_axis_scale_check_box->setChecked(true);
	y_axis_scale_check_box->getEventChanged().connect(this, &ManipulatorsSample::y_axis_scale_check_box_callback);
	hBox->addChild(y_axis_scale_check_box, Gui::ALIGN_LEFT);
	z_axis_scale_check_box = WidgetCheckBox::create("Z");
	z_axis_scale_check_box->setChecked(true);
	z_axis_scale_check_box->getEventChanged().connect(this, &ManipulatorsSample::z_axis_scale_check_box_callback);
	hBox->addChild(z_axis_scale_check_box, Gui::ALIGN_LEFT);

	hBox = WidgetHBox::create(10);
	group_box->addChild(hBox, Gui::ALIGN_LEFT);
	world_basis_button = WidgetButton::create("World");
	hBox->addChild(world_basis_button, Gui::ALIGN_LEFT);
	world_basis_button->setToggleable(true);
	world_basis_button->setToggled(true);
	world_basis_button->getEventChanged().connect(this, &ManipulatorsSample::world_basis_button_callback);
	local_basis_button = WidgetButton::create("Local");
	hBox->addChild(local_basis_button, Gui::ALIGN_LEFT);
	local_basis_button->setToggleable(true);
	local_basis_button->setToggled(false);
	local_basis_button->getEventChanged().connect(this, &ManipulatorsSample::local_basis_button_callback);

	window->arrange();
}

void ManipulatorsSample::shutdown()
{
	Input::setMouseHandle(previous_handle);

	sample_description_window.shutdown();
}

void ManipulatorsSample::x_axis_rotation_check_box_callback()
{
	component->setXAxisRotation(x_axis_rotation_check_box->isChecked());
}

void ManipulatorsSample::y_axis_rotation_check_box_callback()
{
	component->setYAxisRotation(y_axis_rotation_check_box->isChecked());
}

void ManipulatorsSample::z_axis_rotation_check_box_callback()
{
	component->setZAxisRotation(z_axis_rotation_check_box->isChecked());
}

void ManipulatorsSample::x_axis_translation_check_box_callback()
{
	component->setXAxisTranslation(x_axis_translation_check_box->isChecked());
}

void ManipulatorsSample::y_axis_translation_check_box_callback()
{
	component->setYAxisTranslation(y_axis_translation_check_box->isChecked());
}

void ManipulatorsSample::z_axis_translation_check_box_callback()
{
	component->setZAxisTranslation(z_axis_translation_check_box->isChecked());
}

void ManipulatorsSample::x_axis_scale_check_box_callback()
{
	component->setXAxisScale(x_axis_scale_check_box->isChecked());
}

void ManipulatorsSample::y_axis_scale_check_box_callback()
{
	component->setYAxisScale(y_axis_scale_check_box->isChecked());
}

void ManipulatorsSample::z_axis_scale_check_box_callback()
{
	component->setZAxisScale(z_axis_scale_check_box->isChecked());
}

void ManipulatorsSample::local_basis_button_callback()
{
	is_local_basis = local_basis_button->isToggled();
	world_basis_button->setToggled(!is_local_basis);
	component->setLocalBasis(is_local_basis);
}

void ManipulatorsSample::world_basis_button_callback()
{
	is_local_basis = !world_basis_button->isToggled();
	local_basis_button->setToggled(is_local_basis);
	component->setLocalBasis(is_local_basis);
}

```

## MaskPaintSample.cpp

```cpp
#include "MaskPaintSample.h"

#include <UnigineRender.h>

REGISTER_COMPONENT(MaskPaintSample);

using namespace Unigine;
using namespace Math;

void MaskPaintSample::init()
{
	saved_mouse_handle = ControlsApp::getMouseHandle();
	ControlsApp::setMouseHandle(Input::MOUSE_HANDLE_USER);

	mask_painter = ComponentSystem::get()->getComponent<LandscapeMaskPainter>(
		mask_painter_param.get());

	player = checked_ptr_cast<PlayerSpectator>(player_param.get());
	landscape_fetch = LandscapeFetch::create();

	auto guid = FileSystem::getGUID(
		FileSystem::resolvePartialVirtualPath("decal_brush_base.basemat"));

	if (!guid.isValid())
	{
		Log::error("MaskPaintSample::init(): can not find "
				   "\"decal_brush_base.basemat\" material");
		return;
	}

	brush_decal_material = Materials::findMaterialByFileGUID(guid)->inherit();
	brush_decal = DecalOrtho::create(); // 100.f, 1.f, 1.f, "decal_base"
	brush_decal->setRadius(100.f);
	brush_decal->setWidth(1.f);
	brush_decal->setMaterial(brush_decal_material);

	// show only mask data
	Render::setShowLandscapeMask(1);

	init_resources();
	init_gui();

	landscape_layer_map = checked_ptr_cast<LandscapeLayerMap>(landscape_layer_map_param.get());
	if (!landscape_layer_map)
	{
		Log::error("MaskPaintSample::init(): can not find landscape layer map");
		return;
	}

	mask_painter->enable();

	mask_painter->setTarget(landscape_layer_map);
	set_brush_texture(brush_textures.begin().get());
	set_brush_mask(brush_textures.begin().get());
	set_brush_size(brush_size);
	set_brush_spacing(brush_spacing);
	set_brush_angle(brush_angle);
	set_brush_opacity(brush_opacity);
	set_brush_color(brush_color);
}

void MaskPaintSample::init_resources()
{
	for (int i = 0; i < brush_textures_param.size(); ++i)
	{
		auto texture = Texture::create();
		texture->load(brush_textures_param.get(i));
		brush_textures.push_back(texture);

		auto image = Image::create();
		image->load(brush_textures_param.get(i));
		image->resize(32, 32);
		brush_textures_icons.push_back(image);
	}

	for (int i = 0; i < brush_masks_param.size(); ++i)
	{
		auto texture = Texture::create();
		texture->load(brush_masks_param.get(i));
		brush_masks.push_back(texture);

		auto image = Image::create();
		image->load(brush_masks_param.get(i));
		image->resize(32, 32);
		brush_masks_icons.push_back(image);
	}

	for (int i = 0; i < gradients_param.size(); ++i)
	{
		auto texture = Texture::create();
		texture->load(gradients_param.get(i));
		gradients.push_back(texture);

		auto image = Image::create();
		image->load(gradients_param.get(i));
		image->resize(32, 32);
		gradients_icons.push_back(image);
	}
}

void MaskPaintSample::update()
{
	if (window->getMouseX() >= 0 && window->getMouseX() < window->getWidth()
		&& window->getMouseY() >= 0 && window->getMouseY() < window->getHeight())
	{
		return;
	}

	if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_RIGHT))
	{
		vec2 delta = vec2(Input::getMouseDeltaPosition()) * 0.2f;
		player->setPhiAngle(player->getPhiAngle() + delta.x);
		player->setThetaAngle(player->getThetaAngle() + delta.y);
	}

	if (Input::isKeyPressed(Input::KEY_LEFT_SHIFT) || Input::isKeyPressed(Input::KEY_RIGHT_SHIFT))
	{
		set_brush_angle(brush_angle + static_cast<float>(Input::getMouseWheel()) * 5);
	}
	else if (Input::isKeyPressed(Input::KEY_LEFT_CTRL)
		|| Input::isKeyPressed(Input::KEY_RIGHT_CTRL))
	{
		set_brush_size(brush_size + static_cast<float>(Input::getMouseWheel()) * 0.5f);
	}

	const auto mouse_coord = Input::getMousePosition();
	bool fetched = landscape_fetch->intersectionForce(player->getPosition(),
		player->getPosition()
			+ Vec3(player->getDirectionFromMainWindow(mouse_coord.x, mouse_coord.y)) * 10000.0);

	if (fetched)
	{
		brush_decal->setPosition(landscape_fetch->getPosition() + Vec3(0.0, 0.0, 50.0));

		if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_LEFT))
		{
			mask_painter->paintAt(landscape_fetch->getPosition());
		}
	}
}

void MaskPaintSample::shutdown()
{
	mask_painter->disable();
	ControlsApp::setMouseHandle(saved_mouse_handle);

	window.deleteLater();

	Render::setShowLandscapeMask(0);
}

void MaskPaintSample::set_brush_texture(const TexturePtr &in_brush_texture)
{
	brush_decal_material->setTexture("albedo", in_brush_texture);
	mask_painter->setBrushTexture(in_brush_texture);
}

void MaskPaintSample::set_brush_mask(const TexturePtr &in_brush_mask)
{
	brush_decal_material->setTexture("mask", in_brush_mask);
	mask_painter->setBrushMask(in_brush_mask);
}

void MaskPaintSample::set_brush_size(float in_brush_size, bool update_ui)
{
	brush_size = max(in_brush_size, 1.0f);

	mask_painter->setBrushSize(brush_size);
	brush_decal->setWidth(brush_size);
	brush_decal->setHeight(brush_size);

	if (update_ui)
	{
		brush_size_connection.disconnect();
		brush_size_edit_line->setText(String::ftoa(brush_size));
		brush_size_edit_line->getEventChanged().connect(brush_size_connection, this,
			&MaskPaintSample::brush_size_edit_line_callback);
	}
}

void MaskPaintSample::set_brush_spacing(float in_brush_spacing, bool update_ui)
{
	brush_spacing = max(in_brush_spacing, 0.f);

	mask_painter->setBrushSpacing(brush_spacing);

	if (update_ui)
	{
		brush_spacing_connection.disconnect();
		brush_spacing_edit_line->setText(String::ftoa(brush_spacing));
		brush_spacing_edit_line->getEventChanged().connect(brush_spacing_connection, this,
			&MaskPaintSample::brush_spacing_edit_line_callback);
	}
}

void MaskPaintSample::set_brush_angle(float in_brush_angle, bool update_ui)
{
	brush_angle = in_brush_angle;

	mask_painter->setBrushAngle(in_brush_angle);
	brush_decal->setRotation(quat(0.f, 0.f, -brush_angle), true);
	if (update_ui)
	{
		brush_angle_connection.disconnect();
		brush_angle_edit_line->setText(String::ftoa(brush_angle));
		brush_angle_edit_line->getEventChanged().connect(brush_angle_connection, this,
			&MaskPaintSample::brush_angle_edit_line_callback);
	}
}

void MaskPaintSample::set_brush_opacity(float in_brush_opacity, bool update_ui)
{
	brush_opacity = clamp(in_brush_opacity, 0.0f, 1.f);

	mask_painter->setBrushOpacity(brush_opacity);

	if (update_ui)
	{
		brush_opacity_connection.disconnect();
		brush_opacity_edit_line->setText(String::ftoa(brush_opacity));
		brush_opacity_edit_line->getEventChanged().connect(brush_opacity_connection, this,
			&MaskPaintSample::brush_opacity_edit_line_callback);
	}
}

void MaskPaintSample::set_brush_color(const vec4 &in_brush_color, bool update_ui)
{
	brush_color = clamp(in_brush_color, {0.0f, 0.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f, 1.0f});
	mask_painter->setBrushColor(in_brush_color);

	// because we are drawing only in red channel
	const vec4 color_for_decal = vec4{brush_color.x, brush_color.x, brush_color.x, 1.f};

	brush_decal_material->setParameterFloat4("albedo", color_for_decal);
	if (update_ui)
	{
		brush_mask_value_connection.disconnect();
		brush_mask_value_edit_line->setText(String::ftoa(brush_color.x * 255));
		brush_mask_value_edit_line->getEventChanged().connect(brush_mask_value_connection, this,
			&MaskPaintSample::brush_mask_value_edit_line_callback);
	}
}

void MaskPaintSample::init_gui()
{
	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();

	window = sample_description_window.getWindow();

	auto hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create("Texture");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	auto gridbox = WidgetGridBox::create(6);
	parameters->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_textures.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_textures_icons[i]);
		button->getEventClicked().connect(this, &MaskPaintSample::brush_texture_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Mask");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	gridbox = WidgetGridBox::create(6);
	parameters->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_masks.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_masks_icons[i]);
		button->getEventClicked().connect(this, &MaskPaintSample::brush_mask_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Size");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	brush_size_edit_line = WidgetEditLine::create();
	brush_size_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(brush_size_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Spacing");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	brush_spacing_edit_line = WidgetEditLine::create();
	brush_spacing_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(brush_spacing_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Angle");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	brush_angle_edit_line = WidgetEditLine::create();
	brush_angle_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(brush_angle_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Opacity");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	brush_opacity_edit_line = WidgetEditLine::create();
	brush_opacity_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(brush_opacity_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);

	label = WidgetLabel::create("Mask Value");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	brush_mask_value_edit_line = WidgetEditLine::create();
	brush_mask_value_edit_line->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(brush_mask_value_edit_line, Gui::ALIGN_LEFT);
}

void MaskPaintSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void MaskPaintSample::brush_texture_button_callback(int index)
{
	set_brush_texture(brush_textures[index]);
}

void MaskPaintSample::brush_mask_button_callback(int index)
{
	set_brush_mask(brush_masks[index]);
}

void MaskPaintSample::brush_size_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = max(String::atof(checked_ptr_cast<WidgetEditLine>(widget)->getText()), 0.1f);
	set_brush_size(value, true);
}

void MaskPaintSample::brush_spacing_edit_line_callback(const WidgetPtr &widget)
{
	float value = String::atof(checked_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_spacing(value, false);
}

void MaskPaintSample::brush_angle_edit_line_callback(const WidgetPtr &widget)
{
	float value = String::atof(checked_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_angle(value, false);
}

void MaskPaintSample::brush_opacity_edit_line_callback(const WidgetPtr &widget)
{
	float value = String::atof(checked_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_opacity(value, false);
}

void MaskPaintSample::brush_mask_value_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText()) / 255.0f;
	set_brush_color({value, brush_color.y, brush_color.z, brush_color.w}, true);
}

```

## MaterialAnimationSample.cpp

```cpp
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class MaterialAnimationSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(MaterialAnimationSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		create_animations();

		// create object for animation
		box = Primitives::createBox(vec3(1.0f, 1.0f, 1.0f));
		box->setID(123);
		box->setName("box");
		box->setWorldPosition(Vec3(0.f, 0.f, 1.15f));

		// assign a material containing the "emission_scale" and "emission_color" parameters
		MaterialPtr mat = Materials::findMaterialByPath(joinPaths(getWorldRootPath(), "materials", "emission_mat.mat"));
		box->setMaterial(mat, "*");

		playback->play();

		gui.init(this);
	}

	void update()
	{
		gui.update();
	}

	void shutdown()
	{
		gui.shutdown();

		playback->stop();
	}

	void create_animations()
	{
		// get the index of the emission_scale parameter in our material
		MaterialPtr mat = Materials::findMaterialByPath(joinPaths(getWorldRootPath(), "materials", "emission_mat.mat"));
		int emission_scale_index = mat->findParameter("emission_scale");

		// create new track
		AnimationTrackPtr track = AnimationTrack::create();

		// create material animation object and add it to track
		AnimationObjectMaterialPtr anim_obj = AnimationObjectMaterial::create("mat");
		track->addObject(anim_obj);

		AnimationBindMaterialPtr bind = anim_obj->getBind();

		if (1) // bind the animation object to our object
		{
			bind->setAccess(AnimationBindMaterial::ACCESS_FROM_SURFACE);
			bind->setSurfaceDescription("dynamic", 0);
			bind->setObjectDescription(123, "box");
		}

		else // alternatively we can bind it to the material itself
		{
			bind->setAccess(AnimationBindMaterial::ACCESS_FROM_ASSET);
			bind->setMaterialDescription(mat->getGUID(), FileSystem::getGUID(joinPaths(getWorldRootPath(), "materials", "emission_mat.mat")));
		}

		anim_obj->setBind(bind);

		// animate emission scale by index
		auto scale_modifier = AnimationModifierFloat::create("material.parameter_float_indexed", emission_scale_index);
		scale_modifier->addValue(0.0f, 0.0f);
		scale_modifier->addValue(6.0f, 1.0f);
		scale_modifier->addValue(12.0f, 0.0f);
		track->addObjectModifier(anim_obj, scale_modifier);

		// animate emission color by name
		auto color_modifier = AnimationModifierFVec4::create("material.parameter_float4_named", "emission_color");
		color_modifier->addValue(0.0f, vec4_red);
		color_modifier->addValue(4.0f, vec4_green);
		color_modifier->addValue(8.0f, vec4_blue);
		color_modifier->addValue(12.0f, vec4_red);
		track->addObjectModifier(anim_obj, color_modifier);

		// create playback for track
		playback = AnimationPlayback::create();
		playback->setTrack(track);
		playback->setLoop(true);
	}

	// ========================================================================================

	struct SampleGui
	{
		void init(MaterialAnimationSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			auto w = sample_description_window.getWindow();
			auto state_gbox = WidgetGroupBox::create("State", 9, 3);
			w->addChild(state_gbox);

			auto gridbox = WidgetGridBox::create(2);
			state_gbox->addChild(gridbox, Gui::ALIGN_LEFT);

			auto add_parameter = [](const WidgetGridBoxPtr &gridbox, const char *name) {
				auto hbox = WidgetHBox::create();

				hbox->addChild(WidgetLabel::create(name));
				hbox->addChild(WidgetHBox::create(6));

				gridbox->addChild(hbox, Gui::ALIGN_LEFT);

				auto bg_color = WidgetEditLine::create();
				bg_color->setEditable(false);
				bg_color->setFontVOffset(-2);
				bg_color->setFontColor(vec4(vec3(.9f), 1.f));
				bg_color->setWidth(50);

				gridbox->addChild(bg_color, Gui::ALIGN_LEFT);
				return bg_color;
			};

			emission_scale = add_parameter(gridbox, "emission_scale");
			emission_color_r = add_parameter(gridbox, "emission_color.r");
			emission_color_g = add_parameter(gridbox, "emission_color.g");
			emission_color_b = add_parameter(gridbox, "emission_color.b");
		}

		void update()
		{
			auto material = sample->box->getMaterial(0);

			if (material)
			{
				emission_scale->setText(String::format("%.2f", material->getParameterFloat("emission_scale")));

				auto color = material->getParameterFloat4("emission_color");
				emission_color_r->setText(String::format("%.2f", color.x));
				emission_color_g->setText(String::format("%.2f", color.y));
				emission_color_b->setText(String::format("%.2f", color.z));
			}
		}

		void shutdown() { sample_description_window.shutdown(); }

		MaterialAnimationSample *sample = nullptr;
		SampleDescriptionWindow sample_description_window;
		WidgetEditLinePtr emission_scale;
		WidgetEditLinePtr emission_color_r;
		WidgetEditLinePtr emission_color_g;
		WidgetEditLinePtr emission_color_b;
	};

	AnimationPlaybackPtr playback;
	ObjectPtr box;
	SampleGui gui;
};

REGISTER_COMPONENT(MaterialAnimationSample);

```

## MaterialsAndPropertiesSample.cpp

```cpp
#include "MaterialsAndPropertiesSample.h"

#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(MaterialsAndPropertiesSample)

void MaterialsAndPropertiesSample::sample()
{
	Console::setOnscreen(true);
	Console::setOnscreenHeight(100);

	// properties
	{
		// property manager info
		Log::message("Properties:\n");
		for (int j = 0; j < Properties::getNumProperties(); j++)
		{
			PropertyPtr property = Properties::getProperty(j);

			// property info
			Log::message("Property: %s (%d children)\n", property->getName(),
				property->getNumChildren());
		}
	}

	Log::message("\n");

	// materials
	{
		// material library info
		Log::message("Materials: %d\n", Materials::getNumMaterials());

		for (int i = 0; i < Materials::getNumMaterials(); i++)
		{
			MaterialPtr material = Materials::getMaterial(i);

			// material info
			Log::message("\t%asset: materials: %d\n", material->getFilePath().get(),
				material->getNumChildren());
		}
	}
}


void MaterialsAndPropertiesSample::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## Math.cpp

```cpp
#include "Math.h"

using namespace Unigine;
using namespace Math;

namespace {
	float get_t(float t, float alpha, const Vec3& p0, const Vec3& p1)
	{
		auto d = p1 - p0;
		float a = (float)dot(d, d);
		float b = powf(a, alpha * .5f);
		return (b + t);
	}
}

Vec3 Utils::catmullRomCentripetal(const Vec3& p0, const Vec3& p1, const Vec3& p2, const Vec3& p3, float t /* between 0 and 1 */, float alpha/* between 0 and 1 */)
{
	float t0 = 0.0f;
	float t1 = get_t(t0, alpha, p0, p1);
	float t2 = get_t(t1, alpha, p1, p2);
	float t3 = get_t(t2, alpha, p2, p3);
	t = lerp(t1, t2, t);
	Vec3 A1 = p0 * ((t1 - t) / (t1 - t0)) + p1 * ((t - t0) / (t1 - t0));
	Vec3 A2 = p1 * ((t2 - t) / (t2 - t1)) + p2 * ((t - t1) / (t2 - t1));
	Vec3 A3 = p2 * ((t3 - t) / (t3 - t2)) + p3 * ((t - t2) / (t3 - t2));
	Vec3 B1 = A1 * ((t2 - t) / (t2 - t0)) + A2 * ((t - t0) / (t2 - t0));
	Vec3 B2 = A2 * ((t3 - t) / (t3 - t1)) + A3 * ((t - t1) / (t3 - t1));
	Vec3 C = B1 * ((t2 - t) / (t2 - t1)) + B2 * ((t - t1) / (t2 - t1));
	return C;
}

Vector<float> Utils::getLengthCatmullRomCentripetal(const Vec3& p0, const Vec3& p1, const Vec3& p2, const Vec3& p3, int subdivisions)
{
	Vector<float> res;
	Vec3 start = Utils::catmullRomCentripetal(p0, p1, p2, p3, 0);
	for (int i = 1; i < subdivisions; i++)
	{
		Vec3 end = Utils::catmullRomCentripetal(p0, p1, p2, p3, float(i) / (subdivisions - 1));
		res.emplace_back(float(length(end - start)));
		start = end;
	}
	return res;
}

Vec3 Utils::catmullRomUniform(const Vec3& p0, const Vec3& p1, const Vec3& p2, const Vec3& p3, float t)
{
	Vec3 a = p1 * 2.0f;
	Vec3 b = p2 - p0;
	Vec3 c = p0 * 2.0f - p1 * 5.0f + p2 * 4.0f - p3;
	Vec3 d = -p0 + p1 * 3.0f - p2 * 3.0f + p3;
	return (a + b * t + c * t * t + d * t * t * t) * 0.5f;
}

Vector<float> Utils::getLengthCatmullRomUniform(const Vec3& p0, const Vec3& p1, const Vec3& p2, const Vec3& p3, int subdivisions)
{
	Vector<float> res;
	Vec3 start = catmullRomUniform(p0, p1, p2, p3, 0);
	for (int i = 1; i < subdivisions; i++)
	{
		Vec3 end = catmullRomUniform(p0, p1, p2, p3, float(i) / (subdivisions - 1));
		res.emplace_back(float(length(end - start)));
		start = end;
	}
	return res;
}

quat Utils::squad(const quat &q0, const quat &q1, const quat &q2, const quat &q3, float t)
{
	auto qexp = [](const quat &q) {
		float a = Math::fsqrt(q.x * q.x + q.y * q.y + q.z * q.z);
		float sin_a = Math::sin(a);
		vec4 r;
		r.w = Math::cos(a);
		if (Math::abs(sin_a) >= 1.0e-15)
		{
			float coeff = sin_a / a;
			r.x = q.x * coeff;
			r.y = q.y * coeff;
			r.z = q.z * coeff;
		}
		return quat(r);
	};
	auto qlog = [](const quat &q) {
		float a = Math::acos(q.w);
		float sin_a = Math::sin(a);
		if (Math::abs(sin_a) >= 1.0e-15)
		{
			float coeff = a / sin_a;
			vec4 r = vec4(q.x * coeff, q.y * coeff, q.z * coeff, 0);
			return quat(r);
		}
		return quat(vec4_zero);
	};
	auto slerp_no_invert = [](const quat &q0, const quat &q1, float t) {
		float d = dot(q0, q1);
		if (Math::abs(d) > 0.9999f)
			return q0;

		float theta = Math::acos(d);
		float sin_t = 1.0f / Math::sin(theta);
		float t0 = Math::sin((1.0f - t) * theta) * sin_t;
		float t1 = Math::sin(t * theta) * sin_t;
		return (q0 * t0 + q1 * t1); //.normalizeValid();
	};

	// modify quaternions for shortest path
	auto get_length = [](const quat &q) {
		return Math::fsqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
	};
	quat q0m = get_length(q1 - q0) < get_length(q1 + q0) ? q0 : -q0;
	quat q2m = get_length(q1 - q2) < get_length(q1 + q2) ? q2 : -q2;
	quat q3m = get_length(q2m - q3) < get_length(q2m + q3) ? q3 : -q3;

	// calculate helper quaternions (tangent values)
	// https://www.geometrictools.com/Documentation/Quaternions.pdf (page 9 [31])
	quat q1inv = inverse(q1);
	quat q2inv = inverse(q2m);
	quat a = (q1 * qexp((qlog(q1inv * q2m) + qlog(q1inv * q0m)) * -0.25f));
	quat b = (q2m * qexp((qlog(q2inv * q3m) + qlog(q2inv * q1)) * -0.25f));

	return slerp(slerp(q1, q2m, t), slerp(a, b, t), 2.0f * t * (1.0f - t)).normalizeValid();
}

float Utils::mapRange(float input, float in_min, float in_max, float out_min, float out_max,
	bool clamp)
{
	if (in_min == in_max)
		return out_min;

	if (clamp)
	{
		float lower_bound = Unigine::Math::min(in_min, in_max);
		float upper_bound = Unigine::Math::max(in_min, in_max);
		input = Unigine::Math::clamp(input, lower_bound, upper_bound);
	}

	float normalized = (input - in_min) / (in_max - in_min);

	return normalized * (out_max - out_min) + out_min;
}
```

## MathTriggerComponent.cpp

```cpp
#include "MathTriggerComponent.h"

#include <UnigineConsole.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(WorldMathTrigger);

using namespace Unigine;
using namespace Math;

void WorldMathTrigger::init()
{
	Vec3 translation = node->getWorldTransform().getTranslate();
	Vec3 coordinates_for_bound_box_min = -Vec3(bound_box_size / 2.0f);
	Vec3 coordinates_for_bound_box_max = Vec3(bound_box_size / 2.0f);
	bound_box.set(vec3(coordinates_for_bound_box_min), vec3(coordinates_for_bound_box_max));
	bound_box.setTransform(node->getWorldTransform());

	bound_sphere.set(vec3(translation), bound_sphere_size.get() / 2.0f);
	bound_sphere.setTransform(node->getWorldTransform());
}


void WorldMathTrigger::update()
{
	replace_bounds();

	if (debug)
	{
		visualize_bounds();
	}
	check_entered();
	check_leave();
}


void WorldMathTrigger::check_leave()
{
	for (const auto &obj : objects)
	{
		if (!entered.contains(obj))
			continue;
		if (obj.isDeleted())
		{
			entered.removeOneFast(obj);
			continue;
		}
		bool is_inside = is_sphere ? check_sphere(obj) : check_box(obj);
		if (!is_inside)
		{
			entered.removeOneFast(obj);
			if (is_callback(CALLBACK_TRIGGER_LEAVE))
				run_callback(CALLBACK_TRIGGER_LEAVE, obj);
		}
	}
}

void WorldMathTrigger::replace_bounds()
{
	Vec3 translation = node->getWorldTransform().getTranslate();
	Vec3 coordinates_for_bound_box_min = -Vec3(bound_box_size / 2.0f) + translation;
	Vec3 coordinates_for_bound_box_max = Vec3(bound_box_size / 2.0f) + translation;
	bound_box.set(vec3(coordinates_for_bound_box_min), vec3(coordinates_for_bound_box_max));
	bound_sphere.set(vec3(translation), bound_sphere_size.get() / 2.0f);
}

void WorldMathTrigger::visualize_bounds()
{
	if (is_sphere)
		Visualizer::renderSphere(bound_sphere_size / 2.0f, node->getWorldTransform(), vec4_red);
	else
		Visualizer::renderBoundBox(bound_box, Mat4_identity, vec4_red);
}


void WorldMathTrigger::check_entered()
{
	for (const auto &obj : objects)
	{
		if (entered.contains(obj))
			continue;
		bool is_inside = is_sphere ? check_sphere(obj) : check_box(obj);
		if (is_inside)
		{
			entered.push_back(obj);
			if (is_callback(CALLBACK_TRIGGER_ENTER))
				run_callback(CALLBACK_TRIGGER_ENTER, obj);
		}
	}
}


inline bool WorldMathTrigger::check_box(const NodePtr &obj) const
{
	return bound_box.insideValid(vec3(obj->getTransform().getTranslate()));
}


inline bool WorldMathTrigger::check_sphere(const NodePtr &obj) const
{
	return bound_sphere.insideValid(vec3(obj->getTransform().getTranslate()));
}


void *WorldMathTrigger::addCallback(CALLBACK_TRIGGER callback, CallbackBase1<NodePtr> *func)
{
	return signal[callback].add(func);
}


bool WorldMathTrigger::removeCallback(CALLBACK_TRIGGER callback, void *id)
{
	return signal[callback].remove(id);
}


void WorldMathTrigger::clearCallbacks(CALLBACK_TRIGGER callback)
{
	signal[callback].clear();
}


inline bool WorldMathTrigger::is_callback(CALLBACK_TRIGGER callback) const
{
	return signal[callback].size() > 0 ? true : false;
}


inline void WorldMathTrigger::run_callback(CALLBACK_TRIGGER callback, const NodePtr &obj)
{
	signal[callback].invoke(obj);
}


void WorldMathTrigger::shutdown()
{
	for (int i = 0; i < CALLBACK_TRIGGER_NUM; i++)
	{
		signal[i].clear();
	}
}

void WorldMathTrigger::addObject(const Unigine::NodePtr &obj)
{
	objects.push_back(obj);
}

void WorldMathTrigger::addObjects(const Unigine::Vector<Unigine::NodePtr> &input_objects)
{
	objects.append(input_objects);
	;
}

void WorldMathTrigger::removeObject(const Unigine::NodePtr &obj)
{
	auto it = objects.find(obj);
	if (it != objects.end())
		objects.remove(it);
}


// World Intersection Trigger Component

REGISTER_COMPONENT(WorldIntersectionTrigger);

void WorldIntersectionTrigger::init()
{
	Vec3 translation = node->getWorldTransform().getTranslate();
	Vec3 coordinates_for_bound_box_min = -Vec3(bound_box_size / 2.0f) + translation;
	Vec3 coordinates_for_bound_box_max = Vec3(bound_box_size / 2.0f) + translation;
	bound_box.set(vec3(coordinates_for_bound_box_min), vec3(coordinates_for_bound_box_max));
	bound_sphere.set(vec3(translation), bound_sphere_size.get() / 2.0f);
}

void WorldIntersectionTrigger::update()
{
	replace_bounds();

	if (debug)
	{
		visualize_bounds();
	}

	get_inside_nodes();
	check_entered();
	check_leave();
}

void WorldIntersectionTrigger::shutdown()
{
	for (int i = 0; i < CALLBACK_TRIGGER_NUM; i++)
	{
		signal[i].clear();
	}
}

void WorldIntersectionTrigger::check_entered()
{

	for (const auto &it : inside)
	{
		if (entered.find(it) == entered.end())
		{
			entered.push_back(it);
			run_callback(CALLBACK_TRIGGER_ENTER, it);
		}
	}
}

void WorldIntersectionTrigger::check_leave()
{

	for (const auto &it : entered)
	{
		if (it.isDeleted())
			entered.removeOneFast(it);

		if (inside.find(it) == inside.end())
		{
			run_callback(CALLBACK_TRIGGER_LEAVE, it);
			entered.removeOneFast(it);
		}
	}
}

void WorldIntersectionTrigger::replace_bounds()
{
	Vec3 translation = node->getWorldTransform().getTranslate();
	Vec3 coordinates_for_bound_box_min = -Vec3(bound_box_size / 2.0f) + translation;
	Vec3 coordinates_for_bound_box_max = Vec3(bound_box_size / 2.0f) + translation;
	bound_box.set(vec3(coordinates_for_bound_box_min), vec3(coordinates_for_bound_box_max));
	bound_sphere.set(vec3(translation), bound_sphere_size.get() / 2.0f);
}

void WorldIntersectionTrigger::visualize_bounds()
{
	if (is_sphere)
		Visualizer::renderSphere(bound_sphere_size / 2.0f, node->getWorldTransform(), vec4_red);
	else
		Visualizer::renderBoundBox(bound_box, Mat4_identity, vec4_red);
}

void WorldIntersectionTrigger::get_inside_nodes()
{
	if (is_sphere)
		World::getIntersection(bound_sphere, inside);
	else
		World::getIntersection(bound_box, inside);
}


void *WorldIntersectionTrigger::addCallback(CALLBACK_TRIGGER callback, CallbackBase1<NodePtr> *func)
{
	return signal[callback].add(func);
}


bool WorldIntersectionTrigger::removeCallback(CALLBACK_TRIGGER callback, void *id)
{
	return signal[callback].remove(id);
}


void WorldIntersectionTrigger::clearCallbacks(CALLBACK_TRIGGER callback)
{
	signal[callback].clear();
}


inline bool WorldIntersectionTrigger::is_callback(CALLBACK_TRIGGER callback) const
{
	return signal[callback].size() > 0 ? true : false;
}


inline void WorldIntersectionTrigger::run_callback(CALLBACK_TRIGGER callback, const NodePtr &obj)
{
	signal[callback].invoke(obj);
}

```

## Menu.cpp

```cpp
#include "Menu.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(Menu);

using namespace Unigine;
using namespace Math;

void Menu::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_menubar = WidgetMenuBar::create(gui);

	gui->addChild(widget_menubar, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_menubar->setPosition(position.get().x, position.get().y);
	widget_menubar->setFontSize(font_size.get());
	widget_menubar->setFontOutline(1);
	widget_menubar->setSelectionColor(selection_color.get());
	widget_menubar->addItem("File 0");
	widget_menubar->addItem("File 1");
	widget_menubar->addItem("File 2");

	// add file menubox
	WidgetMenuBoxPtr file_menu_box = WidgetMenuBox::create(gui);
	file_menu_box->setFontSize(font_size.get());
	file_menu_box->setFontOutline(1);
	file_menu_box->addItem("File 0");
	file_menu_box->addItem("File 1");
	file_menu_box->addItem("File 2");
	widget_menubar->setItemMenu(0, file_menu_box);

	file_menu_box->getEventClicked().connect(*this, [file_menu_box](){
		String msg = String("Menu: ") + file_menu_box->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	// add edit menubox
	WidgetMenuBoxPtr edit_menu_box = WidgetMenuBox::create(gui);
	edit_menu_box->setFontSize(font_size.get());
	edit_menu_box->setFontOutline(1);
	edit_menu_box->addItem("Edit 0");
	edit_menu_box->addItem("Edit 1");
	edit_menu_box->addItem("Edit 2");
	widget_menubar->setItemMenu(1, edit_menu_box);

	edit_menu_box->getEventClicked().connect(*this, [edit_menu_box](){
		String msg = String("Menu: ") + edit_menu_box->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	// add help menubox
	WidgetMenuBoxPtr help_menu_box = WidgetMenuBox::create(gui);
	help_menu_box->setFontSize(font_size.get());
	help_menu_box->setFontOutline(1);
	help_menu_box->addItem("Help 0");
	help_menu_box->addItem("Help 1");
	help_menu_box->addItem("Help 2");
	widget_menubar->setItemMenu(2, help_menu_box);

	help_menu_box->getEventClicked().connect(*this, [help_menu_box](){
		String msg = String("Menu: ") + help_menu_box->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void Menu::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_menubar);

		widget_menubar.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## MeshDigger.cpp

```cpp
#include "MeshDigger.h"

#include <UnigineAsyncQueue.h>
#include <UnigineGame.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(MeshDigger)


void MeshDigger::init()
{
	// check the minimum values of field_size and marching_cube_size
	if (field_size < 4)
		field_size = 4;
	marching_cube_size = clamp(marching_cube_size, 0.05f, 1.f);

	// check if the ground material exists and set mesh_height parameter to ensure correct texture clamping
	if (!mat.get())
		Log::error("MeshDigger::init(): set Ground Material!\n");
	else
		mat->setParameterFloat("mesh_height", field_size * marching_cube_size);

	marching_cubes = new AsyncMarchingCubes(field_size, marching_cube_size);
	marching_cubes->setMaterial(mat.get());

	// get the object created in the AsyncMarchingCubes() method to check for intersections
	ground_object = marching_cubes->getObject();
	ground_itransform = ground_object->getIWorldTransform();

	Visualizer::setEnabled(true);

	samples_description_window.createWindow();
	samples_description_window.addFloatParameter("Digging Radius", "Radius in marching cubes units",
		digging_radius, 1.f, 30.f, [this](float value) { digging_radius = value; });
}

void MeshDigger::update()
{
	marching_cubes->update();

	auto w = Gui::getCurrent()->getUnderCursorWidget();
	if (w && w->getType() != Widget::WIDGET_ENGINE)
		return;

	// perform an intersection check at the current mouse cursor position
	ivec2 mouse = Input::getMousePosition();
	Vec3 p0 = Game::getPlayer()->getWorldPosition();
	Vec3 p1 = p0 + Vec3(Game::getPlayer()->getDirectionFromMainWindow(mouse.x, mouse.y)) * 100.f;

	// check for an intersection with the ground object
	ObjectPtr obj = World::getIntersection(p0, p1, ~0, intersection);
	if (obj && obj == ground_object)
	{
		// try digging the mesh when the left mouse button is clicked
		if (Input::isMouseButtonDown(Input::MOUSE_BUTTON::MOUSE_BUTTON_LEFT))
		{
			// convert the intersection point coordinates from world space to Marching Cubes coordinates
			auto pos = ground_itransform * intersection->getPoint();
			pos = pos / marching_cube_size;

			AsyncMarchingCubes::BrushSphere sphere;
			sphere.pos = vec3(pos);
			sphere.radius = digging_radius;
			sphere.k = Input::isKeyPressed(Input::KEY_ANY_CTRL) ? 1 : -1;
			marching_cubes->addBrush(sphere);
		}
		Visualizer::renderSphere(digging_radius * marching_cube_size,
			translate(intersection->getPoint()), vec4_blue);
	}
}

void MeshDigger::shutdown()
{
	delete marching_cubes;
	marching_cubes = nullptr;
	ground_object = nullptr;

	Visualizer::setEnabled(false);
	samples_description_window.shutdown();
}


AsyncMarchingCubes::AsyncMarchingCubes(int num_cubes, float cube_edge)
{
	create(num_cubes, cube_edge);
}

void AsyncMarchingCubes::create(int num_cubes, float cube_edge)
{
	destroy();
	is_deleted = false;

	noise.setSeed(Time::get());

	size = num_cubes;
	size2 = size * size;
	cube_edge_length = cube_edge;

	object = ObjectMeshStatic::create();
	object->setMeshProceduralMode(ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC);

	// place the ground object at the center of the world
	float object_offset = num_cubes * cube_edge_length * 0.5f;
	object->setWorldPosition(Vec3(-object_offset));

	field = Image::create();
	field->create3D(size, size, size + 1, Image::FORMAT_R32F);

	// generate voxel field data
	create_field();

	run(true);
}

void AsyncMarchingCubes::destroy()
{
	is_running.waitValue(false);
	is_deleted = true;

	size = 0;

	object.deleteLater();
	field.clear();
	actions.clear();
	async_actions.clear();
}

void AsyncMarchingCubes::update()
{
	run();
}

void AsyncMarchingCubes::run(bool force)
{
	if (object->isMeshProceduralActive() || (actions.empty() && !force))
		return;

	is_running = true;

	// pass all previously saved actions to apply in an async thread
	async_actions.swap(actions);
	actions.clear();

	// update the mesh asynchronously in a separated thread
	object->runGenerateMeshProceduralAsync(MakeCallback(this, &AsyncMarchingCubes::update_ram),
		MakeCallback(this, &AsyncMarchingCubes::update_ram_done), MeshRender::USAGE_DYNAMIC_ALL);
}

void AsyncMarchingCubes::create_field()
{
	float *field_data = (float *)field->getPixels();

	for (int y = 0; y < size; y++)
	{
		for (int x = 0; x < size; x++)
		{
			// scale coordinates for noise generation
			float scale = 10.0f;
			const vec2 p2D = vec2(x, y) / size * scale;

			// noise generated height value in range [0.f, 1.f]
			float h = clamp(noise.get2D(p2D.x, p2D.y), -0.5f, 0.5f);
			h = saturate(h * 0.5f + 0.5f);

			for (int z = 0; z < size; z++)
			{
				// normalized voxel's z-position
				float v = 1.0f - float(z) / size;

				int id = z * size * size + y * size + x;

				// calculate voxel height value. where 1.0f corresponds to the top and -1.f - to the bottom
				field_data[id] = clamp(v * 6.0f - h, -1.0f, 1.0f);
			}
			int id = size * size * size + y * size + x;
			field_data[id] = -1.f;
		}
	}
}

void AsyncMarchingCubes::marching_cubes(MeshPtr mesh) const
{
	if (mesh->getNumSurfaces() <= 0)
	{
		mesh->clear();
		mesh->addSurface("");
	}
	else
	{
		mesh->clearSurface();
	}

	float *field_data = (float *)field->getPixels();

	// get mesh data
	auto &vertices = mesh->getVertices();
	auto &tangents = mesh->getTangents();
	auto &cindices = mesh->getCIndices();
	auto &tindices = mesh->getTIndices();

	HashMap<unsigned long long, int> vertex_hash;
	vertex_hash.clear();

	const float d = 1.0f / (float)size;
	const vec3 o100(d, 0, 0);
	const vec3 o010(0, d, 0);
	const vec3 o001(0, 0, d);

	vec4 field_03;
	vec4 field_47;
	vec3 vertex[12];

	// create a mesh using the Marching Cubes algorithm
	for (int z = 0; z <= size - 1; z++)
	{
		for (int y = 0; y < size - 1; y++)
		{
			for (int x = 0; x < size - 1; x++)
			{
				int id = z * size2 + y * size + x;
				field_03.x = field_data[id + 0];
				field_03.y = field_data[id + 1];
				field_03.w = field_data[id + size + 0];
				field_03.z = field_data[id + size + 1];

				id += size2;
				field_47.x = field_data[id + 0];
				field_47.y = field_data[id + 1];
				field_47.w = field_data[id + size + 0];
				field_47.z = field_data[id + size + 1];

				int index = int(field_03.x > 0) + int(field_03.y > 0) * 2 + int(field_03.z > 0) * 4
					+ int(field_03.w > 0) * 8;

				index |= int(field_47.x > 0) * 16 + int(field_47.y > 0) * 32
					+ int(field_47.z > 0) * 64 + int(field_47.w > 0) * 128;

				if (index == 0 || index == 255)
					continue;

				short edges = marching_cubes_edges[index];
				if (edges & 0x00f)
				{
					vec4 k = field_03 / (field_03 - yzwx(field_03));
					if (edges & 0x001)
						lerp(vertex[0], cell_0, cell_1, k.x);
					if (edges & 0x002)
						lerp(vertex[1], cell_1, cell_2, k.y);
					if (edges & 0x004)
						lerp(vertex[2], cell_2, cell_3, k.z);
					if (edges & 0x008)
						lerp(vertex[3], cell_3, cell_0, k.w);
				}
				if (edges & 0x0f0)
				{
					vec4 k = field_47 / (field_47 - yzwx(field_47));
					if (edges & 0x010)
						lerp(vertex[4], cell_4, cell_5, k.x);
					if (edges & 0x020)
						lerp(vertex[5], cell_5, cell_6, k.y);
					if (edges & 0x040)
						lerp(vertex[6], cell_6, cell_7, k.z);
					if (edges & 0x080)
						lerp(vertex[7], cell_7, cell_4, k.w);
				}
				if (edges & 0xf00)
				{
					vec4 k = field_03 / (field_03 - field_47);
					if (edges & 0x100)
						lerp(vertex[8], cell_0, cell_4, k.x);
					if (edges & 0x200)
						lerp(vertex[9], cell_1, cell_5, k.y);
					if (edges & 0x400)
						lerp(vertex[10], cell_2, cell_6, k.z);
					if (edges & 0x800)
						lerp(vertex[11], cell_3, cell_7, k.w);
				}
				vec3 xyz(x, y, z);

				for (index = index * 16; marching_cubes_triangles[index] != -1; index += 3)
				{
					auto add_vertex = [&](const vec3 &p) {
						unsigned long long hash = p.hash64();

						auto it = vertex_hash.find(hash);
						if (it != vertex_hash.end())
						{
							cindices.append(it->data);
						}
						else
						{
							vec3 uvw = p * d;

							vec3 N;
							N.x = field->get3D(uvw - o100 * 0.5f).f.r
								- field->get3D(uvw + o100 * 0.5f).f.r;
							N.y = field->get3D(uvw - o010 * 0.5f).f.r
								- field->get3D(uvw + o010 * 0.5f).f.r;
							N.z = field->get3D(uvw - o001 * 0.5f).f.r
								- field->get3D(uvw + o001 * 0.5f).f.r;
							N.normalizeFast();

							vec3 T(N.z, 0.0f, -N.x);
							T = T - N * dot(T, N);
							T.normalizeFast();
							quat q;
							q.set(T, cross(N, T), N);

							vertex_hash.append(hash, vertices.size());
							cindices.append(vertices.size());
							vertices.append(p * cube_edge_length);
							tangents.append(q);
						}
					};

					add_vertex(vertex[marching_cubes_triangles[index + 2]] + xyz);
					add_vertex(vertex[marching_cubes_triangles[index + 1]] + xyz);
					add_vertex(vertex[marching_cubes_triangles[index + 0]] + xyz);
				}
			}
		}
	}

	tindices = cindices;

	// create collision data for effective intersection and collision detection
	mesh->clearCollisionData();
	mesh->createCollisionData();
	mesh->createBounds();
}

void AsyncMarchingCubes::brush_field()
{
	for (auto action : async_actions)
		add_sphere(action.pos, action.radius, action.k);
	async_actions.clear();
}

void AsyncMarchingCubes::add_sphere(vec3 pos, float radius, float k)
{
	float *field_data = (float *)field->getPixels();

	// define the bounds of affected voxels
	ivec3 min_pos = ivec3(max(floor(pos - radius), vec3_zero));
	ivec3 max_pos = ivec3(min(ceil(pos + radius), vec3(size - 1)));

	// find affected voxels and adjust their height
	for (int z = min_pos.z; z <= max_pos.z; z++)
	{
		for (int y = min_pos.y; y <= max_pos.y; y++)
		{
			for (int x = min_pos.x; x <= max_pos.x; x++)
			{
				vec3 vox_coord(x, y, z);
				float dist = distance2(vox_coord, pos);
				if (dist > radius * radius)
					continue;

				int id = z * size * size + y * size + x;
				float value = (saturate(1.0f - sqrt(dist) / radius)) * k;

				// update field value
				field_data[id] = clamp(field_data[id] + value, -1.0f, 1.0f);
			}
		}
	}
}

void AsyncMarchingCubes::update_ram(MeshPtr mesh)
{
	brush_field();
	marching_cubes(mesh);

	is_running = false;
}

void AsyncMarchingCubes::update_ram_done()
{
	if (is_deleted)
		return;

	if (object && object->getNumSurfaces() > 0)
	{
		object->setIntersection(true, 0);
		object->setIntersectionMask(~0, 0);
		object->setCollision(true, 0);
		object->setCollisionMask(~0, 0);
		object->setMaterial(material, 0);
	}
}

const short AsyncMarchingCubes::marching_cubes_edges[] = {0x000, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605,
												 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x099, 0x393, 0x29a,
												 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230,
												 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33,
												 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af,
												 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c,
												 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6,
												 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759,
												 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859,
												 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6,
												 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc,
												 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f,
												 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3,
												 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
												 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a,
												 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5,
												 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35,
												 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a,
												 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, 0xf00,
												 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203,
												 0x109, 0x000};

const char AsyncMarchingCubes::marching_cubes_triangles[] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,
	3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,
	3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,
	8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,
	3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,
	9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
	9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,
	10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,
	9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,
	7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
	9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
	1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,
	2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,
	6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
	5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,
	6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,
	3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,
	8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
	10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
	1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
	10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,
	9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,
	8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,
	10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,
	7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
	10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,
	6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,
	6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,
	8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
	8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,
	9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,
	7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,
	9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,
	6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,
	5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,
	11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
	2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,
	1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,
	2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
	8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,
	4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,
	2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

const vec3 AsyncMarchingCubes::cell_0{0.0f, 0.0f, 0.0f};
const vec3 AsyncMarchingCubes::cell_1{1.0f, 0.0f, 0.0f};
const vec3 AsyncMarchingCubes::cell_2{1.0f, 1.0f, 0.0f};
const vec3 AsyncMarchingCubes::cell_3{0.0f, 1.0f, 0.0f};
const vec3 AsyncMarchingCubes::cell_4{0.0f, 0.0f, 1.0f};
const vec3 AsyncMarchingCubes::cell_5{1.0f, 0.0f, 1.0f};
const vec3 AsyncMarchingCubes::cell_6{1.0f, 1.0f, 1.0f};
const vec3 AsyncMarchingCubes::cell_7{0.0f, 1.0f, 1.0f};

```

## MicroprofilerSample.cpp

```cpp
#include "MicroprofilerSample.h"
#include "UnigineEngine.h"
#include "UnigineWindowManager.h"
#include <UnigineProfiler.h>

REGISTER_COMPONENT(MicroprofilerSample);

using namespace Unigine;

void MicroprofilerSample::init()
{
	StringStack<> description = "";
	if (String(Profiler::getMicroprofileUrl()) == "")
	{
		WindowManager::dialogError("Warning", "Microprofiler is not available!");
		description = "<font color=\"#de4a14\"><p>Microprofiler is not compiled.</p>"
					  "<p>Use development-release binaries.</p></font>";
	}
	else
	{
		description = String::format("<p>Microprofiler url - <font color=\"#de4a14\">%s</font></p>",
			Profiler::getMicroprofileUrl());
	}

	sample_description_window.createWindow();
	
	const auto& parameterGB = sample_description_window.getParameterGroupBox();
	auto label = WidgetLabel::create(description);
	label->setFontRich(1);
	parameterGB->addChild(label);

	previous_bg_update = Engine::get()->getBackgroundUpdate();
	Engine::get()->setBackgroundUpdate(Unigine::Engine::BACKGROUND_UPDATE_RENDER_NON_MINIMIZED);
}

void MicroprofilerSample::shutdown()
{
	Engine::get()->setBackgroundUpdate(previous_bg_update);
	sample_description_window.shutdown();
}

```

## MicroprofilerSleepyNode.cpp

```cpp
#include "MicroprofilerSleepyNode.h"
#include <UnigineProfiler.h>

REGISTER_COMPONENT(MicroprofilerSleepyNode);

using namespace Unigine;

void MicroprofilerSleepyNode::init()
{
	UNIGINE_PROFILER_FUNCTION;
	sleepFor(1);
}

void MicroprofilerSleepyNode::updateAsyncThread()
{
	int id = Profiler::beginMicro(__FUNCTION__);
	sleepFor(2);
	Profiler::endMicro(id);
}

void MicroprofilerSleepyNode::updateSyncThread()
{
	UNIGINE_PROFILER_SCOPED(__FUNCTION__);
	sleepFor(0.2);
}

void MicroprofilerSleepyNode::update()
{
	ScopedProfiler profiler(__FUNCTION__);
	node->rotate(0.0f, 0.0f, 3.0f);
	sleepFor(0.2);
}

void MicroprofilerSleepyNode::postUpdate()
{
	UNIGINE_PROFILER_FUNCTION;
	sleepFor(0.05);
}

void MicroprofilerSleepyNode::updatePhysics()
{
	UNIGINE_PROFILER_FUNCTION;
	sleepFor(0.02);
}

void MicroprofilerSleepyNode::swap()
{
	UNIGINE_PROFILER_FUNCTION;
	sleepFor(0.01);
}

void MicroprofilerSleepyNode::shutdown()
{
	UNIGINE_PROFILER_FUNCTION;
	sleepFor(1);
}

void MicroprofilerSleepyNode::sleepFor(double ms)
{
	auto ct = Time::getMilliseconds();
	while (true)
	{
		auto t = Time::getMilliseconds();
		if (t - ct >= ms)
			return;
	}
}

```

## MotionMode.cpp

```cpp
#include "MotionMode.h"

#include <UnigineObjects.h>

using namespace Unigine;
using namespace Math;

void MotionMode::init()
{
	if (!targetNode.get())
		Log::error("MotionMode::init(): cannot get targetNode property\n");

	persecutor = ComponentSystem::get()->getComponent<PersecutorBase>(persecutorNode.get());
	if (!persecutor)
		Log::error("MotionMode::init(): cannot get Persecutor component from persecutorNode\n");
}

```

## MountPointsSample.cpp

```cpp
#include "MountPointsSample.h"
#include "UnigineConsole.h"
#include "UnigineGui.h"
#include "UnigineImage.h"
#include "UnigineMathLibVec4.h"
#include "UniginePtr.h"
#include "UnigineWidgets.h"
#include "UnigineFileSystem.h"

REGISTER_COMPONENT(MountPointsSample)

using namespace Unigine;
using namespace Math;

// Creates a mount point to an external folder or package (.zip, .ung) using the provided absolute path
bool MountPointsSample::add_mount(const char *absolute_path_external, const char *mount_path)
{
	// Checks whether the external folder or package exists.
	if (!Dir::isDir(absolute_path_external) && !FileSystem::isFileExist(String(absolute_path_external) + ".zip"))
	{
		Log::error("External folder/package doesn't exist\n");
		return false;
	}

	// Mounts the external folder or package into the file system.
	// Saves a .umount file with a name derived from the mount_path and the specified access mode (read and write).
	FileSystemMountPtr mount = FileSystem::createMount(absolute_path_external, mount_path, FileSystemMount::ACCESS_READWRITE);

	if (!mount)
		return false;

	return true;
}

// Unmounts the mount point associated with the given absolute path to the mounted folder or package.
bool MountPointsSample::remove_mount(const char *absolute_path_external)
{
	// Checks whether the specified folder or package is currently mounted.
	if (!FileSystem::getMount(absolute_path_external))
		return false;

	FileSystem::removeMount(absolute_path_external);
	return true;
}

void MountPointsSample::init()
{
	virtual_path_umount = String::pathname(World::getPath()) + mounts_folder_name + "/";
	package_image_path = virtual_path_umount + package_name + "/" + image_name;
	folder_image_path = virtual_path_umount + folder_name + "/" + image_name;
	init_gui();

	update_images();
}

void MountPointsSample::shutdown()
{
	disconnectAll();
	window.shutdown();
}

void MountPointsSample::init_gui()
{
	window.createWindow();

	auto parameters = window.getParameterGroupBox();

	WidgetHBoxPtr create_hbox = WidgetHBox::create();
	create_hbox->setSpace(10, 10);

	status_label = WidgetLabel::create("Status: ");
	status_label->setFontWrap(1);
	status_label->setWidth(300);

	create_hbox->addChild(status_label, Gui::ALIGN_LEFT);
	parameters->addChild(create_hbox, Gui::ALIGN_EXPAND);
	parameters->addChild(WidgetSpacer::create());

	// Widget for mount folder
	create_mount_widget(sprite_folder, folder_name, "Folder");
	parameters->addChild(WidgetSpacer::create());

	// Widget for mount package
	create_mount_widget(sprite_package, package_name, "Package");
	parameters->addChild(WidgetSpacer::create());

	image_folder = Image::create();
	image_package = Image::create();
	// sprite_folder->setImage(image_folder);
	// sprite_package->setImage(image_package);

	current_mounts = WidgetVBox::create();
	current_mounts->setSpace(0, 10);
	auto mounts_title = WidgetLabel::create("<b>Current mount points</b>");
	mounts_title->setFontRich(1);
	auto folder_label = WidgetLabel::create();
	folder_label->setFontWrap(1);
	auto package_label = WidgetLabel::create();
	package_label->setFontWrap(1);
	current_mounts->addChild(mounts_title, Gui::ALIGN_LEFT);
	current_mounts->addChild(folder_label, Gui::ALIGN_LEFT);
	current_mounts->addChild(package_label, Gui::ALIGN_LEFT);
	parameters->addChild(current_mounts, Gui::ALIGN_LEFT);

	show_sample_mounts();
}


void MountPointsSample::create_mount_widget(WidgetSpritePtr &sprite, const char *external_name, const char *type)
{
	String absolute_path_external = FileSystem::getAbsolutePath(String("../external_resources/") + external_name);
	String mount_path = virtual_path_umount + external_name;
	String image_path = mount_path + "/" + image_name;

	auto vbox = WidgetVBox::create();
	vbox->setSpace(0, 10);

	auto hbox_buttons = WidgetHBox::create();

	auto create_btn = WidgetButton::create(String::format("Create Mount %s", type));
	create_btn->getEventClicked().connect(*this, [this, mount_path, absolute_path_external]() {
		if (add_mount(absolute_path_external.get(), mount_path))
		{
			status_message("Mount Point Created", vec4_green);
			show_sample_mounts();
			update_images();
		} else
		{
			status_message(Console::getLastError(), vec4_red);
		}
	});

	auto remove_btn = WidgetButton::create(String::format("Unmount %s", type));
	remove_btn->getEventClicked().connect(*this, [this, absolute_path_external]() {
		if (remove_mount(absolute_path_external))
		{
			status_message("The Mount Point unmounted", vec4_green);
			show_sample_mounts();
			update_images();
		} else
		{
			status_message("The Mount Point is not mounted", vec4_red);
		}
	});

	hbox_buttons->addChild(create_btn);
	hbox_buttons->addChild(remove_btn);
	hbox_buttons->setSpace(10, 0);

	sprite = WidgetSprite::create();
	sprite->setWidth(100);
	sprite->setHeight(100);

	vbox->addChild(hbox_buttons, Gui::ALIGN_TOP);
	vbox->addChild(sprite, Gui::ALIGN_BACKGROUND);

	window.getParameterGroupBox()->addChild(vbox, Gui::ALIGN_RIGHT);
}

void MountPointsSample::status_message(const char *msg, vec4 color)
{
	status_label->setFontColor(color);
	status_label->setText(String("Status: ") + msg);
}

void MountPointsSample::show_mount(const char *absolute_path, int index)
{
	auto mount = FileSystem::getMount(absolute_path);
	auto label = static_ptr_cast<WidgetLabel>(current_mounts->getChild(index));
	if (mount)
	{
		label->setText(mount->getUMountPath());
		label->setToolTip(
			String::format("<b>Virtual Mount Path:</b> %s<br><b>Absolute Path:</b> %s", mount->getVirtualPath(), mount->getDataPath())
				.get());
	} else
		label->setText("");
}

void MountPointsSample::show_sample_mounts()
{
	show_mount(FileSystem::getAbsolutePath(String("../external_resources/") + folder_name), 1);
	show_mount(FileSystem::getAbsolutePath(String("../external_resources/") + package_name), 2);
}

void MountPointsSample::update_images()
{
	image_folder->clearData();
	if (!FileSystem::isFileExist(folder_image_path) ||
		!image_folder->load(folder_image_path))
	{
		image_folder->load("core/textures/common/red.texture");
	}
	sprite_folder->setImage(image_folder);

	image_package->clearData();
	if (!FileSystem::isFileExist(package_image_path) ||
			!image_package->load(package_image_path))
	{
		image_package->load("core/textures/common/red.texture");
	}
	sprite_package->setImage(image_package);
}

```

## Movement.cpp

```cpp
#include "Movement.h"

REGISTER_COMPONENT(Movement);

using namespace Unigine;

void Movement::init()
{
	body_rigid = node->getObjectBodyRigid();
	if (!body_rigid)
	{
		Log::message("Movement::init: couldn't get RigidBody");
	}
}

void Movement::update()
{
	direction = static_cast<Math::Vec3>(Math::vec3_zero);

	if (Input::isKeyPressed(Input::KEY::KEY_W))
	{
		direction += static_cast<Math::Vec3>(Math::vec3_forward);
	}

	if (Input::isKeyPressed(Input::KEY::KEY_S))
	{
		direction += static_cast<Math::Vec3>(Math::vec3_back);
	}

	if (Input::isKeyPressed(Input::KEY::KEY_A))
	{
		direction += static_cast<Math::Vec3>(Math::vec3_right * 0.15f);
	}

	if (Input::isKeyPressed(Input::KEY::KEY_D))
	{
		direction += static_cast<Math::Vec3>(Math::vec3_left * 0.15f);
	}
}

void Movement::update_physics()
{
	direction = body_rigid->getTransform().getRotate() * direction;
	body_rigid->addWorldForce(movement_point_node->getWorldPosition(),
		static_cast<Math::vec3>(direction) * body_rigid->getMass() * force_multiplier);
}

```

## MultipleAsyncRequestsSample.cpp

```cpp
#include "MultipleAsyncRequestsSample.h"

#include <UniginePlayers.h>
#include <UnigineGame.h>
#include <UnigineInput.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(MultipleAsyncRequestsSample);

using namespace Unigine;
using namespace Math;

void MultipleAsyncRequestsSample::init()
{
	init_gui();

	requests.resize(num_slices * num_stacks);
	for (int i = 0; i < requests.size(); i++)
	{
		requests[i] = new IntersectionRequest();
		requests[i]->addAsyncEndCallback(MakeCallback(this, &MultipleAsyncRequestsSample::on_intersection_end));
	}

	results.resize(num_slices * num_stacks);

	second_buffer = requests;
	buffer = &second_buffer;

	Visualizer::setEnabled(true);
}

void MultipleAsyncRequestsSample::update()
{
	// update emitter transform
	float k = (Math::sin(0.3f * Game::getTime()) + 1.0f) / 2.0f;
	emitter_pos.z = min_height + k * (max_height - min_height);

	emitter_rotation += 10.0f * Game::getIFps();
	if (emitter_rotation > 360.0f)
		emitter_rotation -= 360.0f;

	Visualizer::renderPoint3D(emitter_pos, 2.0f, vec4_red);

	// update emitter intersection results and rays
	float slice_step = 360.0f / num_slices;
	float stack_step = 85.0f / num_stacks;

	for (int i = 0; i < num_slices; i++)
	{
		for (int j = 0; j < num_stacks; j++)
		{
			IntersectionRequest *fetch = requests[i * num_stacks + j];
			Result &res = results[i * num_stacks + j];

			if (fetch->isAsyncCompleted())
			{
				if (fetch->isIntersection())
				{
					res.point = fetch->getPoint();
					res.normal = fetch->getNormal();
				}
				res.is_intersected = fetch->isIntersection();

				Vec3 dir = rotateZ(slice_step * i + emitter_rotation) * Vec3_forward;
				dir = quat(cross(vec3(dir), vec3_up), -stack_step * j) * dir;

				fetch->setPositionBegin(emitter_pos);
				fetch->setPositionEnd(emitter_pos + dir * intersection_distance);
			}

			if (res.is_intersected)
				Visualizer::renderVector(res.point, res.point + Vec3(res.normal) * 5.0f, vec4_red);
		}
	}

	// swap completed featches buffers
	{
		ScopedLock lock(mutex);

		if (buffer == &first_buffer)
			buffer = &second_buffer;
		else
			buffer = &first_buffer;

		buffer->clear();
	}

	// start intersections detection
	if (buffer == &first_buffer)
		Intersections::getAsync(second_buffer);
	else
		Intersections::getAsync(first_buffer);

	long long total_count = immediate_latency_count + low_latency_count + middle_latency_count + high_latency_count;
	if (total_count != 0)
	{
		float immediate = static_cast<float>(immediate_latency_count) / total_count * 100.0f;
		float low = static_cast<float>(low_latency_count) / total_count * 100.0f;
		float middle = static_cast<float>(middle_latency_count) / total_count * 100.0f;
		float high = static_cast<float>(high_latency_count) / total_count * 100.0f;

		String text = "Latency (number of frames per result): \n";
		text += String::format("0-2 (Immediate): %.1f", immediate) + "%\n";
		text += String::format("3-5 (Low): %.1f", low) + "%\n";
		text += String::format("5-7 (Middle): %.1f", middle) + "%\n";
		text += String::format(">7 (High): %.1f", high) + "%\n";

		sample_description_window.setStatus(text.get());
	}
}

void MultipleAsyncRequestsSample::shutdown()
{
	sample_description_window.shutdown();
	Visualizer::setEnabled(false);

	Intersections::wait(requests);

	for (int i = 0; i < requests.size(); i++)
		delete requests[i];
	requests.clear();

	buffer = nullptr;
	first_buffer.clear();
	second_buffer.clear();

	results.clear();
}

void MultipleAsyncRequestsSample::on_intersection_end(IntersectionRequest *r)
{
	long long d = r->getAsyncFrameLatency();
	if (d <= 2)
		immediate_latency_count++;
	else if (d <= 5)
		low_latency_count++;
	else if (d <= 7)
		middle_latency_count++;
	else
		high_latency_count++;

	ScopedLock lock(mutex);
	buffer->append(r);
}

void MultipleAsyncRequestsSample::init_gui()
{
	sample_description_window.createWindow();
}

```

## NavigationMeshDemoLogic.cpp

```cpp
#include <UnigineVisualizer.h>
#include <UnigineConsole.h>
#include <UnigineComponentSystem.h>
#include <UniginePathFinding.h>
#include <UnigineGame.h>

#include "../../user_interface/widget_manipulators/Manipulators.h"
#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/navigation/Seeker.h"

class NavigationMeshDemoLogic : public Unigine::ComponentBase
{
public:
	COMPONENT_DEFINE(NavigationMeshDemoLogic, Unigine::ComponentBase);
	COMPONENT_INIT(init, 2);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

	PROP_PARAM(Float, route_radius, 0.15f);
	PROP_PARAM(Node, navigation);
	PROP_PARAM(Node, seekers);

	void setSeekersRouteRadius(float radius);

private:
	void init();
	void update();
	void shutdown();

	SampleDescriptionWindow sample_description_window;
	Manipulators *widget_manipulator;
};

REGISTER_COMPONENT(NavigationMeshDemoLogic);

using namespace Unigine;
using namespace Unigine::Math;

void NavigationMeshDemoLogic::init()
{
	Visualizer::setEnabled(true);
	Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);

	widget_manipulator = getComponent<Manipulators>(node);
	if (widget_manipulator)
	{
		widget_manipulator->setZAxisTranslation(false);
		widget_manipulator->setXAxisRotation(false);
		widget_manipulator->setYAxisRotation(false);
		widget_manipulator->setXAxisScale(false);
		widget_manipulator->setYAxisScale(false);
		widget_manipulator->setZAxisScale(false);
	}

	setSeekersRouteRadius(route_radius);

	{
		sample_description_window.createWindow();

		sample_description_window.addFloatParameter(
			"Route radius",
			"The radius required to move the point along the route inside the navigation area.",
			route_radius,
			0.f,
			1.f,
			[this](float radius) { setSeekersRouteRadius(radius); }
		);
	}
}

void NavigationMeshDemoLogic::update()
{
	Game::getPlayer()->setControlled(!widget_manipulator->isActive());

	if (navigation)
		navigation->renderVisualizer();
}

void NavigationMeshDemoLogic::shutdown()
{
	Visualizer::setEnabled(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	sample_description_window.shutdown();
}

void NavigationMeshDemoLogic::setSeekersRouteRadius(float radius)
{
	if (seekers)
	{
		for (int i = 0; i < seekers->getNumChildren(); i += 1)
		{
			auto seeker_component = getComponent<Seeker>(seekers->getChild(i));
			if (seeker_component)
				seeker_component->setRouteRadius(radius);
		}

	}
}

```

## NavigationMeshLogic.cpp

```cpp
#include <UnigineVisualizer.h>
#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineComponentSystem.h>
#include <UniginePathFinding.h>

#include "../../user_interface/widget_manipulators/Manipulators.h"
#include "../../menu_ui/SampleDescriptionWindow.h"

class NavigationMeshLogic : public Unigine::ComponentBase
{
public:
	COMPONENT_DEFINE(NavigationMeshLogic, Unigine::ComponentBase)
	COMPONENT_INIT(init, 2)
	COMPONENT_UPDATE(update)
	COMPONENT_SHUTDOWN(shutdown)

	PROP_PARAM(Node, path_start)
	PROP_PARAM(Node, path_end)
	PROP_PARAM(Node, navigation)
	PROP_PARAM(Float, route_radius, 0.15f)
	PROP_PARAM(Color, route_color, Unigine::Math::vec4_white)

private:
	void init();
	void update();
	void shutdown();

	Unigine::PathRoutePtr route;
	SampleDescriptionWindow sample_description_window;
	Manipulators *widget_manipulator;
};


REGISTER_COMPONENT(NavigationMeshLogic);

using namespace Unigine;
using namespace Unigine::Math;


void NavigationMeshLogic::init()
{
	Visualizer::setEnabled(true);
	Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);

	route = PathRoute::create();
	route->setRadius(route_radius);

	widget_manipulator = getComponent<Manipulators>(node);
	if (widget_manipulator)
	{
		widget_manipulator->setZAxisTranslation(false);
		widget_manipulator->setXAxisRotation(false);
		widget_manipulator->setYAxisRotation(false);
		widget_manipulator->setXAxisScale(false);
		widget_manipulator->setYAxisScale(false);
		widget_manipulator->setZAxisScale(false);
	}

	{
		sample_description_window.createWindow();

		sample_description_window.addFloatParameter(
			"Route radius",
			"The radius required to move the point along the route inside the navigation area.",
			route_radius,
			0.f,
			1.f,
			[this](float value) {
				route->setRadius(value);
			}
		);
	}
}

void NavigationMeshLogic::update()
{
	Game::getPlayer()->setControlled(!widget_manipulator->isActive());

	if (navigation)
		navigation->renderVisualizer();

	if (path_start && path_end)
	{
		auto start = path_start->getWorldPosition();
		auto end = path_end->getWorldPosition();

		route->create2D(start, end);

		if (route->isReached())
			route->renderVisualizer(route_color);

		else
			Visualizer::renderLine3D(start, end, vec4_red, Game::getIFps());
	}

	{
		auto status = String::format(
			"Route length: %.2f\n"
			"Route points: %d\n",
			route->getDistance(),
			route->getNumPoints()
		);

		sample_description_window.setStatus(status);
	}
}

void NavigationMeshLogic::shutdown()
{
	Visualizer::setEnabled(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	sample_description_window.shutdown();
}

```

## NavigationSectorsDemoLogic.cpp

```cpp
#include <UnigineVisualizer.h>
#include <UnigineConsole.h>
#include <UnigineComponentSystem.h>
#include <UniginePathFinding.h>
#include <UnigineGame.h>

#include "../../user_interface/widget_manipulators/Manipulators.h"
#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/navigation/Seeker.h"

class NavigationSectorsDemoLogic : public Unigine::ComponentBase
{
public:
	COMPONENT_DEFINE(NavigationSectorsDemoLogic, Unigine::ComponentBase);
	COMPONENT_INIT(init, 2);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);
	
	PROP_PARAM(Float, route_radius, 0.15f);
	PROP_PARAM(Node, navigation);
	PROP_PARAM(Node, seekers);
	
	void setSeekersRouteRadius(float radius);
	
private:
	void init();
	void update();
	void shutdown();
	
	SampleDescriptionWindow sample_description_window;
	Manipulators *widget_manipulator;
};

REGISTER_COMPONENT(NavigationSectorsDemoLogic);

using namespace Unigine;
using namespace Unigine::Math;

void NavigationSectorsDemoLogic::init()
{
	Visualizer::setEnabled(true);
	Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);
	
	widget_manipulator = getComponent<Manipulators>(node);
	if (widget_manipulator)
	{
		widget_manipulator->setXAxisScale(false);
		widget_manipulator->setYAxisScale(false);
		widget_manipulator->setZAxisScale(false);
	}
	
	setSeekersRouteRadius(route_radius);
	
	{
		sample_description_window.createWindow();
		
		sample_description_window.addFloatParameter(
			"Route radius",
			"The radius required to move the point along the route inside the navigation area.",
			route_radius,
			0.f,
			2.f,
			[this](float radius) { setSeekersRouteRadius(radius); }
		);
	}
}

void NavigationSectorsDemoLogic::update()
{
	Game::getPlayer()->setControlled(!widget_manipulator->isActive());
	
	if (navigation)
		navigation->renderVisualizer();
}

void NavigationSectorsDemoLogic::shutdown()
{
	Visualizer::setEnabled(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	sample_description_window.shutdown();
}

void NavigationSectorsDemoLogic::setSeekersRouteRadius(float radius)
{
	if (seekers)
	{
		for (int i = 0; i < seekers->getNumChildren(); i += 1)
		{
			auto seeker_component = getComponent<Seeker>(seekers->getChild(i));
			if (seeker_component)
				seeker_component->setRouteRadius(radius);
		}
		
	}
}

```

## NavigationSectorsLogic.cpp

```cpp
#include <UnigineVisualizer.h>
#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineComponentSystem.h>
#include <UniginePathFinding.h>

#include "../../user_interface/widget_manipulators/Manipulators.h"
#include "../../menu_ui/SampleDescriptionWindow.h"

class NavigationSectorsLogic : public Unigine::ComponentBase
{
public:
	COMPONENT_DEFINE(NavigationSectorsLogic, Unigine::ComponentBase);
	COMPONENT_INIT(init, 2);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);
	
	PROP_PARAM(Node, path_start);
	PROP_PARAM(Node, path_end);
	PROP_PARAM(Node, navigation);
	PROP_PARAM(Float, route_radius, 0.12f);
	PROP_PARAM(Color, route_color, Unigine::Math::vec4_white);
	
private:
	void init();
	void update();
	void shutdown();
	
	Unigine::PathRoutePtr route;
	SampleDescriptionWindow sample_description_window;
	Manipulators *widget_manipulator;
};

REGISTER_COMPONENT(NavigationSectorsLogic);

using namespace Unigine;
using namespace Unigine::Math;


void NavigationSectorsLogic::init()
{
	Visualizer::setEnabled(true);
	Input::setMouseHandle(Input::MOUSE_HANDLE_SOFT);
	
	route = PathRoute::create();
	route->setRadius(route_radius);
	
	widget_manipulator = getComponent<Manipulators>(node);
	if (widget_manipulator)
	{
		widget_manipulator->setXAxisScale(false);
		widget_manipulator->setYAxisScale(false);
		widget_manipulator->setZAxisScale(false);
	}
	
	{
		sample_description_window.createWindow();
		
		sample_description_window.addFloatParameter(
			"Route radius",
			"The radius required to move the point along the route inside the navigation area.",
			route_radius,
			0.f,
			1.f,
			[this](float value) {
				route->setRadius(value);
			}
		);
	}
}

void NavigationSectorsLogic::update()
{
	Game::getPlayer()->setControlled(!widget_manipulator->isActive());
	
	if (navigation)
	{
		for (int i = 0; i < navigation->getNumChildren(); i += 1)
			navigation->getChild(i)->renderVisualizer();
	}
	
	if (path_start && path_end)
	{
		auto start = path_start->getWorldPosition();
		auto end = path_end->getWorldPosition();
		
		route->create2D(start, end);
		
		if (route->isReached())
			route->renderVisualizer(route_color);
		
		else
			Visualizer::renderLine3D(start, end, vec4_red, Game::getIFps());
	}
	
	{
		auto status = String::format(
			"Route length: %.2f\n"
			"Route points: %d\n",
			route->getDistance(),
			route->getNumPoints()
		);
		
		sample_description_window.setStatus(status);
	}
}

void NavigationSectorsLogic::shutdown()
{
	Visualizer::setEnabled(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	sample_description_window.shutdown();
}

```

## NodeAnimationSample.cpp

```cpp
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class NodeAnimationSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(NodeAnimationSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		create_animations();

		// create object for animation
		box = Primitives::createBox(Math::vec3_one);
		box->setName("box");
		box->setID(123);
		box->setWorldPosition(Vec3(0.f, 0.f, 1.15f));

		playback->play();

		gui.init(this);
	}

	void update()
	{
		gui.update();
	}

	void shutdown()
	{
		gui.shutdown();
		playback->stop();
	}

	void create_animations()
	{
		// create new track
		AnimationTrackPtr track = AnimationTrack::create();

		// create animation object and add it to track
		AnimationObjectNodePtr anim_obj = AnimationObjectNode::create("box");
		track->addObject(anim_obj);

		AnimationBindNodePtr bind = anim_obj->getBind();
		bind->setNodeDescription(123, "box");
		anim_obj->setBind(bind);

		// animate position of object
		auto position_modifier = AnimationModifierScalar::create("node.world_position_z");

		// create an animation curve explicitely
		auto position_curve = AnimationCurveScalar::create();
		position_curve->addKey(0.0f, 1.5f + 0.0f);
		position_curve->addKey(4.0f, 1.5f + 2.0f);
		position_curve->addKey(8.0f, 1.5f + 0.0f);

		// set all key types to KEY_TYPE_SMOOTH to get a bezier curve with symmetric tangents ((-1, 0) and (1, 0) by default)
		position_curve->setTypeOfAllKeys(AnimationCurve::KEY_TYPE_SMOOTH);

		// set the curve in the position modifier
		position_modifier->setCurve(position_curve);

		// add the position modifier to track
		track->addObjectModifier(anim_obj, position_modifier);

		// animate rotation of object
		auto rotation_modifier = AnimationModifierQuat::create(AnimationModifierQuat::MODE_QUAT, "node.world_rotation");
		rotation_modifier->addQuatValue(0.0f, quat(0.0f, 0.0f, 0.0f));
		rotation_modifier->addQuatValue(4.0f, quat(0.0f, 0.0f, 180.0f));
		rotation_modifier->addQuatValue(8.0f, quat(0.0f, 0.0f, 360.0f));
		track->addObjectModifier(anim_obj, rotation_modifier);

		// animate scale of object
		auto scale_modifier = AnimationModifierFVec3::create("node.world_scale");
		scale_modifier->addValue(0.0f, vec3(1.f, 1.f, 1.f), AnimationCurve::KEY_TYPE_SMOOTH);
		scale_modifier->addValue(4.0f, vec3(1.5f, 1.5f, 0.66f), AnimationCurve::KEY_TYPE_SMOOTH);
		scale_modifier->addValue(8.0f, vec3(1.f, 1.f, 1.f), AnimationCurve::KEY_TYPE_SMOOTH);
		track->addObjectModifier(anim_obj, scale_modifier);

		// create playback for track
		playback = AnimationPlayback::create();
		playback->setTrack(track);
		playback->setLoop(true);
	}

	// ========================================================================================

	struct SampleGui
	{
		void init(NodeAnimationSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			auto w = sample_description_window.getWindow();
			auto state_gbox = WidgetGroupBox::create("State", 9, 3);
			w->addChild(state_gbox);

			auto gridbox = WidgetGridBox::create(2);
			state_gbox->addChild(gridbox, Gui::ALIGN_LEFT);

			auto add_parameter = [](const WidgetGridBoxPtr &gridbox, const char *name) {
				auto hbox = WidgetHBox::create();

				hbox->addChild(WidgetLabel::create(name));
				hbox->addChild(WidgetHBox::create(6));

				gridbox->addChild(hbox, Gui::ALIGN_LEFT);

				auto bg_color = WidgetEditLine::create();
				bg_color->setEditable(false);
				bg_color->setFontVOffset(-2);
				bg_color->setFontColor(vec4(vec3(.9f), 1.f));
				bg_color->setWidth(50);

				gridbox->addChild(bg_color, Gui::ALIGN_LEFT);
				return bg_color;
			};

			node_position_z = add_parameter(gridbox, "node.position.z");
			node_rotation_z = add_parameter(gridbox, "node.rotation.z");
			node_scale_x = add_parameter(gridbox, "node.scale.x");
			node_scale_y = add_parameter(gridbox, "node.scale.y");
			node_scale_z = add_parameter(gridbox, "node.scale.z");
		}

		void update()
		{
			node_position_z->setText(String::format("%.2f", sample->box->getWorldPosition().z));
			node_rotation_z->setText(String::format("%.2f", sample->box->getWorldRotation().getAngle(vec3_up)));
			node_scale_x->setText(String::format("%.2f", sample->box->getWorldScale().x));
			node_scale_y->setText(String::format("%.2f", sample->box->getWorldScale().y));
			node_scale_z->setText(String::format("%.2f", sample->box->getWorldScale().z));
		}

		void shutdown() { sample_description_window.shutdown(); }

		SampleDescriptionWindow sample_description_window;
		NodeAnimationSample *sample = nullptr;
		WidgetEditLinePtr node_position_z;
		WidgetEditLinePtr node_rotation_z;
		WidgetEditLinePtr node_scale_x;
		WidgetEditLinePtr node_scale_y;
		WidgetEditLinePtr node_scale_z;
	};

	AnimationPlaybackPtr playback;
	NodePtr box;
	SampleGui gui;
};

REGISTER_COMPONENT(NodeAnimationSample);

```

## NodeExternSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineMathLib.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

#include "../../menu_ui/SampleDescriptionWindow.h"

using namespace Unigine;
using namespace Math;

class MyNode : public NodeExternBase
{
public:
	// unique class ID
	static constexpr int id = 1;

	MyNode()
	{
		Log::message("MyNode::MyNode(): called\n");
	}

	MyNode(void *node): NodeExternBase(node)
	{
		Log::message("MyNode::MyNode(void*): called\n");
	}

	~MyNode() override
	{
		Log::message("MyNode::~MyNode(): called\n");
	}

	int getClassID() override { return id; }

	const BoundBox &getBoundBox() override { return bbox; }

	void renderVisualizer() override
	{
		Visualizer::renderBoundBox(bbox, getNode()->getWorldTransform(), color);
	}

	// custom method
	void setColor(const vec4 &color)
	{
		this->color = color;
	}

private:
	BoundBox bbox = BoundBox(vec3(-.5f), vec3(.5f));
	vec4 color = vec4_white;
};

class NodeExternSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(NodeExternSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		NodeExternBase::addClassID<MyNode>(MyNode::id);

		if (true)
		{
			// create a new MyNode instance
			NodeExternPtr node_extern = NodeExtern::create(MyNode::id);
			NodeExternBase *node_extern_base = node_extern->getNodeExtern();
			if (node_extern_base)
			{
				my_node = static_cast<MyNode *>(node_extern_base);
			}
		}

		else
		{
			// alternatively you can instantiate MyNode directly (you'd need to free it later!)
			my_node = new MyNode();
		}

		if (my_node)
		{
			// you can access the base Node methods via NodeExternBase::getNode
			my_node->getNode()->setWorldPosition(Vec3(0.f, 0.f, 1.f));

			// ... and access the custom MyNode methods directly
			my_node->setColor(vec4_white);
		}

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
	}

	void update()
	{
		my_node->renderVisualizer();
	}

	void shutdown()
	{
		Visualizer::setEnabled(visualizer_enabled);
	}

	// ========================================================================================

	bool visualizer_enabled = false;
	MyNode *my_node = nullptr;
};

REGISTER_COMPONENT(NodeExternSample);

```

## NodeSpawnerGrid.cpp

```cpp
#include "NodeSpawnerGrid.h"
#include <UnigineWorld.h>

using namespace Unigine;
using namespace Math;




void Utils::spawnGrid(const char* node_path, const Unigine::Math::vec2& cell_size, const Unigine::Math::ivec2& grid_size,
	const Unigine::Math::Mat4& world_transform,
	bool pivot_at_center,
	Unigine::Vector<Unigine::NodePtr>* output)
{
	for (int x = 0; x < grid_size.x; x++)
	{
		double x_pos = pivot_at_center ? x * cell_size.x - grid_size.x * cell_size.x/2 : x * cell_size.x;
		for (int y = 0; y < grid_size.y; y++)
		{
			double y_pos = pivot_at_center ? y * cell_size.y - grid_size.y*cell_size.y/2 : y * cell_size.y;
			NodePtr spawned_node = World::loadNode(node_path);
			spawned_node->setTransform(world_transform * translate(Vec3(static_cast<Scalar>(x_pos), static_cast<Scalar>(y_pos), 0)));
			if (output)
				output->push_back(spawned_node);
		}
	}
}

```

## NodeSpawnerGridSample.cpp

```cpp
#include "NodeSpawnerGridSample.h"


#include "NodeSpawnerGrid.h"

REGISTER_COMPONENT(NodeSpawnerGridSample);

using namespace Unigine;
using namespace Math;

void NodeSpawnerGridSample::init()
{
	sample_description_window.createWindow();

	sample_description_window.addIntParameter("Grid Size X", "Grid Size X", 5, 1, 100, [this](int v) {
		grid_size_x = v;
		redraw();
	});

	sample_description_window.addIntParameter("Grid Size Y", "Grid Size Y", 5, 1, 100, [this](int v) {
		grid_size_y = v;
		redraw();
	});

	sample_description_window.addFloatParameter("Cell Size", "Cell Size", 2.f, 0.5f, 100.f, [this](float v) {
		cell_size = v;
		redraw();
	});

	auto parameters = sample_description_window.getParameterGroupBox();
	auto hbox = WidgetHBox::create();
	auto checkbox = WidgetCheckBox::create();
	checkbox->getEventClicked().connect(*this, [this, checkbox]() {
		is_pivot_center = checkbox->isChecked();
		redraw();
	});
	auto label = WidgetLabel::create("Spawn from center");

	hbox->addChild(label);
	hbox->addChild(checkbox);

	parameters->addChild(hbox, Gui::ALIGN_LEFT);

	redraw();
}


void NodeSpawnerGridSample::redraw()
{
	if (!spawned_nodes.empty())
	{
		for (const auto &it : spawned_nodes)
		{
			it.deleteLater();
		}
		spawned_nodes.clear();
	}
	Utils::spawnGrid(node_to_spawn, vec2(cell_size), ivec2(grid_size_x, grid_size_y),
		Mat4_identity, is_pivot_center, &spawned_nodes);
}

void NodeSpawnerGridSample::shutdown()
{
	//checkbox_connection.disconnect();
	sample_description_window.shutdown();
}

```

## NodeSpawnerTimer.cpp

```cpp
#include "NodeSpawnerTimer.h"
#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(NodeSpawnerTimer);

void NodeSpawnerTimer::update()
{
	time_buffer_sec += Game::getIFps();
	if (time_buffer_sec >= spawn_rate)
	{
		time_buffer_sec -= spawn_rate;
		NodePtr spawned_node = World::loadNode(node_to_spawn);
		spawned_node->setTransform(node->getTransform());
	}
}
```

## NodeSpawnerTimerSample.cpp

```cpp
#include "NodeSpawnerTimerSample.h"

#include "NodeSpawnerTimer.h"

#include <UnigineGui.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(NodeSpawnerTimerSample);

void NodeSpawnerTimerSample::init()
{
	Visualizer::setEnabled(true);
	sample_description_window.createWindow();

	spawner = getComponent<NodeSpawnerTimer>(timed_spawner);
	spawner->spawn_rate = 5.0f;
	auto gui = Gui::getCurrent();
	sample_description_window.addFloatParameter("Spawn Frequency", "spawn frequency", 2, 0.1, 20,
		[this](float v) { spawner->spawn_rate = v; });
}

void NodeSpawnerTimerSample::update()
{
	vec4 color = lerp(vec4_red, vec4_green,
		inverseLerp(0, spawner->spawn_rate, spawner->getTimer()));
	color.w = 0.5f; // transparent
	Visualizer::renderSolidSphere(1.0f, timed_spawner->getWorldTransform(), color);
}

void NodeSpawnerTimerSample::shutdown()
{
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

```

## NodeToTexture.cpp

```cpp
#include "NodeToTexture.h"

#include <UnigineTextures.h>

REGISTER_COMPONENT(NodeToTexture);

using namespace Unigine;
using namespace Math;

void NodeToTexture::init()
{
	player = checked_ptr_cast<Player>(player_camera.get());
	texture = Texture::create();
	texture->create2D(256, 256, Texture::FORMAT_RGBA8,
		Texture::SAMPLER_FILTER_LINEAR | Texture::SAMPLER_ANISOTROPY_16
			| Texture::FORMAT_USAGE_RENDER);
	viewport = Viewport::create();
	viewport->setNodeLightUsage(Viewport::USAGE_WORLD_LIGHT);
	viewport->setSkipFlags(
		Viewport::SKIP_TRANSPARENT | Viewport::SKIP_VELOCITY_BUFFER | Viewport::SKIP_POSTEFFECTS | Viewport::SKIP_VISUALIZER);
	viewport->setEnvironmentTexture(Render::getBlackCubeTexture());
	auto obj = checked_ptr_cast<ObjectMeshStatic>(object_view.get());
	auto mat = obj->getMaterial(0);
	mat = mat->inherit();
	mat->setTexture(mat->findTexture("albedo"), texture);
	mat->setParameterFloat4("uv_transform", vec4(-1.f, Render::isFlipped() ? -1.f : 1.f, 0, 0));
	obj->setMaterial(mat, 0);
}

void NodeToTexture::update()
{
	viewport->renderNodeTexture2D(player->getCamera(), node_to_render, texture);
}

```

## NonPhysicalTracks.cpp

```cpp
#include "NonPhysicalTracks.h"

REGISTER_COMPONENT(NonPhysicalTracks);

using namespace Unigine;
using namespace Math;

void NonPhysicalTracks::init()
{
	if (!track_node.get())
		Log::error("NonPysicalTracks::init(): can not get targetNode property\n");

	mesh_static = static_ptr_cast<ObjectMeshStatic>(track_node.get());
	if (!mesh_static)
		Log::error("NonPysicalTracks::init():TrackNode is not ObjectMeshStatic\n");

	spline.init(node, mesh_static);
	spline.setSpacing(spacing);

	cluster = ObjectMeshCluster::create(mesh_static->getMeshPath());
	for (int i = 0; i < cluster->getNumSurfaces(); i++)
	{
		cluster->setIntersection(false, i);
		cluster->setCollision(false, i);
		cluster->setPhysicsIntersection(false, i);
		cluster->setMaterial(mesh_static->getMaterial(i), i);
	}
	cluster->setParent(node);
	
	spline.setParentTransform(cluster->getWorldTransform());

	is_initialized = true;
}

void NonPhysicalTracks::update()
{
	if (!is_initialized)
		return;

	// update tank tracks offset
	spline.setOffset(pos_offset);
	spline.setParentTransform(cluster->getWorldTransform());
	spline.update();
	
	cluster->createMeshes(spline.getMeshTrasform());
}

void NonPhysicalTracks::shutdown()
{
	if (cluster)
		cluster.deleteLater();
}

void NonPhysicalTracks::setOffset(float offset)
{
	pos_offset += offset;
}

```

## ObjectDepth.cpp

```cpp
#include "ObjectDepth.h"
#include <Unigine.h>
#include <UnigineTextures.h>

using namespace Unigine;
using namespace Math;

ObjectDepth::ObjectDepth()
{
	camera = Camera::create();

	viewport = Viewport::create();
	viewport->setAspectCorrection(0);
	viewport->setLifetime(60 * 60 * 10); // keep the temporary resources alive between calls to viewport->render*
	viewport->setSkipFlags(~0); // set all skip flags, since we don't want any shadows, post effects, etc.

	render_target = RenderTarget::create();

	// set render mode to RENDER_DEPTH, as we will only be using the depth buffer
	viewport->setRenderMode(Viewport::RENDER_DEPTH);

	// set up the end screen callback where the actual rendering will take place
	viewport->getEventEndScreen().connect(on_end_screen_connection, this, &ObjectDepth::on_end_screen);

	auto guid = FileSystem::getGUID(FileSystem::resolvePartialVirtualPath("digging_tool.basemat"));
	if (guid.isValid())
		digging_tool_mat = Materials::findMaterialByFileGUID(guid)->inherit();
	else
		Log::warning("ObjectDepth::ObjectDepth(): can not find \"digging_tool.basemat\" material\n");
}

void ObjectDepth::renderDepthTexture(
	TexturePtr &tex,
	const NodePtr &target,
	const Vec3 &pos,
	const Vec3 &size,
	const ivec2 &resolution
)
{
	if (!target)
		return;

	Vec3 center = pos + size * .5f;

	// save the bound box height and min z: these values will later be used
	// in the `digging_tool.basemat` shader, in the "object_depth" pass, when
	// mapping the depth value from clip space [0, 1] to the world space z
	{
		bb_height = (float)size.z;
		bb_min_z = (float)pos.z;
	}

	// set the camera's orthographic projection and modelview such that it matches the given position and size of the object's bound box
	{
		mat4 projection = ortho((float)(-size.x * 0.5f), (float)(size.x * 0.5f), (float)(-size.y * 0.5f), (float)(size.y * 0.5f), 0.0f, (float)size.z);
		Mat4 transform = translate(Vec3(center.x, center.y, pos.z)) * Mat4(rotateX(-180.0f));

		camera->setProjection(projection);
		camera->setModelview(inverse(transform));
	}

	// render the digging object to our texture
	{
		RenderState::saveState();
		RenderState::clearStates();
		RenderState::setViewport(0, 0, resolution.x, resolution.y);

		render_target->bindColorTexture(0, tex);
		render_target->enable();

		{
			viewport->renderNode(camera, target);
		}

		render_target->disable();
		render_target->unbindColorTexture(0);

		RenderState::restoreState();
	}
}

void ObjectDepth::on_end_screen()
{
	digging_tool_mat->setTexture("depth", Renderer::getTextureCurrentDepth());
	digging_tool_mat->setParameterFloat("bb_height", bb_height);
	digging_tool_mat->setParameterFloat("bb_min_z", bb_min_z);
	digging_tool_mat->renderScreen("object_depth");
}

```

## ObjectExternSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineFfp.h>
#include <UnigineMathLib.h>
#include <UnigineObjects.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class MyObject : public ObjectExternBase
{
public:
	// unique class ID
	static constexpr int id = 2;

	MyObject()
	{
		Log::message("MyObject::MyObject(): called\n");
	}

	MyObject(void *node): ObjectExternBase(node)
	{
		Log::message("MyObject::MyObject(void*): called\n");
	}

	~MyObject() override
	{
		Log::message("MyObject::~MyObject(): called\n");
	}

	int getClassID() override { return id; }

	int getNumSurfaces() override { return 1; }
	const char *getSurfaceName(int surface) override { return "surface"; }

	const Math::BoundBox &getBoundBox(int surface) override { return bbox; }
	const Math::BoundSphere &getBoundSphere(int surface) override { return bsphere; }

	const BoundBox &getBoundBox() override { return bbox; }
	const BoundSphere &getBoundSphere() override { return bsphere; }

	bool hasRender() override { return true; }

	void render(Render::PASS pass, int surface) override
	{
		// check render pass
		if (pass != Render::PASS_AMBIENT)
			return;

		// set object surface
		ObjectPtr object = getObject();
		Renderer::setShaderParameters(pass, object, surface, false);

		// object color
		ShaderPtr shader = RenderState::getShader();
		shader->setParameterFloat4("extern_color", color);
		shader->flushParameters();

		// object geometry
		Ffp::beginTriangles();

		vec3 half_size = bbox.getSize() * .5f;;

		Ffp::addVertex(-half_size.x, -half_size.y, -half_size.z);
		Ffp::addVertex(half_size.x, -half_size.y, -half_size.z);
		Ffp::addVertex(-half_size.x, half_size.y, -half_size.z);
		Ffp::addVertex(half_size.x, half_size.y, -half_size.z);
		Ffp::addVertex(-half_size.x, -half_size.y, half_size.z);
		Ffp::addVertex(half_size.x, -half_size.y, half_size.z);
		Ffp::addVertex(-half_size.x, half_size.y, half_size.z);
		Ffp::addVertex(half_size.x, half_size.y, half_size.z);

		Ffp::addIndices(0, 3, 1);
		Ffp::addIndices(3, 0, 2);
		Ffp::addIndices(6, 5, 7);
		Ffp::addIndices(5, 6, 4);
		Ffp::addIndices(2, 7, 3);
		Ffp::addIndices(7, 2, 6);
		Ffp::addIndices(1, 4, 0);
		Ffp::addIndices(4, 1, 5);
		Ffp::addIndices(3, 5, 1);
		Ffp::addIndices(5, 3, 7);
		Ffp::addIndices(0, 6, 2);
		Ffp::addIndices(6, 0, 4);

		Ffp::endTriangles();
	}

	// custom method
	void setColor(const vec4 &color)
	{
		this->color = color;
	}

private:
	BoundBox bbox = BoundBox(vec3(-.5f), vec3(.5f));
	BoundSphere bsphere = BoundSphere(vec3(0.f), 1.f);
	vec4 color = vec4_white;
};

class ObjectExternSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(ObjectExternSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		ObjectExternBase::addClassID<MyObject>(MyObject::id);

		if (true)
		{
			// create a new MyObject instance
			ObjectExternPtr object_extern = ObjectExtern::create(MyObject::id);
			ObjectExternBase *object_extern_base = object_extern->getObjectExtern();
			if (object_extern_base)
			{
				my_object = static_cast<MyObject *>(object_extern_base);
			}
		}

		else
		{
			// alternatively you can instantiate MyObject directly (you'd need to free it later!)
			my_object = new MyObject();
		}

		if (my_object)
		{
			// you can access the base Object methods via ObjectExternBase::getObject
			my_object->getObject()->setWorldPosition(Vec3(0.f, 0.f, 1.f));

			// assign a body to the object
			{
				BodyRigidPtr body = BodyRigid::create();
				ShapePtr shape = ShapeBox::create(my_object->getBoundBox().getSize());
				body->addShape(shape);
				my_object->getObject()->setBody(body);
			}

			// assign a material to our object's "surface"
			my_object->getObject()->setMaterialFilePath(joinPaths(getWorldRootPath(), "materials", "object_extern.basemat"), "surface");

			// ... and access the custom MyObject methods directly
			my_object->setColor(vec4_white);
		}

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
	}

	void update()
	{
	}

	void shutdown()
	{
		Visualizer::setEnabled(visualizer_enabled);
	}

	// ========================================================================================

	bool visualizer_enabled = false;
	MyObject *my_object = nullptr;
};

REGISTER_COMPONENT(ObjectExternSample);

```

## ObjectFrame.cpp

```cpp
#include "ObjectFrame.h"

#include <UnigineGame.h>
#include <UnigineViewport.h>

REGISTER_COMPONENT(ObjectFrame)


using namespace Unigine;
using namespace Math;

Unigine::WidgetCanvasPtr ObjectFrame::canvas;
bool ObjectFrame::canvas_clean;
int ObjectFrame::components_count = 0;

void ObjectFrame::init()
{
	components_count++;
	auto init_transform = node->getWorldTransform();
	node->setWorldTransform(Mat4(Math::scale(node->getScale())));
	collect_mesh_bound_box(node);

	points.resize(8);
	bound_box.getPoints(points.get(), 8);

	local_center = bound_box.getCenter();
	node->setWorldTransform(init_transform);

	if (!canvas)
	{
		auto gui = Gui::getCurrent();
		canvas = WidgetCanvas::create(gui);
		gui->addChild(canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_EXPAND);
		canvas_clean = false;
	}

	max_visibility_distance = visibility_distance * visibility_distance;
}

void ObjectFrame::update()
{
	auto window = WindowManager::getMainWindow();
	auto player = Game::getPlayer();
	if (!window || !player)
		return;

	is_frame_rendered = false;
	if (!canvas_clean)
	{
		canvas_clean = true;
		canvas->clear();
	}
	float distance = (node->getWorldPosition() - player->getWorldPosition()).length2();
	if (distance > max_visibility_distance)
		return;

	auto screen_size = window->getClientSize();
	min_point = {screen_size.x, screen_size.y};
	max_point = {0, 0};

	int x, y;
	bool visible = false;
	auto transform = node->getWorldTransform();
	for (const auto &point : points)
	{
		visible |= get_screen_position(x, y, Vec3(transform * point), player, screen_size);
		min_point.x = Math::min(min_point.x, x);
		min_point.y = Math::min(min_point.y, y);
		max_point.x = Math::max(max_point.x, x);
		max_point.y = Math::max(max_point.y, y);
	}

	if (!visible || !is_rectangle_on_screen(screen_size, min_point, max_point))
		return;

	auto world_center = transform * local_center;
	auto obj = World::getIntersection(player->getWorldPosition(), Vec3(world_center), ~0);
	if (!obj || !is_child(obj))
		return;

	int order = int(-distance * 100);
	ivec2 minmax_point = ivec2{min_point.x, max_point.y};
	ivec2 maxmin_point = ivec2{max_point.x, min_point.y};

	draw_rectangle(order, minmax_point, min_point - ivec2{border_size});
	draw_rectangle(order, min_point, maxmin_point + ivec2{1, -1} * border_size);
	draw_rectangle(order, maxmin_point, max_point + ivec2{border_size});
	draw_rectangle(order, max_point, minmax_point + ivec2{-1, 1} * border_size);

	int text_id = canvas->addText(order + 1);
	canvas->setFontSize(label_text_size);
	ivec2 text_size = canvas->toUnitSize(canvas->getTextRenderSize(label_text));

	auto header_point_min = min_point - ivec2{border_size};
	auto header_point_max = header_point_min + ivec2{text_size.x, -text_size.y}
		+ ivec2{2, -1} * border_size;
	draw_rectangle(order, header_point_min, header_point_max);

	canvas->setTextPosition(text_id, vec2(min_point.x, header_point_max.y));
	canvas->setTextText(text_id, label_text);
	canvas->setTextSize(text_id, label_text_size);
	canvas->setTextAlign(text_id, Gui::ALIGN_LEFT | Gui::ALIGN_BOTTOM | Gui::ALIGN_BACKGROUND);
	canvas->setTextColor(text_id, label_text_color);
	canvas->setTextOutline(text_id, label_text_outline);

	is_frame_rendered = true;
}

void ObjectFrame::post_update()
{
	if (canvas_clean)
		canvas_clean = false;
}

void ObjectFrame::shutdown()
{
	components_count--;
	if (components_count == 0 && (canvas || !canvas.isDeleted()))
	{
		canvas.deleteLater();
		canvas = nullptr;
	}
}

void ObjectFrame::collect_mesh_bound_box(const NodePtr &n)
{
	if (!n)
		return;

	int type = n->getType();
	if (type == Node::NODE_REFERENCE)
		collect_mesh_bound_box(static_ptr_cast<NodeReference>(n)->getReference());
	else if (type == Node::OBJECT_MESH_STATIC || type == Node::OBJECT_MESH_SKINNED
		|| type == Node::OBJECT_MESH_DYNAMIC)
	{
		bound_box.expand(n->getBoundBox());
	}

	for (int i = 0; i < n->getNumChildren(); i++)
		collect_mesh_bound_box(n->getChild(i));
}

bool ObjectFrame::get_screen_position(int &x, int &y, const Vec3 &world_point,
	const Unigine::PlayerPtr &player, const Unigine::Math::ivec2 &screen_size)
{
	float width = itof(screen_size.x);
	float height = itof(screen_size.y);

	mat4 projection = player->getProjection();
	mat4 modelview = mat4(player->getCamera()->getModelview());
	projection.m00 *= height / width;

	Vec4 p = projection * Vec4(modelview * Vec4(world_point, 1));
	if (p.w > 0)
	{
		// in front of camera
		x = (static_cast<float>(width * (0.5f + p.x * 0.5f / p.w)));
		y = (static_cast<float>(height - height * (0.5f + p.y * 0.5f / p.w)));
		return true;
	}
	else
	{
		// behind camera
		x = (width - static_cast<float>(width * (0.5f + p.x * 0.5f / p.w)));
		y = (height - static_cast<float>(height - height * (0.5f + p.y * 0.5f / p.w)));
		return false;
	}
}

int ObjectFrame::draw_rectangle(int order, const ivec2 &p1, const ivec2 &p2)
{
	int id = canvas->addPolygon(order);

	canvas->addPolygonPoint(id, vec3(p1.x, p1.y, 0));
	canvas->addPolygonPoint(id, vec3(p1.x, p2.y, 0));
	canvas->addPolygonPoint(id, vec3(p2.x, p2.y, 0));
	canvas->addPolygonPoint(id, vec3(p2.x, p1.y, 0));
	canvas->addPolygonIndex(id, 0);
	canvas->addPolygonIndex(id, 1);
	canvas->addPolygonIndex(id, 2);
	canvas->addPolygonIndex(id, 2);
	canvas->addPolygonIndex(id, 3);
	canvas->addPolygonIndex(id, 0);

	canvas->setPolygonColor(id, border_color);
	return id;
}

bool ObjectFrame::is_rectangle_on_screen(const Unigine::Math::ivec2 &screen_size, const ivec2 &min,
	const ivec2 &max)
{
	if ((min.x <= 0 && max.x <= 0) || (min.x >= screen_size.x && max.x >= screen_size.x)
		|| (min.y <= 0 && max.y <= 0) || (min.y >= screen_size.y && max.y >= screen_size.y))
		return false;
	return true;
}

bool ObjectFrame::is_child(const Unigine::NodePtr &n)
{
	if (n == node)
		return true;
	auto parent = n->getParent();
	if (!parent)
		parent = n->getPossessor();
	return parent ? is_child(parent) : false;
}

void ObjectFrame::setObjectFramesEnabled(bool enabled)
{
	if (!canvas)
		return;

	auto gui = Gui::getCurrent();
	if (enabled)
		gui->addChild(canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_EXPAND | Gui::ALIGN_BACKGROUND);
	else
		gui->removeChild(canvas);
}

JsonPtr ObjectFrame::getJsonMeta() const
{
	JsonPtr json = Json::create();
	json->setObject();
	json->addChild("node_id", node->getID());
	json->addChild("node_name", node->getName());

	auto pos = node->getWorldPosition();
	auto pos_json = json->addChild("position");
	pos_json->setObject();
	pos_json->addChild("x", pos.x);
	pos_json->addChild("y", pos.y);
	pos_json->addChild("z", pos.z);

	auto rot = node->getWorldRotation();
	auto rot_json = json->addChild("rotation");
	rot_json->setObject();
	rot_json->addChild("x", rot.getAngle(vec3_right));
	rot_json->addChild("y", rot.getAngle(vec3_forward));
	rot_json->addChild("z", rot.getAngle(vec3_up));

	auto min_frame_json = json->addChild("screen_position");
	min_frame_json->setObject();
	min_frame_json->addChild("min_x", min_point.x);
	min_frame_json->addChild("min_y", min_point.y);
	min_frame_json->addChild("max_x", max_point.x);
	min_frame_json->addChild("max_y", max_point.y);

	return json;
}

```

## ObjectFrameSample.cpp

```cpp
#include "ObjectFrameSample.h"
#include "ObjectFrame.h"

#include <UnigineConsole.h>
#include <ctime>

#include "../../utils/Utils.h"

REGISTER_COMPONENT(ObjectFrameSample);

using namespace Unigine;

void ObjectFrameSample::init()
{
	sample_description_window.createWindow();

	auto param_box = sample_description_window.getParameterGroupBox();
	param_box->setText("Controls");
	WidgetButtonPtr button = WidgetButton::create("Snap Screenshot");
	button->getEventClicked().connect(*this, [this]() {
		ObjectFrame::setObjectFramesEnabled(false);
		grab_flag = true;
	});
	param_box->addChild(button, Gui::ALIGN_EXPAND);

	label = WidgetLabel::create("");
	param_box->addChild(label, Gui::ALIGN_LEFT);

	window = WindowManager::getMainWindow();
	if (window)
		window->getEventFuncEndRender().connect(*this, this,
			&ObjectFrameSample::snap_screenshot);

	ComponentSystem::get()->getComponentsInWorld(frames, true);
}

void ObjectFrameSample::shutdown()
{
	sample_description_window.shutdown();
}

void ObjectFrameSample::snap_screenshot()
{
	if (!grab_flag)
		return;
	grab_flag = false;

	TexturePtr temporary_texture = Render::getTemporaryTexture2D(window->getClientRenderSize().x,
		window->getClientRenderSize().y, Texture::FORMAT_RGBA8);
	temporary_texture->copy2D();
	ObjectFrame::setObjectFramesEnabled(true);

	time_t now = time(0);
	std::strftime(time_str.getRaw(), time_str.getMemoryUsage(), "%Y-%m-%d %H_%M_%S",
		std::localtime(&now));

	JsonPtr json = Json::create();
	auto array = json->addChild("entities");
	array->setArray();
	for (const auto &it : frames)
	{
		if (!it->isVisible() || !it->isEnabled())
			continue;
		auto info = it->getJsonMeta();
		array->addChild(info);
	}
	json->save(joinPaths(getWorldRootPath(), "frame_data", time_str + ".json"));

	Render::asyncTransferTextureToImage(nullptr, MakeCallback([this](ImagePtr image) {
		if (!Render::isFlipped())
			image->flipY();

		Log::message("Saving \"%s.png\"\n", time_str.get());
		image->save(joinPaths(getWorldRootPath(), "screenshots", time_str + ".png"));

		String msg = String::format("Saved screenshot \"%s.png\"", time_str.get());
		label->setText(msg);
	}),
		temporary_texture);
	Render::releaseTemporaryTexture(temporary_texture);
}

```

## ObjectsSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineFileSystem.h>
#include <UnigineMesh.h>
#include <UniginePhysics.h>
#include <UnigineVisualizer.h>
#include <UniginePrimitives.h>
#include <UnigineObjects.h>
#include <UnigineGame.h>

#include "../../menu_ui/SampleDescriptionWindow.h"

using namespace Unigine;
using namespace Math;

namespace
{
	constexpr float tetrahedron_edge = 1.4f;
}

class ObjectsSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(ObjectsSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_UPDATE_PHYSICS(update_physics);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		create_static_mesh();
		create_dynamic_mesh();
		create_particles_object();

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
		gui.init(this);
	}

	void update()
	{
		visualize_objects();
	}

	void update_physics()
	{
		if (first_frame)
		{
			if (BodyRigidPtr body = dynamic_mesh->getBodyRigid())
			{
				body->addAngularImpulse(body->getInertia() * vec3(0.f, 0.f, .5f));
			}
		}

		first_frame = false;
	}

	void shutdown()
	{
		gui.shutdown();
		Visualizer::setEnabled(visualizer_enabled);
	}

	void create_static_mesh()
	{
		static_mesh = ObjectMeshStatic::create();

		// set an existing mesh to be used in our static mesh
		static_mesh->setMeshPath(FileSystem::resolvePartialVirtualPath("material_ball.mesh"));

		// assign a material to all of the surfaces of the mesh using a wildcard pattern
		static_mesh->setMaterialFilePath(FileSystem::resolvePartialVirtualPath("material_ball/fbx/material_ball_mat.mat"), "*");

		{
			// add a rigid body to our static mesh object

			BoundBox bbox = static_mesh->getBoundBox();

			BodyRigidPtr body = BodyRigid::create();
			ShapeBoxPtr shape = ShapeBox::create();

			shape->setSize(bbox.getSize());
			body->addShape(shape, translate(bbox.getCenter()));

			static_mesh->setBody(body);
		}

		static_mesh->setWorldPosition(Vec3(-3.0f, 0.f, 1.1f));
		static_mesh->setWorldRotation(quat(0.f, 0.f, 270.f));
	}

	void create_dynamic_mesh()
	{
		// here we construct a tetrahedron - a simple shape with four vertices

		// in this sample we don't change the indices of the mesh (triangle configuration), but we do change the mesh vertices (their positions),
		// so we set the dynamic mesh flags correspondigly:
		dynamic_mesh = ObjectMeshDynamic::create(ObjectMeshDynamic::USAGE_IMMUTABLE_INDICES | ObjectMeshDynamic::USAGE_DYNAMIC_VERTEX);

		// allocate the memory for the vertices and indices
		dynamic_mesh->allocateIndices(3 * 4);
		dynamic_mesh->allocateVertex(4);

		{
			// add the four vertices to the mesh

			dynamic_mesh->addVertex(vec3(0.f, - sqrtf(8.f / 9.f), -1.f / 3.f) * tetrahedron_edge * 3.f / (2.f * sqrtf(6.f)));
			dynamic_mesh->addVertex(vec3(- sqrtf(2.f / 3.f), sqrtf(2.f / 9.f), -1.f / 3.f) * tetrahedron_edge * 3.f / (2.f * sqrtf(6.f)));
			dynamic_mesh->addVertex(vec3(+ sqrtf(2.f / 3.f), sqrtf(2.f / 9.f), -1.f / 3.f) * tetrahedron_edge * 3.f / (2.f * sqrtf(6.f)));
			dynamic_mesh->addVertex(vec3(0.f, 0.f, 1.f) * tetrahedron_edge * 3.f / (2.f * sqrtf(6.f)));
		}

		{
			// set up the texture coordinates for the vertices of our mesh, which are going to be used by materials

			dynamic_mesh->setTexCoord(0, vec4(vec2(0.f, 0.f), vec2_zero));
			dynamic_mesh->setTexCoord(1, vec4(vec2(.33f, 0.f), vec2_zero));
			dynamic_mesh->setTexCoord(2, vec4(vec2(.66f, 0.f), vec2_zero));
			dynamic_mesh->setTexCoord(3, vec4(vec2(.5f, 1.f), vec2_zero));
		}

		{
			// add the 12 indices corresponding to the 4 triangles of our mesh

			// note that the order of the three indices describing each triangle matters:
			// it encodes the information about which side of the triangle is "front" and which side is "back"
			// and is sometimes referred to as the "winding order" (you can learn more about it here: https://www.khronos.org/opengl/wiki/Face_Culling)

			// in Unigine counter-clockwise order is used to denote the "front" side of the triangle,
			// the "back" faces are culled and will not be rendered

			dynamic_mesh->addIndex(0);
			dynamic_mesh->addIndex(1);
			dynamic_mesh->addIndex(2);

			dynamic_mesh->addIndex(1);
			dynamic_mesh->addIndex(0);
			dynamic_mesh->addIndex(3);

			dynamic_mesh->addIndex(3);
			dynamic_mesh->addIndex(0);
			dynamic_mesh->addIndex(2);

			dynamic_mesh->addIndex(2);
			dynamic_mesh->addIndex(1);
			dynamic_mesh->addIndex(3);

			// save the resulting mesh as a surface with name "surface"
			dynamic_mesh->addSurface("surface");
		}

		// update the tangents and bounds after constructing the mesh
		dynamic_mesh->updateTangents();
		dynamic_mesh->updateBounds();

		// assign a material to the surface "surface" we've just created
		dynamic_mesh->setMaterialFilePath(FileSystem::resolvePartialVirtualPath("glass_mat.mgraph"), "surface");

		{
			// add a rigid body to our dynamic mesh object

			BodyRigidPtr body = BodyRigid::create(dynamic_mesh);
			ShapeSpherePtr shape = ShapeSphere::create(body, sqrtf(3.f / 8.f) * tetrahedron_edge);

			body->setGravity(false);
			body->setShapeBased(false);
			body->setInertia(mat3_identity * 60.f);
			body->setMass(60.f);
		}

		dynamic_mesh->setWorldPosition(Vec3(0.f, 3.f, 1.2f));
		dynamic_mesh->setWorldRotation(quat(0.f, 0.f, 180.f));
	}

	void create_particles_object()
	{
		particles = ObjectParticles::create();

		// here we create a particles object and configure some of its type-specific properties

		particles->setCollisionEnabled(true);
		particles->setCollisionMask(~0);

		particles->setPhysicsIntersectionEnabled(true);
		particles->setPhysicsIntersectionMask(~0);

		particles->setEmitterEnabled(1);
		particles->setSpawnRate(5.0f);
		particles->setLife(2.0f, 0.5f);

		particles->setWorldPosition(Vec3(3.f, 0.f, 1.0f));
	}

	void visualize_objects()
	{
		vec4 surface_color = visualize_surfaces ? vec4(vec3(1.f), .66f) : vec4_zero;
		vec4 shape_color = visualize_shapes ? vec4(.97f, .9f, .356f, 1.f) : vec4_zero;

		auto render_surfaces = [](const ObjectPtr &object, const vec4 &color)
		{
			for (int i = 0; i < object->getNumSurfaces(); i += 1)
				Visualizer::renderObjectSurface(object, i, color);
		};

		auto render_shapes = [](const ObjectPtr &object, const vec4 &color)
		{
			BodyPtr body = object->getBody();

			// check that the object has a body
			if (body)
			{
				for (int i = 0; i < body->getNumShapes(); i += 1)
					body->getShape(i)->renderVisualizer(color);
			}
		};

		render_surfaces(dynamic_mesh, surface_color);
		render_surfaces(static_mesh, surface_color);
		render_surfaces(particles, surface_color);

		render_shapes(dynamic_mesh, shape_color);
		render_shapes(static_mesh, shape_color);
		render_shapes(particles, shape_color);
	}

	void set_tetrahedron_base_relative_height(float height)
	{
		// here we change some of the vertex positions of our tetrahedron mesh

		height = height * tetrahedron_edge * 3.f / (2.f * sqrtf(6.f));
		float circumsphere_radius = tetrahedron_edge * sqrtf(3.f / 8.f);
		float base_radius = sqrtf(circumsphere_radius * circumsphere_radius - height * height);

		// update the vertex positions
		dynamic_mesh->setVertex(0, rotateZ(0.f * 360.f) * vec3(0.f, -base_radius, height));
		dynamic_mesh->setVertex(1, rotateZ(1.f /3.f * 360.f) * vec3(0.f, -base_radius, height));
		dynamic_mesh->setVertex(2, rotateZ(2.f /3.f * 360.f) * vec3(0.f, -base_radius, height));

		// call the flushVertex method after changing the vertex data so that it is updated on the GPU also
		dynamic_mesh->flushVertex();
	}

	// ========================================================================================

	struct SampleGui : public EventConnections
	{
		void init(ObjectsSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			sample_description_window.addFloatParameter(
				"material ball albedo brightness",
				"",
				1.f,
				0.f,
				1.f,
				[sample](float value)
				{
					for (int i = 0; i < sample->static_mesh->getNumSurfaces(); i += 1)
						sample->static_mesh->getMaterialInherit(i)->setParameterFloat4("albedo_color", vec4(vec3(value), 1.f));
				}
			);

			sample_description_window.addFloatParameter(
				"tetrahedron base height",
				"",
				-1.f / 3.f,
				-1.f,
				1.f,
				[sample](float value) {
					sample->set_tetrahedron_base_relative_height(value);
				}
			);

			sample_description_window.addFloatParameter(
				"particles spawn rate",
				"",
				5.f,
				0.f,
				50.f,
				[sample](float value) {
					sample->particles->setSpawnRate(value);
				}
			);

			sample_description_window.addBoolParameter(
				"show object surfaces",
				"",
				true,
				[sample](bool value) {
					sample->visualize_surfaces = value;
				}
			);

			sample_description_window.addBoolParameter(
				"show object body shapes",
				"",
				false,
				[sample](bool value) {
					sample->visualize_shapes = value;
				}
			);
		}

		void shutdown()
		{
			sample_description_window.shutdown();
		}

		ObjectsSample *sample = nullptr;
		SampleDescriptionWindow sample_description_window;
	};

	// ========================================================================================

	ObjectMeshDynamicPtr dynamic_mesh;
	ObjectMeshStaticPtr static_mesh;
	ObjectParticlesPtr particles;

	bool visualizer_enabled = false;
	bool visualize_surfaces = true;
	bool visualize_shapes = false;
	bool first_frame = true;

	SampleGui gui;
};

REGISTER_COMPONENT(ObjectsSample);

```

## ObserverController.cpp

```cpp
#include "ObserverController.h"

#include <UnigineGame.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ObserverController);

using namespace Unigine;
using namespace Math;

void ObserverController::init()
{
	player_camera = checked_ptr_cast<PlayerSpectator>(Game::getPlayer());
	enter_mouse_grab_mode = Input::isMouseGrab();

	assign_inputs();
	create_state_map();
	update_gear(velocity_gear);
	init_menu();
}

void ObserverController::init_spectator()
{
	player_camera->setControlled(true);
	ControlsApp::setMouseEnabled(true);
}

void ObserverController::init_panning()
{
	Input::setMouseGrab(true);

	ControlsApp::setMouseEnabled(true);
}

void ObserverController::init_focusing()
{
	WorldIntersectionPtr intersection = WorldIntersection::create();

	Vec3 start_point, end_point, obj_position;

	Scalar focus_radius;

	player_camera->getDirectionFromMainWindow(start_point, end_point, Input::getMousePosition().x, Input::getMousePosition().y);

	NodePtr obj = World::getIntersection(start_point, end_point, ~0, intersection);

	if (!obj)
	{
		try_end_focusing = true;
		return;
	}

	obj_position = obj->getWorldPosition();
	focus_radius = obj->getWorldBoundSphere().radius;

	// Block, with an example for focusing specifically on instances of ObjectMeshCluster
	if (ObjectMeshClusterPtr cluster = checked_ptr_cast<ObjectMeshCluster>(obj)) 
	{
		int instance_index = intersection->getInstance();

		ConstMeshPtr mesh = cluster->getMeshCurrentRAM();
		Mat4 transform = Mat4(cluster->getMeshTransform(instance_index));

		obj_position = cluster->getWorldTransform() * transform.getTranslate();

		//When searching the radius, we take into account both the scale of the instance and the ObjectMeshCluster itself.
		focus_radius = mesh->getBoundSphere().radius * cluster->getScale().max() * transform.getScale().max(); 
	}

	//We take the doubled radius so that the camera is at a distance from the focus point.
	target_point = obj_position - Vec3(player_camera->getWorldDirection() * focus_radius * 2);
}

void ObserverController::init_menu()
{
	menu_layout = WidgetHBox::create(0, 4);
	menu_layout->setBackground(1);
	Gui::getCurrent()->addChild(menu_layout, Gui::ALIGN_TOP);

	WidgetHBoxPtr gears_layout = WidgetHBox::create(5, 0);
	menu_layout->addChild(gears_layout, Gui::ALIGN_LEFT);

	WidgetLabelPtr labelName = WidgetLabel::create("Player speed:");
	gears_layout->addChild(labelName, Gui::ALIGN_LEFT);

	edit_lines.push_back(WidgetEditLine::create(String::ftoa(get_velocity(), 5)));
	edit_lines[0]->setValidator(3);
	edit_lines[0]->setWidth(100);
	gears_layout->addChild(edit_lines[0], Gui::ALIGN_LEFT);

	edit_lines[0]->getEventFocusIn().connect(*this, [this]() { edit_text = true; });
	edit_lines[0]->getEventFocusOut().connect(*this, [this]() {
		edit_text = false;
		set_velocity(
			velocity_gear,
			String::isEmpty(edit_lines[0]->getText()) ? DEFAULT_VELOCITY : String::atof(edit_lines[0]->getText()));
	});

	first_gear_checkbox = WidgetCheckBox::create("1");
	first_gear_checkbox->setChecked(true);
	gears_layout->addChild(first_gear_checkbox, Gui::ALIGN_LEFT);
	first_gear_checkbox->getEventChanged().connect(*this, [this]() {
		if (first_gear_checkbox->isChecked())
			change_gear_text_field(VelocityGear::GEAR_FIRST);
	});

	second_gear_checkbox = WidgetCheckBox::create("2");
	first_gear_checkbox->addAttach(second_gear_checkbox);
	gears_layout->addChild(second_gear_checkbox, Gui::ALIGN_LEFT);
	second_gear_checkbox->getEventChanged().connect(*this, [this]() {
		if (second_gear_checkbox->isChecked())
			change_gear_text_field(VelocityGear::GEAR_SECOND);
	});

	third_gear_checkbox = WidgetCheckBox::create("3");
	first_gear_checkbox->addAttach(third_gear_checkbox);
	gears_layout->addChild(third_gear_checkbox, Gui::ALIGN_LEFT);
	third_gear_checkbox->getEventChanged().connect(*this, [this]() {
		if (third_gear_checkbox->isChecked())
			change_gear_text_field(VelocityGear::GEAR_THIRD);
	});

	WidgetSpacerPtr gear_spacer = WidgetSpacer::create();
	gear_spacer->setOrientation(0);
	menu_layout->addChild(gear_spacer, Gui::ALIGN_LEFT);

	WidgetHBoxPtr position_layout = WidgetHBox::create(5, 0);
	menu_layout->addChild(position_layout, Gui::ALIGN_LEFT);

	labelName = WidgetLabel::create("X:");
	position_layout->addChild(labelName, Gui::ALIGN_LEFT);

	edit_lines.push_back(WidgetEditLine::create(String::dtoa((double)player_camera->getWorldPosition().x)));
	edit_lines[1]->setValidator(3);
	edit_lines[1]->setWidth(100);
	position_layout->addChild(edit_lines[1], Gui::ALIGN_LEFT);
	edit_lines[1]->getEventFocusIn().connect(*this, [this]() { edit_text = true; });
	edit_lines[1]->getEventKeyPressed().connect(*this, [this]() {
		Scalar value = String::isEmpty(edit_lines[1]->getText()) ? DEFAULT_POSITION_VALUE : String::atof(edit_lines[1]->getText());
		Vec3 position = player_camera->getWorldPosition();
		player_camera->setWorldPosition(Vec3(value, position.y, position.z));
	});
	edit_lines[1]->getEventFocusOut().connect(*this, [this]() {
		edit_text = false;
		if (String::isEmpty(edit_lines[1]->getText()))
			edit_lines[1]->setText(String::ftoa(DEFAULT_POSITION_VALUE));
	});

	labelName = WidgetLabel::create("Y:");
	position_layout->addChild(labelName, Gui::ALIGN_LEFT);

	edit_lines.push_back(WidgetEditLine::create(String::dtoa((double)player_camera->getWorldPosition().y)));
	edit_lines[2]->setValidator(3);
	edit_lines[2]->setWidth(100);
	position_layout->addChild(edit_lines[2], Gui::ALIGN_LEFT);
	edit_lines[2]->getEventFocusIn().connect(*this, [this]() { edit_text = true; });
	edit_lines[2]->getEventKeyPressed().connect(*this, [this]() {
		Scalar value = String::isEmpty(edit_lines[2]->getText()) ? DEFAULT_POSITION_VALUE : String::atof(edit_lines[2]->getText());
		Vec3 position = player_camera->getWorldPosition();
		player_camera->setWorldPosition(Vec3(position.x, value, position.z));
	});
	edit_lines[2]->getEventFocusOut().connect(*this, [this]() {
		edit_text = false;
		if (String::isEmpty(edit_lines[2]->getText()))
			edit_lines[2]->setText(String::ftoa(DEFAULT_POSITION_VALUE));
	});

	labelName = WidgetLabel::create("Z:");
	position_layout->addChild(labelName, Gui::ALIGN_LEFT);

	edit_lines.push_back(WidgetEditLine::create(String::dtoa((double)player_camera->getWorldPosition().z)));
	edit_lines[3]->setValidator(3);
	edit_lines[3]->setWidth(100);
	position_layout->addChild(edit_lines[3], Gui::ALIGN_LEFT);
	edit_lines[3]->getEventFocusIn().connect(*this, [this]() { edit_text = true; });
	edit_lines[3]->getEventKeyPressed().connect(*this, [this]() {
		Scalar value = String::isEmpty(edit_lines[3]->getText()) ? DEFAULT_POSITION_VALUE : String::atof(edit_lines[3]->getText());
		Vec3 position = player_camera->getWorldPosition();
		player_camera->setWorldPosition(Vec3(position.x, position.y, value));
	});
	edit_lines[3]->getEventFocusOut().connect(*this, [this]() {
		edit_text = false;
		if (String::isEmpty(edit_lines[3]->getText()))
			edit_lines[3]->setText(String::ftoa(DEFAULT_POSITION_VALUE));
	});
}

void ObserverController::update()
{
	if (Console::isActive())
		return;
	if (edit_text)	
	{
		update_edit_field_submission();
		return;
	}
	update_velocity_gear();
	update_state();
	update_menu();
}

void ObserverController::update_state()
{
	auto &state = state_map[player_state];

	for (const auto &transition : state.transitions)
	{
		if (transition.condition())
		{
			switch_state(transition.target_state);
			return;
		}
	}

	if (state.on_update)
		state.on_update();
}

void ObserverController::update_gear(VelocityGear new_gear)
{
	velocity_gear = new_gear;
	player_camera->setMinVelocity(get_velocity());
	player_camera->setMaxVelocity(get_velocity_acceleration());
}

void ObserverController::update_velocity_gear()
{
	if (Input::isKeyDown(_first_gear_key))
	{
		first_gear_checkbox->setChecked(true);
	}

	if (Input::isKeyDown(_second_gear_key))
	{
		second_gear_checkbox->setChecked(true);
	}

	if (Input::isKeyDown(_third_gear_key))
	{
		third_gear_checkbox->setChecked(true);
	}
}

void ObserverController::update_spectator()
{
	Input::setMouseCursorHide(true);
}

void ObserverController::update_rail()
{
	Input::setMouseCursorHide(true);

	ivec2 mouse_delta = Input::getMouseDeltaPosition();

	normalizeValid(vec2(mouse_delta));

	float current_acceleration = Input::isKeyPressed(_acceleration_key) ? get_velocity() : get_velocity_acceleration();

	float delta = -(mouse_delta.x + mouse_delta.y) * current_acceleration * ControlsApp::getMouseSensitivity() * panning_rail_scale;

	player_camera->translate(Vec3(0, 0, delta));
}

void ObserverController::update_panning()
{
	Input::setMouseCursorHide(true);

	ivec2 mouse_delta = Input::getMouseDeltaPosition();

	normalizeValid(vec2(mouse_delta));

	float current_acceleration = Input::isKeyPressed(_acceleration_key) ? get_velocity() : get_velocity_acceleration();

	player_camera->translate(Vec3(float( - mouse_delta.x), float(mouse_delta.y), 0.0f) * current_acceleration * ControlsApp::getMouseSensitivity() * panning_rail_scale);
}

void ObserverController::update_focusing()
{
	player_camera->setWorldPosition(lerp(player_camera->getWorldPosition(), target_point, Game::getIFps() * 5));
	if (distance2(player_camera->getWorldPosition(), target_point) < 0.01f)
		try_end_focusing = true;
}

void ObserverController::update_menu()
{
	if (Input::isKeyDown(_toggle_camera_menu))
		menu_layout->setHidden(!menu_layout->isHidden());

	Vec3 player_position = player_camera->getWorldPosition();

	edit_lines[1]->setText(String::dtoa((double)player_position.x, 5));
	edit_lines[2]->setText(String::dtoa((double)player_position.y, 5));
	edit_lines[3]->setText(String::dtoa((double)player_position.z, 5));
}

void ObserverController::update_edit_field_submission()
{
	if (!edit_lines.empty() && Input::isKeyDown(Input::KEY_ENTER))
	{
		for (const auto &line : edit_lines)
			line->removeFocus();
	}
}

void ObserverController::shutdown()
{
	menu_layout.deleteLater();
	Input::setMouseGrab(enter_mouse_grab_mode);
}

void ObserverController::end_spectator()
{
	player_camera->setControlled(false);
}

void ObserverController::end_panning()
{
	Input::setMouseGrab(false);
}

void ObserverController::end_focusing()
{
	try_end_focusing = false;
}

// This method sets up the state transitions and associated actions for each movement state of the player.
// Each state (e.g., IDLE, SPECTATOR, FOCUSING, etc.) is mapped to a set of conditions for state transitions, 
// as well as initialization, update, and end functions for when the state is entered or exited.
void ObserverController::create_state_map()
{
	state_map[PlayerMovementState::IDLE] = {
		{{[this]() { return try_focusing(); }, PlayerMovementState::FOCUSING},
			{[this]() { return try_enter_spectator_mode(); }, PlayerMovementState::SPECTATOR},
			{[this]() { return try_enter_rail_mode(); }, PlayerMovementState::RAIL},
			{[this]() { return try_enter_panning_mode(); }, PlayerMovementState::PANNING}},
		nullptr,
		nullptr,
		nullptr};

	state_map[PlayerMovementState::SPECTATOR] = {
		{{[this]() { return !try_enter_spectator_mode(); }, PlayerMovementState::IDLE}},
		[this]() { init_spectator(); },
		[this]() { end_spectator(); },
		[this]() { update_spectator(); }};

	state_map[PlayerMovementState::RAIL] = {
		{{[this]() { return try_exit_rail_mode(); }, PlayerMovementState::IDLE}},
		nullptr,
		nullptr,
		[this] { update_rail(); }};
	state_map[PlayerMovementState::FOCUSING] = {
		{{[this]() { return try_end_focusing; }, PlayerMovementState::IDLE},
			{[this]() { return try_enter_spectator_mode(); }, PlayerMovementState::SPECTATOR},
			{[this]() { return try_enter_rail_mode(); }, PlayerMovementState::RAIL},
			{[this]() { return try_enter_panning_mode(); }, PlayerMovementState::PANNING}},
		[this]() { init_focusing(); },
		[this]() { end_focusing(); },
		[this]() { update_focusing(); }};

	state_map[PlayerMovementState::PANNING] = {
		{{[this]() { return try_exit_panning_mode(); }, PlayerMovementState::IDLE}},
		[this]() { init_panning(); },
		[this]() { end_panning(); },
		[this]() { update_panning(); }};
}

void ObserverController::switch_state(PlayerMovementState target_state)
{
	if (player_state == target_state)
		return;

	if (state_map[player_state].on_exit)
		state_map[player_state].on_exit();

	player_state = target_state;

	if (state_map[player_state].on_enter)
		state_map[player_state].on_enter();
}

void ObserverController::assign_inputs()
{
	_toggle_camera_menu = Input::getKeyByName(toggle_camera_menu.get());
	_focus_key = Input::getKeyByName(focus_key.get());
	_acceleration_key = Input::getKeyByName(acceleration_key.get());
	_first_gear_key = Input::getKeyByName(first_gear_key.get());
	_second_gear_key = Input::getKeyByName(second_gear_key.get());
	_third_gear_key = Input::getKeyByName(third_gear_key.get());

	_spectator_mode = Input::getMouseButtonByName(spectator_mode);
	_rail_mode = Input::getMouseButtonByName(rail_mode);
	_panning_mode = Input::getMouseButtonByName(panning_mode);

	_alt_camera_mode = Input::getModifierByName(alt_camera_mode);
}

void ObserverController::change_gear_text_field(VelocityGear target_gear)
{
	update_gear(target_gear);
	edit_lines[0]->setText(String::ftoa(get_velocity()));
}

void ObserverController::set_velocity(VelocityGear target_gear, float velocity)
{
	switch (target_gear)
	{
		case VelocityGear::GEAR_FIRST:
			first_gear_velocity = velocity;
			break;
		case VelocityGear::GEAR_SECOND:
			second_gear_velocity = velocity;
			break;
		case VelocityGear::GEAR_THIRD:
			third_gear_velocity = velocity;
	}
	update_gear(target_gear);
}

float ObserverController::get_velocity() const
{
	switch (velocity_gear)
	{
		case VelocityGear::GEAR_FIRST:
			return first_gear_velocity;
			break;
		case VelocityGear::GEAR_SECOND:
			return second_gear_velocity;
			break;
		case VelocityGear::GEAR_THIRD:
			return third_gear_velocity;
			break;
		default:
			return 0.0f;
	}
}

float ObserverController::get_velocity_acceleration() const
{
	return get_velocity() * accelearation_multiplier;
}

```

## PaintSample.cpp

```cpp
#include "PaintSample.h"

REGISTER_COMPONENT(PaintSample);

using namespace Unigine;
using namespace Math;

void PaintSample::init()
{
	saved_mouse_handle = ControlsApp::getMouseHandle();
	ControlsApp::setMouseHandle(Input::MOUSE_HANDLE_USER);

	albedo_painter = getComponent<LandscapeAlbedoPainter>(albedo_painter_param);
	height_painter = getComponent<LandscapeHeightPainter>(height_painter_param);
	height_to_albedo = getComponent<LandscapeHeightToAlbedo>(height_to_albedo_param);

	player = static_ptr_cast<PlayerSpectator>(player_param.get());
	landscape_fetch = LandscapeFetch::create();

	auto guid = FileSystem::getGUID(
		FileSystem::resolvePartialVirtualPath("decal_brush_base.basemat"));
	if (!guid.isValid())
	{
		Log::warning("PaintSample::init(): can not find \"decal_brush_base.basemat\" material\n");
		return;
	}

	brush_decal_material = Materials::findMaterialByFileGUID(guid)->inherit();
	brush_decal = DecalOrtho::create(); // 100.0f, 1.0f, 1.0f, "decal_base"
	brush_decal->setRadius(100.0f);
	brush_decal->setWidth(1.0f);
	brush_decal->setHeight(1.0f);
	brush_decal->setMaterial(brush_decal_material);

	init_resources();
	init_gui();

	landscape_layer_map = static_ptr_cast<LandscapeLayerMap>(landscape_layer_map_param.get());
	albedo_painter->setTarget(landscape_layer_map);
	height_painter->setTarget(landscape_layer_map);
	height_to_albedo->setTarget(landscape_layer_map);

	set_mode(mode);
	set_brush_texture(brush_textures[0]);
	set_brush_mask(brush_masks[0]);
	set_gradient(gradients[0]);
	set_brush_size(brush_size);
	set_brush_spacing(brush_spacing);
	set_brush_angle(brush_angle);
	set_brush_height(brush_height);
	set_brush_height_scale(brush_height_scale);
	set_brush_opacity(brush_opacity);
	set_brush_color(brush_color);
	set_height_blend_mode(blend_mode);
	set_min_height(min_height);
	set_max_height(max_height);
}

void PaintSample::init_resources()
{
	for (int i = 0; i < brush_textures_param.size(); ++i)
	{
		auto image = Image::create();
		image->load(brush_textures_param[i]);

		auto texture = Texture::create();
		texture->create(image);
		brush_textures.push_back(texture);

		image->resize(32, 32);
		brush_textures_icons.push_back(image);
	}

	for (int i = 0; i < brush_masks_param.size(); ++i)
	{
		auto image = Image::create();
		image->load(brush_masks_param[i]);

		auto texture = Texture::create();
		texture->create(image);
		brush_masks.push_back(texture);

		image->resize(32, 32);
		brush_masks_icons.push_back(image);
	}

	for (int i = 0; i < gradients_param.size(); ++i)
	{
		auto image = Image::create();
		image->load(gradients_param[i]);

		auto texture = Texture::create();
		texture->create(image);
		gradients.push_back(texture);

		image->resize(32, 128);
		gradiends_icons.push_back(image);
	}
}

void PaintSample::update()
{
	if (window->getMouseX() >= 0 && window->getMouseX() < window->getWidth() && window->getMouseY() >= 0 && window->getMouseY() < window->getHeight())
	{
		return;
	}

	if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_RIGHT))
	{
		vec2 delta = vec2(Input::getMouseDeltaPosition()) * 0.2f;
		player->setPhiAngle(player->getPhiAngle() + delta.x);
		player->setThetaAngle(player->getThetaAngle() + delta.y);
	}

	if (Input::isKeyPressed(Input::KEY_LEFT_SHIFT) || Input::isKeyPressed(Input::KEY_RIGHT_SHIFT))
		set_brush_angle(brush_angle + Input::getMouseWheel() * 5);
	else if (Input::isKeyPressed(Input::KEY_LEFT_CTRL) || Input::isKeyPressed(Input::KEY_RIGHT_CTRL))
		set_brush_size(brush_size + Input::getMouseWheel() * 0.5f);


	if (mode == Mode::AlbedoPainter || mode == Mode::HeightPainter)
	{
		const auto mouse_coord = Input::getMousePosition();
		bool fetched = landscape_fetch->intersectionForce(player->getPosition(),
			player->getPosition() + Vec3(player->getDirectionFromMainWindow(mouse_coord.x, mouse_coord.y)) * 10000.0);

		if (fetched)
		{
			brush_decal->setPosition(landscape_fetch->getPosition() + Vec3(0.0, 0.0, 50.0));

			if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_LEFT))
			{
				switch (mode)
				{
					case Mode::AlbedoPainter:
						albedo_painter->paintAt(landscape_fetch->getPosition());
						break;
					case Mode::HeightPainter:
						height_painter->paintAt(landscape_fetch->getPosition());
						break;
					default: break;
				}
			}
		}
	}
}

void PaintSample::shutdown()
{
	albedo_painter->disable();
	height_painter->disable();
	height_to_albedo->disable();

	ControlsApp::setMouseHandle(saved_mouse_handle);

	shutdown_gui();
}

void PaintSample::set_mode(Mode in_mode)
{
	mode = in_mode;

	switch (mode)
	{
		case PaintSample::Mode::AlbedoPainter:
			albedo_painter->enable();
			height_painter->disable();
			height_to_albedo->disable();
			brush_decal->setEnabled(true);
			tab_box->setCurrentTab(0);
			break;
		case PaintSample::Mode::HeightPainter:
			albedo_painter->disable();
			height_painter->enable();
			height_to_albedo->disable();
			brush_decal->setEnabled(true);
			tab_box->setCurrentTab(1);
			break;
		case PaintSample::Mode::HeightToAlbedo:
			albedo_painter->disable();
			height_painter->disable();
			height_to_albedo->enable();
			brush_decal->setEnabled(false);
			tab_box->setCurrentTab(2);
			break;
		default:
			albedo_painter->disable();
			height_painter->disable();
			height_to_albedo->disable();
			brush_decal->setEnabled(false);
			break;
	}
}

void PaintSample::set_brush_texture(const Unigine::TexturePtr &in_brush_texture)
{
	brush_texture = in_brush_texture;

	albedo_painter->setBrushTexture(in_brush_texture);
	height_painter->setBrushTexture(in_brush_texture);

	brush_decal_material->setTexture("albedo", brush_texture);
}

void PaintSample::set_brush_mask(const Unigine::TexturePtr &in_brush_mask)
{
	brush_mask = in_brush_mask;

	albedo_painter->setBrushMask(in_brush_mask);
	height_painter->setBrushMask(in_brush_mask);

	brush_decal_material->setTexture("mask", brush_mask);
}

void PaintSample::set_gradient(const Unigine::TexturePtr &in_gradient)
{
	gradient = in_gradient;

	height_to_albedo->setGradient(gradient);
}

void PaintSample::set_brush_size(float in_brush_size, bool update_ui)
{
	brush_size = max(in_brush_size, 1.0f);

	albedo_painter->setBrushSize(brush_size);
	height_painter->setBrushSize(brush_size);

	brush_decal->setWidth(brush_size);
	brush_decal->setHeight(brush_size);

	if (update_ui)
	{
		albedo_brush_size_edit_line_callback.disconnect();
		albedo_brush_size_edit_line->setText(String::ftoa(brush_size));
		albedo_brush_size_edit_line->getEventChanged().connect(
			albedo_brush_size_edit_line_callback, this, &PaintSample::brush_size_edit_line_callback);

		height_brush_size_edit_line_callback.disconnect();
		height_brush_size_edit_line->setText(String::ftoa(brush_size));
		height_brush_size_edit_line->getEventChanged().connect(
			height_brush_size_edit_line_callback, this, &PaintSample::brush_size_edit_line_callback);
	}
}

void PaintSample::set_brush_spacing(float in_brush_spacing, bool update_ui)
{
	brush_spacing = max(in_brush_spacing, 0.0f);

	albedo_painter->setBrushSpacing(brush_spacing);
	height_painter->setBrushSpacing(brush_spacing);

	if (update_ui)
	{
		albedo_brush_spacing_edit_line_callback.disconnect();
		albedo_brush_spacing_edit_line->setText(String::ftoa(brush_spacing));
		albedo_brush_spacing_edit_line->getEventChanged().connect(
			albedo_brush_spacing_edit_line_callback, this, &PaintSample::brush_spacing_edit_line_callback);

		height_brush_spacing_edit_line_callback.disconnect();
		height_brush_spacing_edit_line->setText(String::ftoa(brush_spacing));
		height_brush_spacing_edit_line->getEventChanged().connect(
			height_brush_spacing_edit_line_callback, this, &PaintSample::brush_spacing_edit_line_callback);
	}
}

void PaintSample::set_brush_angle(float in_brush_angle, bool update_ui)
{
	brush_angle = in_brush_angle;

	albedo_painter->setBrushAngle(brush_angle);
	height_painter->setBrushAngle(brush_angle);

	brush_decal->setRotation(quat(0.0f, 0.0f, -brush_angle), true);

	if (update_ui)
	{
		albedo_brush_angle_edit_line_callback.disconnect();
		albedo_brush_angle_edit_line->setText(String::ftoa(brush_angle));
		albedo_brush_angle_edit_line->getEventChanged().connect(
			albedo_brush_angle_edit_line_callback, this, &PaintSample::brush_angle_edit_line_callback);

		height_brush_angle_edit_line_callback.disconnect();
		height_brush_angle_edit_line->setText(String::ftoa(brush_angle));
		height_brush_angle_edit_line->getEventChanged().connect(
			height_brush_angle_edit_line_callback, this, &PaintSample::brush_angle_edit_line_callback);
	}
}

void PaintSample::set_brush_height(float in_brush_height, bool update_ui)
{
	brush_height = in_brush_height;

	height_painter->setBrushHeight(in_brush_height);

	if (update_ui)
	{
		height_brush_height_edit_line_callback.disconnect();
		height_brush_height_edit_line->setText(String::ftoa(brush_height));
		height_brush_height_edit_line->getEventChanged().connect(
			height_brush_height_edit_line_callback, this, &PaintSample::brush_height_edit_line_callback);
	}
}

void PaintSample::set_brush_height_scale(float in_brush_height_scale, bool update_ui)
{
	brush_height_scale = in_brush_height_scale;

	height_painter->setBrushHeightScale(in_brush_height_scale);

	if (update_ui)
	{
		height_brush_height_scale_edit_line_callback.disconnect();
		height_brush_height_scale_edit_line->setText(String::ftoa(brush_height_scale));
		height_brush_height_scale_edit_line->getEventChanged().connect(
			height_brush_height_scale_edit_line_callback, this, &PaintSample::brush_height_scale_edit_line_callback);
	}
}

void PaintSample::set_brush_opacity(float in_brush_opacity, bool update_ui)
{
	brush_opacity = clamp(in_brush_opacity, 0.0f, 1.0f);

	albedo_painter->setBrushOpacity(brush_opacity);
	height_painter->setBrushOpacity(brush_opacity);

	if (update_ui)
	{
		albedo_brush_opacity_edit_line_callback.disconnect();
		albedo_brush_opacity_edit_line->setText(String::ftoa(brush_opacity));
		albedo_brush_opacity_edit_line->getEventChanged().connect(
			albedo_brush_opacity_edit_line_callback, this, &PaintSample::brush_opacity_edit_line_callback);

		height_brush_opacity_edit_line_callback.disconnect();
		height_brush_opacity_edit_line->setText(String::ftoa(brush_opacity));
		height_brush_opacity_edit_line->getEventChanged().connect(
			height_brush_opacity_edit_line_callback, this, &PaintSample::brush_opacity_edit_line_callback);
	}
}

void PaintSample::set_brush_color(const Unigine::Math::vec3 &in_brush_color, bool update_ui)
{
	brush_color = clamp(in_brush_color, {0.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f});

	albedo_painter->setBrushColor(brush_color);

	brush_decal_material->setParameterFloat4("albedo", {brush_color, 1.0f});

	if (update_ui)
	{
		albedo_brush_color_r_edit_line_callback.disconnect();
		albedo_brush_color_r_edit_line->setText(String::itoa(ftoi(brush_color.x * 255.0f)));
		albedo_brush_color_r_edit_line->getEventChanged().connect(
			albedo_brush_color_r_edit_line_callback, this, &PaintSample::brush_color_r_edit_line_callback);

		albedo_brush_color_g_edit_line_callback.disconnect();
		albedo_brush_color_g_edit_line->setText(String::itoa(ftoi(brush_color.y * 255.0f)));
		albedo_brush_color_g_edit_line->getEventChanged().connect(
			albedo_brush_color_g_edit_line_callback, this, &PaintSample::brush_color_g_edit_line_callback);

		albedo_brush_color_b_edit_line_callback.disconnect();
		albedo_brush_color_b_edit_line->setText(String::itoa(ftoi(brush_color.z * 255.0f)));
		albedo_brush_color_b_edit_line->getEventChanged().connect(
			albedo_brush_color_b_edit_line_callback, this, &PaintSample::brush_color_b_edit_line_callback);
	}
}

void PaintSample::set_height_blend_mode(BlendMode in_blend_mode, bool update_ui)
{
	blend_mode = in_blend_mode;

	height_painter->setBlendMode(in_blend_mode);

	if (update_ui)
	{
		height_blend_mode_combo_box_callback.disconnect();
		switch (blend_mode)
		{
			case BlendMode::Alpha: height_blend_mode_combo_box->setCurrentItem(0); break;
			case BlendMode::Additive: height_blend_mode_combo_box->setCurrentItem(1); break;
		}
		height_blend_mode_combo_box->getEventChanged().connect(
			height_blend_mode_combo_box_callback, this, &PaintSample::blend_mode_combo_box_callback);
	}
}

void PaintSample::set_min_height(float in_min_height, bool update_ui)
{
	min_height = in_min_height;

	height_to_albedo->setMinHeight(min_height);

	if (update_ui)
	{
		min_height_edit_line_callback_.disconnect();
		min_height_edit_line->setText(String::ftoa(min_height));
		min_height_edit_line->getEventChanged().connect(
			min_height_edit_line_callback_, this, &PaintSample::min_height_edit_line_callback);
	}
}

void PaintSample::set_max_height(float in_max_height, bool update_ui)
{
	max_height = in_max_height;

	height_to_albedo->setMaxHeight(max_height);

	if (update_ui)
	{
		max_height_edit_line_callback_.disconnect();
		max_height_edit_line->setText(String::ftoa(max_height));
		max_height_edit_line->getEventChanged().connect(
			max_height_edit_line_callback_, this, &PaintSample::max_height_edit_line_callback);
	}
}

void PaintSample::init_gui()
{
	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();

	window = sample_description_window.getWindow();

	tab_box = WidgetTabBox::create();
	tab_box->getEventChanged().connect(this, &PaintSample::tab_box_callback);
	tab_box->addTab("Albedo Painter");

	auto hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create("Texture");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	auto gridbox = WidgetGridBox::create(6);
	tab_box->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_textures.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_textures_icons[i]);
		button->getEventClicked().connect(this, &PaintSample::brush_texture_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Mask");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	gridbox = WidgetGridBox::create(6);
	tab_box->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_masks.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_masks_icons[i]);
		button->getEventClicked().connect(this, &PaintSample::brush_mask_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Size");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_size_edit_line = WidgetEditLine::create();
	albedo_brush_size_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(albedo_brush_size_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Spacing");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_spacing_edit_line = WidgetEditLine::create();
	albedo_brush_spacing_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(albedo_brush_spacing_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Angle");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_angle_edit_line = WidgetEditLine::create();
	albedo_brush_angle_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(albedo_brush_angle_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Opacity");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_opacity_edit_line = WidgetEditLine::create();
	albedo_brush_opacity_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(albedo_brush_opacity_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Color");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("R");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_color_r_edit_line = WidgetEditLine::create();
	albedo_brush_color_r_edit_line->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(albedo_brush_color_r_edit_line, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("G");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_color_g_edit_line = WidgetEditLine::create();
	albedo_brush_color_g_edit_line->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(albedo_brush_color_g_edit_line, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("B");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	albedo_brush_color_b_edit_line = WidgetEditLine::create();
	albedo_brush_color_b_edit_line->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(albedo_brush_color_b_edit_line, Gui::ALIGN_LEFT);


	tab_box->addTab("Height Painter");

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Texture");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	gridbox = WidgetGridBox::create(6);
	tab_box->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_textures.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_textures_icons[i]);
		button->getEventClicked().connect(this, &PaintSample::brush_texture_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Mask");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	gridbox = WidgetGridBox::create(6);
	tab_box->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < brush_masks.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(brush_masks_icons[i]);
		button->getEventClicked().connect(this, &PaintSample::brush_mask_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Size");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_size_edit_line = WidgetEditLine::create();
	height_brush_size_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_size_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Spacing");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_spacing_edit_line = WidgetEditLine::create();
	height_brush_spacing_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_spacing_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Angle");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_angle_edit_line = WidgetEditLine::create();
	height_brush_angle_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_angle_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Opacity");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_opacity_edit_line = WidgetEditLine::create();
	height_brush_opacity_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_opacity_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Height");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_height_edit_line = WidgetEditLine::create();
	height_brush_height_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_height_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Height Scale");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_brush_height_scale_edit_line = WidgetEditLine::create();
	height_brush_height_scale_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(height_brush_height_scale_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Blend Mode");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	height_blend_mode_combo_box = WidgetComboBox::create();
	height_blend_mode_combo_box->addItem("Alpha");
	height_blend_mode_combo_box->addItem("Additive");
	hbox->addChild(height_blend_mode_combo_box);


	tab_box->addTab("Height To Albedo");

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Min Height");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	min_height_edit_line = WidgetEditLine::create();
	min_height_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(min_height_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Max Height");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	max_height_edit_line = WidgetEditLine::create();
	max_height_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	hbox->addChild(max_height_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	tab_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Gradient");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	gridbox = WidgetGridBox::create(6);
	tab_box->addChild(gridbox, Gui::ALIGN_LEFT);
	for (int i = 0; i < gradients.size(); ++i)
	{
		auto button = WidgetButton::create();
		button->setImage(gradiends_icons[i]);
		button->getEventClicked().connect(this, &PaintSample::gradient_button_callback, i);
		gridbox->addChild(button, Gui::ALIGN_LEFT);
	}

	parameters->addChild(tab_box);
}

void PaintSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void PaintSample::tab_box_callback()
{
	switch (tab_box->getCurrentTab())
	{
		case 0: set_mode(Mode::AlbedoPainter); break;
		case 1: set_mode(Mode::HeightPainter); break;
		case 2: set_mode(Mode::HeightToAlbedo); break;
	}
}

void PaintSample::brush_texture_button_callback(int index)
{
	set_brush_texture(brush_textures[index]);
}

void PaintSample::brush_mask_button_callback(int index)
{
	set_brush_mask(brush_masks[index]);
}

void PaintSample::gradient_button_callback(int index)
{
	set_gradient(gradients[index]);
	height_to_albedo->run();
}

void PaintSample::brush_size_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_size(value, true);
}

void PaintSample::brush_spacing_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_spacing(value, false);
}

void PaintSample::brush_angle_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_angle(value, false);
}

void PaintSample::brush_height_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_height(value, false);
}

void PaintSample::brush_height_scale_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_height_scale(value, false);
}

void PaintSample::brush_opacity_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_brush_opacity(value, false);
}

void PaintSample::brush_color_r_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText()) / 255.0f;
	set_brush_color({value, brush_color.y, brush_color.z}, false);
}

void PaintSample::brush_color_g_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText()) / 255.0f;
	set_brush_color({brush_color.x, value, brush_color.z}, false);
}

void PaintSample::brush_color_b_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText()) / 255.0f;
	set_brush_color({brush_color.x, brush_color.y, value}, false);
}

void PaintSample::min_height_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_min_height(value, false);
}

void PaintSample::max_height_edit_line_callback(const Unigine::WidgetPtr &widget)
{
	float value = String::atof(static_ptr_cast<WidgetEditLine>(widget)->getText());
	set_max_height(value, false);
}

void PaintSample::blend_mode_combo_box_callback(const Unigine::WidgetPtr &widget)
{
	switch (static_ptr_cast<WidgetComboBox>(widget)->getCurrentItem())
	{
		case 0: set_height_blend_mode(BlendMode::Alpha); break;
		case 1: set_height_blend_mode(BlendMode::Additive); break;
	}
}

void PaintSample::height_to_albedo_run_button_callback()
{
	height_to_albedo->run();
}

```

## PathCircle.cpp

```cpp
#include "PathCircle.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(PathCircle);

using namespace Unigine;
using namespace Math;


void PathCircle::update()
{
	quat new_rotation = node->getRotation() * quat(0.0f, 0.0f, angular_speed.get() * Game::getIFps());
	Vec3 new_position = node->getPosition() + Vec3(node->getDirection(AXIS::AXIS_Y)) * speed.get() * Game::getIFps();

	Mat4 new_transform;
	composeTransform(new_transform, new_position, new_rotation, vec3_one);
	node->setTransform(new_transform);
}

```

## Pawn.cpp

```cpp
#include "Pawn.h"

#include <UnigineConsole.h>
#include <UnigineRender.h>

REGISTER_COMPONENT(Pawn);

#define DAMAGE_EFFECT_TIME 0.5f

using namespace Unigine;
using namespace Math;

void Pawn::init()
{
	player = Game::getPlayer();
	controls = player->getControls();

	default_model_view = player->getCamera()->getModelview();
	damage_effect_timer = 0;
	show_damage_effect();

	Log::message("PAWN: INIT \"%s\"\n", name.get());
}

void Pawn::update()
{
	// get delta time between frames
	float ifps = Game::getIFps();

	// show damage effect
	if (damage_effect_timer > 0)
	{
		damage_effect_timer = Math::clamp(damage_effect_timer - ifps, 0.0f, DAMAGE_EFFECT_TIME);
		show_damage_effect();
	}

	// if console is opened we disable any controls
	if (Console::isActive())
		return;

	// get the direction vector of the mesh from the second column (y axis) of the transformation
	// matrix
	Vec3 direction = node->getWorldTransform().getColumn3(1);

	// checking controls states and changing pawn position and rotation
	if (controls->getState(Controls::STATE_FORWARD) || controls->getState(Controls::STATE_TURN_UP))
		node->setWorldPosition(node->getWorldPosition() + direction * move_speed * ifps);

	if (controls->getState(Controls::STATE_BACKWARD)
		|| controls->getState(Controls::STATE_TURN_DOWN))
		node->setWorldPosition(node->getWorldPosition() - direction * move_speed * ifps);

	if (controls->getState(Controls::STATE_MOVE_LEFT)
		|| controls->getState(Controls::STATE_TURN_LEFT))
		node->setWorldRotation(node->getWorldRotation() * quat(0.0f, 0.0f, turn_speed * ifps));

	if (controls->getState(Controls::STATE_MOVE_RIGHT)
		|| controls->getState(Controls::STATE_TURN_RIGHT))
		node->setWorldRotation(node->getWorldRotation() * quat(0.0f, 0.0f, -turn_speed * ifps));
}

void Pawn::shutdown()
{
	Log::message("PAWN: DEAD!\n");
}

void Pawn::hit(int damage)
{
	// take damage
	health = health - damage;

	// show effect
	damage_effect_timer = DAMAGE_EFFECT_TIME;
	show_damage_effect();

	// destroy
	if (health <= 0)
		node.deleteLater();

	Log::message("PAWN: damage taken (%d) - HP left (%d)\n", damage, health.get());
}

void Pawn::show_damage_effect()
{
	float strength = damage_effect_timer / DAMAGE_EFFECT_TIME;
	Render::setFadeColor(vec4(0.5f, 0, 0, saturate(strength - 0.5f)));
	player->getCamera()->setModelview(default_model_view
		* Mat4(rotateX(Game::getRandomFloat(-5, 5) * strength)
			* rotateY(Game::getRandomFloat(-5, 5) * strength)));
}

```

## Persecutor.cpp

```cpp
#include "Persecutor.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(PersecutorSkinned);

using namespace Unigine;
using namespace Math;

void PersecutorSkinned::init()
{
	persecutor = static_ptr_cast<ObjectMeshSkinned>(node);
	if (!persecutor)
		Log::error("Persecutor::init(): node is not ObjectMeshSkinned!\n");

	// set persecutor's animation
	persecutor->setNumLayers(2);
	persecutor->setLayerAnimationFilePath(0, persecutorIdleAnim);
	persecutor->setLayerAnimationFilePath(1, persecutorRunAnim);
}

Unigine::Math::Vec3 PersecutorSkinned::getPosition() const
{
	return persecutor->getWorldPosition();
};

Unigine::Math::quat PersecutorSkinned::getRotation() const
{
	return persecutor->getWorldRotation();
};

void PersecutorSkinned::setPosition(const Unigine::Math::Vec3 &new_pos)
{
	persecutor->setWorldPosition(new_pos);
};

void PersecutorSkinned::setRotation(const Unigine::Math::Vec3 &target_dir)
{
	// align forward direction to negative X-axis
	quat target_rot = rotationFromDir(vec3(target_dir), vec3_up) * quat(0, 0, 1, -90.0f);

	// use exponential turning average to set direction
	persecutor->setWorldRotation(slerp(persecutor->getWorldRotation(), target_rot,
		1.0f - Math::exp(-turnRate * Game::getIFps())));
};

void PersecutorSkinned::setAnimation(float persecutor_speed, bool reached_target)
{
	// calculate animation weight for smooth transition
	// animation using simple version of the exponential movement average without "exp" function
	idle_anim_weight = lerp(idle_anim_weight, reached_target ? 1.0f : 0.0f,
		saturate(moveRate * Game::getIFps()));
	persecutor->setLayer(0, 1, idle_anim_weight);
	persecutor->setLayer(1, 1, 1.0f - idle_anim_weight);

	run_anim_time += persecutor_speed * animationSpeed * Game::getIFps();
	persecutor->setLayerFrame(0, 0);
	persecutor->setLayerFrame(1, run_anim_time);
};

```

## PersecutorTarget.cpp

```cpp
#include "PersecutorTarget.h"
#include <UnigineNode.h>
#include <UnigineGame.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(PersecutorTarget);

void PersecutorTarget::init()
{
	player = checked_ptr_cast<PlayerPersecutor>(node);
	if (!player)
	{
		Log::error("%s: component for %s(%d): can be only on PlayerPersecutor node!\n", __FUNCTION__, node->getName(), node->getID());
		return;
	}
	if (!target.get())
	{
		Log::error("%s: component for %s(%d): target is empty!\n", __FUNCTION__, node->getName(), node->getID());
		return;
	}
	target_node = NodeDummy::create();
	player->setTarget(target_node);
	valid = true;

	distance_spread = (player->getMaxDistance() - player->getMinDistance()) * 0.5f;
}

void PersecutorTarget::update()
{
	if (!valid || !target.get())
		return;

	if (Console::isActive() || Game::getPlayer() != player)
		return;

	if (Input::isKeyPressed(Input::KEY_P))
		fixed = !fixed;

	float ifps = Game::getIFps();

	if (lerp_pos)
		target_node->setWorldPosition(lerp(target_node->getWorldPosition(), target->getWorldPosition(), float(lerp_pos_k * ifps)));
	else
		target_node->setWorldPosition(target->getWorldPosition());

	if (wait_angle)
	{
		ivec2 delta = Input::getMouseDeltaPosition();
		ivec4 mdx = ivec4(delta.x, delta.y, Input::getMouseWheel(), Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_RIGHT));

		if (mdx != ivec4_zero || fixed)
		{
			if (!player->isFixed())
				player->setFixed(true);
			timer = wait_angle_time;
		}
		else
		{
			timer -= ifps;
			if (timer <= 0 && player->isFixed())
			{
				player->setFixed(false);
			}
		}
	}

	if (wheel_distance)
	{
		int dt = Input::getMouseWheel();
		if (dt)
		{
			float new_distance = player->getDistance() - dt * ifps * wheel_distance_speed;
			new_distance = clamp(new_distance, wheel_distance_clamp.get().x, wheel_distance_clamp.get().y);
			player->setDistance(new_distance);
			player->setMinDistance(new_distance - distance_spread);
			player->setMaxDistance(new_distance + distance_spread);
		}
	}
}

void PersecutorTarget::shutdown()
{
	if (target_node)
		target_node.deleteLater();
}


```

## PhysicalTracks.cpp

```cpp
#include "PhysicalTracks.h"

#include <UniginePhysics.h>

REGISTER_COMPONENT(PhysicalTracks);

using namespace Unigine;
using namespace Math;

void PhysicalTracks::init()
{
	if (!track_node.get())
		Log::error("PhysicalTracks::init(): can not get targetNode property\n");

	mesh_static = static_ptr_cast<ObjectMeshStatic>(track_node.get());
	if (!mesh_static)
		Log::error("PhysicalTracks::init():TrackNode is not ObjectMeshStatic\n");

//	find transforms to place track plates
	spline.init(node, mesh_static);
	spline.setSpacing(spacing);
	spline.setParentTransform(node->getWorldTransform());
	spline.update();
	auto mesh_transform = spline.getMeshTrasform();

	for (int i = 0; i < mesh_transform.size(); i++)
	{
		auto mesh = mesh_static->clone();
		mesh->setWorldTransform(mesh_transform[i]);
		mesh->setEnabled(true);
		nodes.append(mesh);
	}

	for (int i = 0; i < nodes.size(); i++)
	{
		JointHingePtr joint = JointHinge::create(nodes[i]->getObjectBody(),
			nodes[(i + 1) % nodes.size()]->getObjectBody());

		joint->setWorldAxis(vec3(1.0f, 0.0f, 0.0f));

		joint->setLinearRestitution(0.6f);
		joint->setAngularRestitution(0.4f);
		joint->setLinearSoftness(0.2f);
		joint->setAngularSoftness(0.4f);
		joint->setAngularDamping(8.0f);

		// setting angular limits in degrees
		joint->setAngularLimitFrom(-50.0f);
		joint->setAngularLimitTo(50.0f);

		joint->setAngularSpring(8.0f);
		joint->setNumIterations(16);
	}
}

void PhysicalTracks::shutdown()
{
	for (int i = 0; i < nodes.size(); i++)
		nodes[i].deleteLater();
	nodes.clear();
}

```

## PhysicsMovement.cpp

```cpp
#include "PhysicsMovement.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(PhysicsForceMovement);
REGISTER_COMPONENT(PhysicsImpulseMovement);

//Force movement

void PhysicsForceMovement::init()
{
	rigid = node->getObjectBodyRigid();
}

void PhysicsForceMovement::update()
{
	rigid->setMaxLinearVelocity(max_speed);
	input_direction.y =static_cast<float>(Input::isKeyPressed(Input::KEY_W) - Input::isKeyPressed(Input::KEY_S));
	input_direction.x = static_cast<float>(Input::isKeyPressed(Input::KEY_A) - Input::isKeyPressed(Input::KEY_D));
	brake = Input::isKeyPressed(Input::KEY_SPACE);
}

void PhysicsForceMovement::update_physics()
{
	vec3 forward = node->getWorldDirection(AXIS_Y);
	vec3 up = node->getWorldDirection(AXIS_Z);

	rigid->addForce(forward * input_direction.y * force);
	rigid->addTorque(up * input_direction.x * sign(input_direction.y) * torque);

	rigid->setLinearDamping(brake ? brakes_strenth : 0.0f);
	rigid->setAngularDamping(brake ? brakes_strenth : 0.0f);
}

//Impulse movement

void PhysicsImpulseMovement::init()
{
	rigid = node->getObjectBodyRigid();
}

void PhysicsImpulseMovement::update()
{
	rigid->setMaxLinearVelocity(max_speed);
	input_direction.y = static_cast<float>(Input::isKeyPressed(Input::KEY_W) - Input::isKeyPressed(Input::KEY_S));
	input_direction.x = static_cast<float>(Input::isKeyPressed(Input::KEY_A) - Input::isKeyPressed(Input::KEY_D));
	brake = Input::isKeyPressed(Input::KEY_SPACE);
}

void PhysicsImpulseMovement::update_physics()
{
	vec3 forward = node->getWorldDirection(AXIS_Y);
	vec3 up = node->getWorldDirection(AXIS_Z);

	rigid->addLinearImpulse(forward * input_direction.y * linear_impulse * Physics::getIFps());
	rigid->addAngularImpulse(up * input_direction.x * sign(input_direction.y) * angular_impulse * Physics::getIFps());

	rigid->setLinearDamping(brake ? brakes_strenth : 0.0f);
	rigid->setAngularDamping(brake ? brakes_strenth : 0.0f);
}

```

## PhysicsMovementSample.cpp

```cpp
#include "PhysicsMovementSample.h"

#include "PhysicsMovement.h"


REGISTER_COMPONENT(PhysicsMovementSample);

using namespace Unigine;
using namespace Math;

void PhysicsMovementSample::init()
{
	car_node = car;

	comp_force = ComponentSystem::get()->getComponent<PhysicsForceMovement>(car_node);
	comp_impulse = ComponentSystem::get()->getComponent<PhysicsImpulseMovement>(car_node);

	switch_component(force);
	init_gui();
}

void PhysicsMovementSample::shutdown()
{
	shutdown_gui();
}

void PhysicsMovementSample::init_gui()
{
	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();
	auto hbox = WidgetHBox::create();
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	auto force_button = WidgetButton::create("Force");
	force_button->setToggleable(1);
	auto impulse_button = WidgetButton::create("Impulse");
	impulse_button->setToggleable(1);
	hbox->addChild(force_button);
	hbox->addChild(impulse_button);

	force_button->setToggled(true);

	force_button->getEventClicked().connect(button_connections, [this, force_button, impulse_button]() {
			if (impulse_button->isToggled() == force_button->isToggled())
			{
				impulse_button->setToggled(!force_button->isToggled());
			}
			switch_component(force_button->isToggled());
		});

	impulse_button->getEventClicked().connect(button_connections, 
		[this, impulse_button, force_button]() {
			if (impulse_button->isToggled() == force_button->isToggled())
			{
				force_button->setToggled(!impulse_button->isToggled());
			}
			switch_component(force_button->isToggled());
		});


	sample_description_window.addFloatParameter("Max Speed", "Max Speed", max_speed, 1.0f, 50.f,
		[this](float v) {
			max_speed = v;
			comp_force->max_speed = max_speed;
			comp_impulse->max_speed = max_speed;
		});

	sample_description_window.addFloatParameter("Acceleration", "Acceleration", max_speed, 1.0f, 20.f,
		[this](float v) {
			acceleration = v;
			comp_force->force = acceleration;
			comp_impulse->linear_impulse = acceleration;
		});

	sample_description_window.addFloatParameter("Turn Speed", "Turn Speed", turn_speed, 1.0f, 5.0f,
		[this](float v) {
			turn_speed = v;
			comp_force->torque = turn_speed;
			comp_impulse->angular_impulse = turn_speed;
		});
}

void PhysicsMovementSample::shutdown_gui()
{
	button_connections.disconnectAll();
	sample_description_window.shutdown();
}

void PhysicsMovementSample::switch_component(bool force)
{
	comp_force->setEnabled(force);
	comp_impulse->setEnabled(!force);
}

```

## PlaybackLayersSample.cpp

```cpp
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class PlaybackLayersSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(PlaybackLayersSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		create_animations();

		// create objects for animation
		NodePtr parent_0 = NodeDummy::create();
		NodePtr parent_1 = NodeDummy::create();

		NodePtr box_node_combined = Primitives::createBox(Math::vec3_one);
		box_node_combined->setName("box_node_combined");
		box_node_combined->setID(123);
		box_node_combined->setParent(parent_0);
		parent_0->setWorldPosition(Vec3(-2.0f, 0.0f, 1.75f));

		NodePtr box_node_sequential = Primitives::createBox(Math::vec3_one);
		box_node_sequential->setName("box_node_sequential");
		box_node_sequential->setID(456);
		box_node_sequential->setParent(parent_1);
		parent_1->setWorldPosition(Vec3(2.0f, 0.0f, 1.75f));

		playback_combined->play();
		playback_sequential->play();
	}

	void shutdown()
	{
		playback_combined->stop();
		playback_sequential->stop();
	}

	void create_animations()
	{
		// create animation object
		AnimationObjectNodePtr anim_obj = AnimationObjectNode::create("box");

		// create position track
		AnimationTrackPtr position_track = AnimationTrack::create();
		position_track->addObject(anim_obj);

		auto position_modifier = AnimationModifierScalar::create("node.position_z");
		position_modifier->addValue(0.0f, 0.0f, AnimationCurve::KEY_TYPE_SMOOTH);
		position_modifier->addValue(3.0f, 2.0f, AnimationCurve::KEY_TYPE_SMOOTH);
		position_modifier->addValue(6.0f, 0.0f, AnimationCurve::KEY_TYPE_SMOOTH);
		position_track->addObjectModifier(anim_obj, position_modifier);

		// create rotation track
		AnimationTrackPtr rotation_track = AnimationTrack::create();
		rotation_track->addObject(anim_obj);

		auto rotation_modifier = AnimationModifierQuat::create(AnimationModifierQuat::MODE_QUAT, "node.rotation");
		rotation_modifier->addQuatValue(0.0f, quat(0.0f, 0.0f, 0.0f));
		rotation_modifier->addQuatValue(3.0f, quat(0.0f, 0.f, 180.0f));
		rotation_modifier->addQuatValue(6.0f, quat(0.0f, 0.0f, 360.0f));
		rotation_track->addObjectModifier(anim_obj, rotation_modifier);

		// create scale track
		AnimationTrackPtr scale_track = AnimationTrack::create();
		scale_track->addObject(anim_obj);

		auto scale_modifier = AnimationModifierFVec3::create("node.scale");
		scale_modifier->addValue(0.0f, vec3(1.f, 1.f, 1.f), AnimationCurve::KEY_TYPE_SMOOTH);
		scale_modifier->addValue(3.0f, vec3(1.5f, 1.5f, 0.66f), AnimationCurve::KEY_TYPE_SMOOTH);
		scale_modifier->addValue(6.0f, vec3(1.f, 1.f, 1.f), AnimationCurve::KEY_TYPE_SMOOTH);
		scale_track->addObjectModifier(anim_obj, scale_modifier);

		// create combined playback
		{
			playback_combined = AnimationPlayback::create();
			playback_combined->setLoop(true);

			// each track is added to a new layer and played simultaneously
			playback_combined->setLayerTrack(0, 0, position_track);
			playback_combined->addLayer(rotation_track);
			playback_combined->addLayer(scale_track);

			// bind the animation object to the left node for this combined playback
			AnimationBindNodePtr bind = AnimationBindNode::create();
			bind->setNodeDescription(123, "box_node_combined");
			anim_obj->setPlaybackOverriddenBind(playback_combined, bind);
		}

		// create sequential playback
		{
			playback_sequential = AnimationPlayback::create();
			playback_sequential->setLoop(true);

			// add tracks one after another on one layer
			playback_sequential->setLayerTrack(0, 0, position_track);
			playback_sequential->addLayerTrack(0, rotation_track);
			playback_sequential->addLayerTrack(0, scale_track);

			for (int i = 0; i < playback_sequential->getNumLayerTracks(0); i++)
			{
				playback_sequential->setLayerTrackApplyBefore(0, i, true);
				playback_sequential->setLayerTrackApplyAfter(0, i, true);
			}

			// bind the animation object to the right node for this sequential playback
			AnimationBindNodePtr bind = AnimationBindNode::create();
			bind->setNodeDescription(456, "box_node_sequential");
			anim_obj->setPlaybackOverriddenBind(playback_sequential, bind);
		}
	}

	// ========================================================================================

	AnimationPlaybackPtr playback_combined;
	AnimationPlaybackPtr playback_sequential;
};

REGISTER_COMPONENT(PlaybackLayersSample);

```

## PlayerPersecutorComponent.cpp

```cpp
#include "PlayerPersecutorComponent.h"
#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(PlayerPersecutorComponent);

void PlayerPersecutorComponent::init()
{
	camera = checked_ptr_cast<PlayerDummy>(node);
	
	shape = Unigine::ShapeSphere::create();
	shape->setContinuous(0);
	shape->setCenter(node->getWorldPosition());

	direction = vec3_right;
	distance = 4.0f;
	phi_direction = vec3_right;
	theta_angle = 0.0f;

	setFixed(fixed);
	setCollision(collision);
	setCollisionMask(collision_mask);
	setCollisionRadius(0.5f);

	setAnchor(anchor);
	setMinDistance(min_distance);
	setMaxDistance(max_distance);
	setMinThetaAngle(min_theta_angle);
	setMaxThetaAngle(max_theta_angle);
	setTurning(90.0f);
}

void PlayerPersecutorComponent::update()
{
	if (!target_node || !camera)
		return;
	
	target = target_node->getWorldTransform() * Vec3(anchor);

	BodyRigidPtr body = target_node->getObjectBodyRigid();
	if (body)
		camera->setVelocity(body->getLinearVelocity());
	else
		camera->setVelocity(vec3_zero);

	float phi = 0.0f;
	float theta = 0.0f;

	if (controlled && camera->isMainPlayer() && Input::isMouseCursorHide())
	{
		// direction
		phi = Input::getMouseDeltaPosition().x;
		theta = Input::getMouseDeltaPosition().y;
	}

	float old_min_theta_angle = getMinThetaAngle();
	float old_max_theta_angle = getMaxThetaAngle();

	// fixed angles
	if (isFixed())
	{
		theta_angle += theta;
		theta_angle = clamp(theta_angle, min_theta_angle, max_theta_angle);
		theta += theta_angle - getThetaAngle();

		setMinThetaAngle(theta_angle);
		setMaxThetaAngle(theta_angle);
	}

	// adaptive collision-aware rotation adjustment
	do
	{
		// adaptive step
		float max_distance = max(getCollisionRadius(), getDistance());
		float min_distance = min(getCollisionRadius(), getDistance());

		float angle = max(Math::atan(max_distance / min_distance) * Consts::RAD2DEG * 0.5f, Consts::EPS);
		float p = clamp(phi, -angle, angle);
		float t = clamp(theta, -angle, angle);
		phi -= p;
		theta -= t;

		Vector<ShapeContactPtr> contacts;
		shape->getCollision(contacts, Game::getIFps());

		// update constraints
		update_distance();
		update_angles(p, t);

		// world collision
		contacts.clear();
		if (getCollision())
		{
			for (int i = 0; i < PLAYER_PERSECUTOR_COLLISIONS; i++)
			{
				shape->setCenter(position);
				shape->getCollision(contacts, 0.0f);
				if (contacts.size() == 0)
					break;
				float inum_contacts = 1.0f / Math::itof(contacts.size());
				for (int j = 0; j < contacts.size(); j++)
				{
					const ShapeContact& c = *contacts[j].get();
					position += Vec3(c.getNormal() * (c.getDepth() * inum_contacts));
				}
				update_distance();
				if (isFixed())
					update_angles(-getPhiAngle(), 0.0f);
				else
					update_angles(0.0f, 0.0f);
			}
		}

		// shape position
		shape->setCenter(position);
	} while (Math::abs(phi) > Consts::EPS || Math::abs(theta) > Consts::EPS);

	setMinThetaAngle(old_min_theta_angle);
	setMaxThetaAngle(old_max_theta_angle);

	// applying transform
	flushTransform();
}

void PlayerPersecutorComponent::shutdown()
{
	shape.deleteLater();
}

//////////////////////////////////////////////////////////////////////////
// Parameters
//////////////////////////////////////////////////////////////////////////

void PlayerPersecutorComponent::setFixed(int f)
{
	fixed = f;
	update_transform();
}

void PlayerPersecutorComponent::setTarget(NodePtr n)
{
	target_node = n;
	update_transform();
}

void PlayerPersecutorComponent::setAnchor(const vec3& a)
{
	anchor = a;
	update_transform();
}

//////////////////////////////////////////////////////////////////////////
// Dynamic
//////////////////////////////////////////////////////////////////////////

void PlayerPersecutorComponent::setDistance(float d)
{
	distance = clamp(d, min_distance, max_distance);
	position = target - Vec3(direction * distance);

	flushTransform();
}

void PlayerPersecutorComponent::setPhiAngle(float angle)
{
	if (!target_node)
		return;

	float phi = angle - getPhiAngle();

	
	vec3 up = camera->getUp();

	quat transform = quat(target_node->getWorldTransform());
	phi_direction = (inverse(transform) * quat(up, phi) * transform) * phi_direction;

	direction = quat(up, -phi) * direction;
	position = target - Vec3(direction * distance);

	flushTransform();
}

float PlayerPersecutorComponent::getPhiAngle() const
{
	if (!target_node)
		return 0.0f;

	vec3 up = camera->getUp();

	if (isFixed())
	{
		vec3 d0 = rotation(target_node.get()->getWorldTransform()) * phi_direction;
		vec3 d1 = direction;
		d0 = normalize(d0 - up * dot(up, d0));
		d1 = normalize(d1 - up * dot(up, d1));

		return Math::acos(clamp(dot(d0, d1), -1.0f, 1.0f)) * Math::sign(dot(up, cross(d0, d1))) * Consts::RAD2DEG;
	}
	else
	{
		vec3 tangent, binormal;
		orthoBasis(up, tangent, binormal);

		return Math::atan2(dot(direction, tangent), dot(direction, binormal)) * Consts::RAD2DEG;
	}
}

void PlayerPersecutorComponent::setThetaAngle(float angle)
{
	theta_angle = clamp(angle, min_theta_angle, max_theta_angle);
	float theta = theta_angle - getThetaAngle();

	direction = quat(cross(camera->getUp(), direction), theta) * direction;
	position = target - Vec3(direction * distance);

	flushTransform();
}

float PlayerPersecutorComponent::getThetaAngle() const
{
	return Math::acos(clamp(dot(direction, camera->getUp()), -1.0f, 1.0f)) * Consts::RAD2DEG - 90.0f;
}

void PlayerPersecutorComponent::setViewDirection(const vec3& view)
{
	direction = normalize(view);
	theta_angle = getThetaAngle();
	flushTransform();
}

void PlayerPersecutorComponent::setView(const vec3& view)
{
	direction = normalize(view);

	theta_angle = getThetaAngle();

	flushTransform();
}


//////////////////////////////////////////////////////////////////////////
// Contacts
//////////////////////////////////////////////////////////////////////////


const ShapeContactPtr& PlayerPersecutorComponent::getContact(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContact(): bad contact number");
	return contacts[num];
}

float PlayerPersecutorComponent::getContactDepth(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactDepth(): bad contact number");
	return contacts[num]->getDepth();
}

vec3 PlayerPersecutorComponent::getContactNormal(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactNormal(): bad contact number");
	return contacts[num]->getNormal();
}

ObjectPtr PlayerPersecutorComponent::getContactObject(int num)
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactObject(): bad contact number");
	return contacts[num]->getObject();
}

Vec3 PlayerPersecutorComponent::getContactPoint(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactPoint(): bad contact number");
	return contacts[num]->getPoint();
}

ShapePtr PlayerPersecutorComponent::getContactShape(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactShape(): bad contact number");
	return checked_ptr_cast<Shape>(contacts[num]->getShape1());
}

int PlayerPersecutorComponent::getContactSurface(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerPersecutor::getContactSurface(): bad contact number");
	return contacts[num]->getSurface();
}

//////////////////////////////////////////////////////////////////////////
// Update
//////////////////////////////////////////////////////////////////////////

void PlayerPersecutorComponent::update_distance()
{
	// ortho basis
	vec3 tangent, binormal;
	orthoBasis(camera->getUp(), tangent, binormal);

	// update direction
	direction = vec3(target - position);
	distance = length(direction);
	if (length(vec2(direction)) > Consts::EPS)
		direction /= distance;
	else
		direction = binormal;

	// clamp distance
	distance = clamp(distance, min_distance, max_distance);

	// update position
	position = target - Vec3(direction * distance);
}

void PlayerPersecutorComponent::update_angles(float phi, float theta)
{
	vec3 up = camera->getUp();

	// theta angle
	float theta_angle = getThetaAngle() + theta;

	// clamp theta angle
	if (theta_angle < min_theta_angle)
		theta += min_theta_angle - theta_angle;
	else if (theta_angle > max_theta_angle)
		theta += max_theta_angle - theta_angle;

	// fixed angles
	if (isFixed())
	{
		quat transform = quat(target_node->getWorldTransform());
		phi_direction = normalize(inverse(transform) * quat(up, -phi) * transform) * phi_direction;
		phi = getPhiAngle();
	}

	// update transformation
	direction = (quat(up, -phi) * quat(cross(up, direction), theta)) * direction;
	position = target - Vec3(direction * distance);
}

//////////////////////////////////////////////////////////////////////////
// Transformation
//////////////////////////////////////////////////////////////////////////

void PlayerPersecutorComponent::update_transform()
{
	// update transformation
	if (flush == 0 && target_node)
	{
		// target position
		target = target_node->getWorldTransform() * Vec3(anchor);

		// decompose transformation
		position = node->getWorldTransform().getColumn3(3); 

		// update distance
		update_distance();

		// phi direction
		phi_direction = rotation(target_node->getIWorldTransform()) * direction;

		// update angles
		update_angles(0.0f, 0.0f);

		// theta angle
		theta_angle = getThetaAngle();
	}
}

void PlayerPersecutorComponent::flushTransform()
{
	flush = 1;
	node->setWorldTransform(setTo(position, position + Vec3(direction), camera->getUp()));
	flush = 0;
}

```

## PlayerPersecutorSample.cpp

```cpp
#include "PlayerPersecutorSample.h"
#include "PlayerPersecutorComponent.h"


REGISTER_COMPONENT(PlayerPersecutorSample);

using namespace Unigine;

void PlayerPersecutorSample::init()
{
	mouse_grab_state_at_init = Input::isMouseGrab();
	mouse_handle_at_init = Input::getMouseHandle();
	Input::setMouseGrab(false);
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	description_window.createWindow();

	WidgetGroupBoxPtr group = WidgetGroupBox::create();

	WidgetCheckBoxPtr fixed = WidgetCheckBox::create();
	fixed->setLifetime(Widget::LIFETIME_WORLD);
	fixed->setText(" fixed");
	fixed->getEventChanged().connect(*this, [this, fixed] () {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setFixed(fixed->isChecked());
		}
		});

	WidgetCheckBoxPtr controlled = WidgetCheckBox::create();
	controlled->setLifetime(Widget::LIFETIME_WORLD);
	controlled->setText(" controlled");
	controlled->setChecked(true);
	controlled->getEventChanged().connect(*this, [this, controlled]() {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->controlled = controlled->isChecked();
		}
		});

	WidgetCheckBoxPtr collision = WidgetCheckBox::create();
	collision->setLifetime(Widget::LIFETIME_WORLD);
	collision->setText(" collision");
	collision->setChecked(true);
	collision->getEventChanged().connect(*this, [this, collision]() {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setCollision(collision->isChecked());
		}
		});

	group->addChild(fixed, Gui::ALIGN_LEFT);
	group->addChild(controlled, Gui::ALIGN_LEFT);
	group->addChild(collision, Gui::ALIGN_LEFT);

	description_window.getWindow()->addChild(group);



	description_window.addFloatParameter("Min Distance", "", 1.0f, 0.0f, 50.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setMinDistance(value);
		}
		});

	description_window.addFloatParameter("Max Distance", "", 4.0f, 0.0f, 50.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setMaxDistance(value);
		}
		});

	description_window.addFloatParameter("Min ThetaAngle", "", -89.0f, -89.0f, 89.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setMinThetaAngle(value);
		}
		});

	description_window.addFloatParameter("Max ThetaAngle", "", 89.0f, -89.0f, 89.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setMaxThetaAngle(value);
		}
		});

	description_window.addParameterSpacer();


	description_window.addFloatParameter("Anchor Point X", "", 0.0f, -20.0f, 20.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setAnchor(Unigine::Math::vec3(value, component->getAnchor().y, component->getAnchor().z));
		}
		});

	description_window.addFloatParameter("Anchor Point Y", "", 0.0f, -20.0f, 20.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setAnchor(Unigine::Math::vec3(component->getAnchor().x, value, component->getAnchor().z));
		}
		});

	description_window.addFloatParameter("Anchor Point Z", "", 0.0f, -20.0f, 20.0f, [this](float value) {
		PlayerPersecutorComponent* component = getComponent<PlayerPersecutorComponent>(persecutor);
		if (component)
		{
			component->setAnchor(Unigine::Math::vec3(component->getAnchor().x, component->getAnchor().y, value));
		}
		});

}

void PlayerPersecutorSample::shutdown()
{
	Input::setMouseGrab(mouse_grab_state_at_init);
	Input::setMouseHandle(mouse_handle_at_init);

	description_window.shutdown();
}

```

## PlayersSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineVisualizer.h>
#include <UniginePlayers.h>
#include <UnigineGame.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class PlayersSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(PlayersSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		// get the "material_ball" node from the world to use as a target for persecutor player
		NodePtr target = World::getNodeByName("material_ball");

		if (!target)
			target = NodeDummy::create();

		// create dummy player
		{
			dummy = PlayerDummy::create();

			float z_near = .25f;
			float z_far = 1000.f;
			float fov = 60.f;

			dummy->setProjectionMode(Camera::PROJECTION_MODE_PERSPECTIVE);

			if (true) // configure camera projection parameters
			{
				dummy->setZNear(z_near);
				dummy->setZFar(z_far);
				dummy->setFov(fov);
			}

			else // alternatively you can set up the projection matrix manually
			{
				mat4 projection_matrix = perspective(fov, 1.f, z_near, z_far);
				dummy->setProjection(projection_matrix);
			}

			dummy->setWorldTransform(setTo(rotate(Vec3_up, 0.f * 360.f) * Vec3(3.5f, 0.f, 1.5f), target->getWorldPosition(), vec3_up));
		}

		// create persecutor player
		{
			persecutor = PlayerPersecutor::create();

			persecutor->setFovMode(Camera::FOV_MODE_VERTICAL);
			persecutor->setFov(60.f);

			persecutor->setCollision(true);
			persecutor->setCollisionMask(~0);
			persecutor->setCollisionRadius(.5f);

			persecutor->setFixed(false);
			persecutor->setMaxDistance(8.f);
			persecutor->setMinDistance(3.f);
			persecutor->setAnchor(vec3(0.f, 0.f, 0.5f));

			persecutor->setTarget(target);

			persecutor->setControlled(false);

			persecutor->setWorldTransform(setTo(rotate(Vec3_up, .25f * 360.f) * Vec3(3.5f, 0.f, 1.5f), target->getWorldPosition(), vec3_up));
		}

		// create spectator player
		{
			spectator = PlayerSpectator::create();

			spectator->setFovMode(Camera::FOV_MODE_VERTICAL);
			spectator->setFov(80.f);

			spectator->setAcceleration(5.f);
			spectator->setMaxVelocity(10.f);
			spectator->setDamping(.9f);

			spectator->setCollision(true);
			spectator->setCollisionMask(~0);
			spectator->setCollisionRadius(0.5f);

			spectator->setControlled(false);

			spectator->setWorldTransform(setTo(rotate(Vec3_up, .5f * 360.f) * Vec3(3.5f, 0.f, 1.5f), target->getWorldPosition(), vec3_up));
		}

		// create actor player
		{
			actor = PlayerActor::create();

			actor->setCollision(true);
			actor->setCollisionMask(~0);
			actor->setCollisionRadius(0.5f);
			actor->setCollisionHeight(1.f);

			actor->setPhysical(true);
			actor->setPhysicalMask(~0);
			actor->setPhysicalMass(1.f);

			actor->setMaxVelocity(5.f);

			actor->setJumping(1.5f);

			actor->setControlled(false);

			actor->setWorldTransform(setTo(rotate(Vec3_up, .75f * 360.f) * Vec3(3.5f, 0.f, 1.5f), target->getWorldPosition(), vec3_up));
		}

		actor->setMainPlayer(true);

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
		gui.init(this);
		mouse_handle = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE::MOUSE_HANDLE_GRAB);
	}

	void update()
	{
		visualize_player(dummy);
		visualize_player(persecutor);
		visualize_player(spectator);
		visualize_player(actor);

		gui.update();
	}

	void shutdown()
	{
		gui.shutdown();
		Visualizer::setEnabled(visualizer_enabled);
		Input::setMouseHandle(mouse_handle);
	}

	void visualize_player(PlayerPtr player)
	{
		// render the Player's view frustum and its physical body (if it has one)

		if (!player || Game::getPlayer() == player)
			return;

		vec4 label_color = vec4_white;
		vec4 frustum_color = vec4_white;
		vec4 collision_shape_color = visualize_collision_shapes ? vec4(.97f, .9f, .356f, 1.f) : vec4_zero;
		vec4 persecutor_target_color = visualize_persecutor_target ? vec4(vec3(91, 221, 247) / 255.f, 1.f) : vec4_zero;

		// note that the inverse of the camera's view matrix is the camera's transformation matrix
		Mat4 imodelview = player->getCamera()->getIModelview();
		Vec3 camera_position = imodelview.getTranslate();

		// remember that the aspect correction is usually done automatically on a viewport-specific basis,
		// and the aspect ratio stored in the projection matrix of the cameras is henceforth usually just 1.0,
		// so to get the "correct" projection matrix you need to use the Player::getAspectCorrectedProjection method

		Visualizer::renderFrustum(player->getAspectCorrectedProjection(), imodelview, frustum_color);

		{
			// draw the local basis vectors

			float arrow_size = .6f;
			float arrow_end_size = .15f;
			float arrow_opacity = .8f;

			Vec3 forward = imodelview.getAxisY();
			Vec3 right = imodelview.getAxisX();
			Vec3 up = imodelview.getAxisZ();

			Visualizer::renderVector(camera_position, camera_position + forward * arrow_size, vec4_green * vec4(vec3(1.f), arrow_opacity), arrow_end_size);
			Visualizer::renderVector(camera_position, camera_position + right * arrow_size, vec4_red * vec4(vec3(1.f), arrow_opacity), arrow_end_size);
			Visualizer::renderVector(camera_position, camera_position + up * arrow_size, vec4_blue * vec4(vec3(1.f), arrow_opacity), arrow_end_size);
		}

		switch (player->getType())
		{
			case Node::PLAYER_DUMMY:
			{
				Visualizer::renderMessage3D(camera_position + Vec3_up * .3f, vec3_zero, "Dummy", label_color, 1, 16);

				break;
			}

			case Node::PLAYER_PERSECUTOR:
			{
				PlayerPersecutorPtr persecutor = static_ptr_cast<PlayerPersecutor>(player);

				Visualizer::renderMessage3D(camera_position + Vec3_up * .3f, vec3_zero, "Persecutor", label_color, 1, 16);

				if (persecutor->getCollision())
				{
					Visualizer::renderSphere(
						persecutor->getCollisionRadius(),
						persecutor->getWorldTransform(),
						collision_shape_color
					);
				}

				NodePtr target = persecutor->getTarget();

				if (target)
				{
					WorldBoundBox bbox = target->getWorldBoundBox();

					Visualizer::renderMessage3D(bbox.getCenter() + Vec3_up * (bbox.getSize().y * .5f + .2f), vec3_zero, "Persecutor Target", persecutor_target_color, 1, 16);
					Visualizer::renderNodeBoundBox(target, persecutor_target_color);
				}

				break;
			}

			case Node::PLAYER_SPECTATOR:
			{
				PlayerSpectatorPtr spectator = static_ptr_cast<PlayerSpectator>(player);

				Visualizer::renderMessage3D(camera_position + Vec3_up * .3f, vec3_zero, "Spectator", label_color, 1, 16);

				if (spectator->getCollision())
				{
					Visualizer::renderSphere(
						spectator->getCollisionRadius(),
						spectator->getWorldTransform(),
						collision_shape_color
					);
				}

				break;
			}

			case Node::PLAYER_ACTOR:
			{
				PlayerActorPtr actor = static_ptr_cast<PlayerActor>(player);

				Visualizer::renderMessage3D(camera_position + Vec3_up * .3f, vec3_zero, "Actor", label_color, 1, 16);

				if (actor->getCollision())
				{
					Visualizer::renderCapsule(
						actor->getCollisionRadius(),
						actor->getCollisionHeight(),
						{
							translate(
								actor->getWorldTransform().getAxisZ() * (
									actor->getCollisionRadius() +
									actor->getCollisionHeight() * .5f
								)
							) *
							actor->getWorldTransform(),
						},
						collision_shape_color
					);
				}

				break;
			}

			default: break;
		}
	}

	// ========================================================================================

	struct SampleGui : public EventConnections
	{
		void init(PlayersSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			auto parameters = sample_description_window.getParameterGroupBox();
			auto vbox = WidgetVBox::create();
			parameters->addChild(vbox);

			vbox->addChild(WidgetSpacer::create());

			{
				auto hbox = WidgetHBox::create();

				dummy_btn = WidgetButton::create("Dummy");
				dummy_btn->getEventClicked().connect(this, &SampleGui::on_player_button_clicked);
				dummy_btn->setToggleable(true);
				hbox->addChild(dummy_btn);

				persecutor_btn = WidgetButton::create("Persecutor");
				persecutor_btn->getEventClicked().connect(this, &SampleGui::on_player_button_clicked);
				persecutor_btn->setToggleable(true);
				hbox->addChild(persecutor_btn);

				spectator_btn = WidgetButton::create("Spectator");
				spectator_btn->getEventClicked().connect(this, &SampleGui::on_player_button_clicked);
				spectator_btn->setToggleable(true);
				hbox->addChild(spectator_btn);

				actor_btn = WidgetButton::create("Actor");
				actor_btn->getEventClicked().connect(this, &SampleGui::on_player_button_clicked);
				actor_btn->setToggleable(true);
				actor_btn->runEventClicked(0);
				hbox->addChild(actor_btn);

				vbox->addChild(hbox);
			}

			fov_slider = sample_description_window.addFloatParameter("FOV", "", 60.f, 10.f, 120.f, [](float value) { auto player = Game::getPlayer(); if (player) player->setFov(value); });
			z_far_slider = sample_description_window.addFloatParameter("Far Z", "", 1000.f, 5.f, 1000.f, [](float value) { auto player = Game::getPlayer(); if (player) player->setZFar(value); });
			z_near_slider = sample_description_window.addFloatParameter("Near Z", "", 0.25f, 0.01f, 5.f, [](float value) { auto player = Game::getPlayer(); if (player) player->setZNear(value); });
		}

		void update()
		{
			auto player = Game::getPlayer();

			if (player)
			{
				fov_slider->setValue(int(player->getFov()) * 100);
				z_far_slider->setValue(int(player->getZFar()) * 100);
				z_near_slider->setValue(int(player->getZNear()) * 100);
			}
		}

		void shutdown() { sample_description_window.shutdown(); }

		void on_player_button_clicked(const WidgetPtr &widget, int mouse)
		{
			MUTE_EVENT(dummy_btn->getEventClicked());
			MUTE_EVENT(persecutor_btn->getEventClicked());
			MUTE_EVENT(spectator_btn->getEventClicked());
			MUTE_EVENT(actor_btn->getEventClicked());

			dummy_btn->setToggled(false);
			persecutor_btn->setToggled(false);
			spectator_btn->setToggled(false);
			actor_btn->setToggled(false);

			sample->persecutor->setControlled(false);
			sample->spectator->setControlled(false);
			sample->actor->setControlled(false);

			if (widget == dummy_btn)
			{
				Game::setPlayer(sample->dummy);
				dummy_btn->setToggled(true);
			}

			if (widget == persecutor_btn)
			{

				Game::setPlayer(sample->persecutor);
				sample->persecutor->setControlled(true);
				persecutor_btn->setToggled(true);
			}

			if (widget == spectator_btn)
			{
				Game::setPlayer(sample->spectator);
				sample->spectator->setControlled(true);
				spectator_btn->setToggled(true);
			}

			if (widget == actor_btn)
			{
				Game::setPlayer(sample->actor);
				sample->actor->setControlled(true);
				actor_btn->setToggled(true);
			}
		}

		PlayersSample *sample = nullptr;
		SampleDescriptionWindow sample_description_window;

		WidgetSliderPtr fov_slider;
		WidgetSliderPtr z_far_slider;
		WidgetSliderPtr z_near_slider;

		WidgetButtonPtr dummy_btn;
		WidgetButtonPtr persecutor_btn;
		WidgetButtonPtr spectator_btn;
		WidgetButtonPtr actor_btn;
	};

	// ========================================================================================

	PlayerDummyPtr dummy;
	PlayerPersecutorPtr persecutor;
	PlayerSpectatorPtr spectator;
	PlayerActorPtr actor;

	bool visualizer_enabled = false;
	bool visualize_collision_shapes = true;
	bool visualize_persecutor_target = true;

	SampleGui gui;
	Input::MOUSE_HANDLE mouse_handle;
};

REGISTER_COMPONENT(PlayersSample);

```

## ProceduralMeshApply.cpp

```cpp
#include "ProceduralMeshApply.h"

#include <UnigineGame.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ProceduralMeshApply);


void ProceduralMeshApply::init()
{
	mesh = Mesh::create();
	cluster = ObjectMeshCluster::create();

	// before changing mesh choose Procedural Mode:
	// - Disable - procedural mode is disabled
	// - Dynamic - fastest performance, stored in RAM and VRAM, not automatically unloaded from
	// memory.
	// - Blob - moderate performance, stored in RAM and VRAM, automatically unloaded from memory.
	// - File - slowest performance, all data stored on disk, automatically unloaded from memory.
	cluster->setMeshProceduralMode(ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC);
	cluster->setWorldPosition(Vec3(0.f, 0.f, 3.f));

	// create cluster transforms
	Vector<Mat4> transforms;
	float field_offset = (1.f + offset) * size / 2.f;

	for (int y = 0; y < size; y++)
	{
		for (int x = 0; x < size; x++)
		{
			transforms.append(
				translate(Vec3(x + x * offset - field_offset, y + y * offset - field_offset, 1.5)));
		}
	}

	cluster->appendMeshes(transforms);

	Visualizer::setEnabled(true);
}

void ProceduralMeshApply::update()
{
	// change mesh before applying
	update_mesh(mesh);

	// Apply new mesh. You can do it Force or Async.
	// Changing mesh_render_flag you can choose where to store MeshRender data: in RAM or VRAM
	// 0 - store everything in VRAM (default behavior)
	// USAGE_DYNAMIC_VERTEX - store vertices on RAM
	// USAGE_DYNAMIC_INDICES - store indices on RAM
	// USAGE_DYNAMIC_ALL - store both vertices and indices on RAM
	cluster->applyMoveMeshProceduralAsync(mesh, 0);
	Visualizer::renderObject(cluster, vec4_green);
}

void ProceduralMeshApply::shutdown()
{
	mesh.clear();
	cluster.deleteLater();

	Visualizer::setEnabled(false);
}

void ProceduralMeshApply::update_mesh(MeshPtr mesh)
{
	current_time += Game::getIFps();

	if (current_time > change_rate)
	{
		current_time = 0.f;

		num_slices = is_increasing ? num_slices + 1 : num_slices - 1;
		num_stacks = is_increasing ? num_stacks + 1 : num_stacks - 1;

		if (num_stacks == max_num_stacks)
			is_increasing = false;

		if (num_stacks <= min_num_stacks)
		{
			is_increasing = true;
			num_stacks = min_num_stacks;
			num_slices = num_stacks + 1;
		}
	}

	mesh->clear();
	mesh->addSphereSurface("sphere", radius, num_stacks, num_slices);
}

```

## ProceduralMeshGenerator.cpp

```cpp
#include "ProceduralMeshGenerator.h"

#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ProceduralMeshGenerator);


constexpr float B2MB = 1.f / (1024 * 1024);

void ProceduralMeshGenerator::init()
{
	num_objects = size * size;
	new_size = size;

	init_gui();
}

void ProceduralMeshGenerator::update()
{
	// check that all objects are created
	if (is_creating_objects && num_created_objects == num_objects)
	{
		set_gui_enabled(true);
		is_creating_objects = false;
	}

	// check that deleting of all objects is finished
	if (is_deleting_done)
	{
		is_deleting_done = false;
		if (is_creating_objects)
			create_objects();
		else
			set_gui_enabled(true);
	}

	// change to new filed size if there are no active object creation processes
	if (!is_creating_objects && new_size != size)
	{
		size = new_size;
		num_objects = size * size;
	}

	// update memory usage statistic
	update_stats();
}

void ProceduralMeshGenerator::shutdown()
{
	clear_objects();
	shutdown_gui();
}

void ProceduralMeshGenerator::create_objects()
{
	is_creating_objects = true;

	if (box_objects.size() > 0)
	{
		clear_objects();
		return;
	}

	float field_offset = (1.f + offset) * size / 2.f;

	box_objects.reserve(num_objects);
	for (int x = 0; x < size; x++)
	{
		for (int y = 0; y < size; y++)
		{
			auto obj = ObjectMeshStatic::create();
			obj->setWorldPosition(
				Vec3(x + x * offset - field_offset, y + y * offset - field_offset, 1.5));

			obj->setMeshProceduralMode(current_mode);

			// this method will itself generate new mesh by create_mesh callback, load MeshRender,
			// apply new mesh to object and then call create_done callback when everything is done
			obj->runGenerateMeshProceduralAsync(
				MakeCallback(this, &ProceduralMeshGenerator::create_mesh),
				MakeCallback(this, &ProceduralMeshGenerator::create_done, obj), current_mesh_render_flag);

			box_objects.append(obj);
		}
	}
}

void ProceduralMeshGenerator::create_mesh(MeshPtr mesh)
{
	mesh->addBoxSurface("box", vec3(1));

	// dynamic procedural meshes are constantly stored in memory, so we can calculate it's memory
	// usage right after creation
	if (current_mode != ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC)
		return;
	dynamic_ram += mesh->getMemoryUsage();
}

void ProceduralMeshGenerator::create_done(ObjectMeshStaticPtr obj)
{
	num_created_objects++;

	// dynamic procedural meshes are constantly stored in memory, so we can calculate it's memory
	// usage right after creation; file and blob procedural meshes don't occupy vram till active
	if (current_mode != ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC)
		return;

	MeshRenderPtr m_vram = obj->getMeshCurrentVRAM();
	if (m_vram)
	{
		dynamic_ram += m_vram->getSystemMemoryUsage();
		dynamic_vram += m_vram->getVideoMemoryUsage();
	}
}

void ProceduralMeshGenerator::clear_objects()
{
	num_created_objects = 0;
	dynamic_ram = 0;
	dynamic_vram = 0;

	for (auto &obj : box_objects)
	{
		obj.deleteLater();
	}
	box_objects.clear();
	is_deleting_done = true;
}

void ProceduralMeshGenerator::update_stats()
{
	int ram = 0, active_vram = 0;
	auto &stat = Render::getStreamingStatistics();

	switch (last_mode)
	{
	// Memory usage by Dynamic procedural meshes was already calculated right after meshes creation
	// and is constant throught all the time we use these meshes
	case Unigine::ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC:
		ram = int(dynamic_ram * B2MB);
		active_vram = int(dynamic_vram * B2MB);
		break;
	// File and Blob procedural meshes occupy memory only when thea are activce, otherwise they
	// are unloaded to cache
	case Unigine::ObjectMeshStatic::PROCEDURAL_MODE_BLOB:
	case Unigine::ObjectMeshStatic::PROCEDURAL_MODE_FILE:
		ram = int(stat.static_meshes.ram.active * B2MB);
		active_vram = int(stat.static_meshes.vram.active * B2MB);
		break;
	default: break;
	}

	String status = String::format("Num ready objects: %d\nRAM: %d MB\nVRAM Active: %d MB",
		num_created_objects.fetch(), ram, active_vram);
	sample_description_window.setStatus(status);
}

void ProceduralMeshGenerator::init_gui()
{
	sample_description_window.createWindow(Gui::ALIGN_RIGHT);
	auto params = sample_description_window.getParameterGroupBox();

	auto gridbox = WidgetGridBox::create(2, 10);
	params->addChild(gridbox);

	//	--------Procedural Mode Selector--------
	modes_map["Dynamic"] = ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC;
	modes_map["File"] = ObjectMeshStatic::PROCEDURAL_MODE_FILE;
	modes_map["Blob"] = ObjectMeshStatic::PROCEDURAL_MODE_BLOB;

	auto label = WidgetLabel::create("Procedural Mode");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	mode_combo = WidgetComboBox::create();
	mode_combo->addItem("Dynamic");
	mode_combo->addItem("File");
	mode_combo->addItem("Blob");
	gridbox->addChild(mode_combo, Gui::ALIGN_EXPAND);

	current_mode = ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC;
	mode_combo->setCurrentItem(0);
	mode_combo->getEventChanged().connect(*this, [this]() {
		auto item = mode_combo->getCurrentItemText();
		current_mode = modes_map[item];
	});

	//	--------MeshRender Dynamic Usage Selector--------
	flags_map["None"] = 0;
	flags_map["DYNAMIC_VERTEX"] = MeshRender::USAGE_DYNAMIC_VERTEX;
	flags_map["DYNAMIC_INDICES"] = MeshRender::USAGE_DYNAMIC_INDICES;
	flags_map["DYNAMIC_ALL"] = MeshRender::USAGE_DYNAMIC_ALL;

	label = WidgetLabel::create("MeshRender Flag");
	gridbox->addChild(label, Gui::ALIGN_LEFT);
	
	flags_combo = WidgetComboBox::create();
	flags_combo->addItem("None");
	flags_combo->addItem("DYNAMIC_VERTEX");
	flags_combo->addItem("DYNAMIC_INDICES");
	flags_combo->addItem("DYNAMIC_ALL");
	gridbox->addChild(flags_combo, Gui::ALIGN_EXPAND);
	
	current_mesh_render_flag = 0;
	flags_combo->setCurrentItem(0);
	flags_combo->getEventChanged().connect(*this, [this]() {
		auto item = flags_combo->getCurrentItemText();
		current_mesh_render_flag = flags_map[item];
	});

	//	--------Fiels Size Input--------
	label = WidgetLabel::create("Field Size");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	auto spinbox_hbox = WidgetHBox::create();
	gridbox->addChild(spinbox_hbox, Gui::ALIGN_EXPAND);

	spinbox = WidgetSpinBox::create(1, 1000);
	spinbox->setValue(size);
	spinbox->getEventChanged().connect(*this, [this]() { new_size = spinbox->getValue(); });

	editline = WidgetEditLine::create();
	editline->setValidator(Gui::VALIDATOR_UINT);
	editline->getEventFocusOut().connect(*this, [this]() {
		int text = atoi(editline->getText());
		new_size = clamp(text, spinbox->getMinValue(), spinbox->getMaxValue());
		if (text != new_size)
			editline->setText(String::itoa(new_size));
	});
	editline->setText(String::itoa(size));
	editline->addAttach(spinbox);

	spinbox_hbox->addChild(editline);
	spinbox_hbox->addChild(spinbox, Gui::ALIGN_EXPAND);

	//	--------Spacer--------
	auto spacer = WidgetSpacer::create();
	spacer->setOrientation(1);
	params->addChild(spacer, Gui::ALIGN_EXPAND);

	//	--------Create buttons--------
	auto hbox = WidgetHBox::create(10);
	params->addChild(hbox, Gui::ALIGN_EXPAND);
	generate_button = WidgetButton::create("Generate");
	generate_button->getEventClicked().connect(this, &ProceduralMeshGenerator::on_generate_button);
	hbox->addChild(generate_button, Gui::ALIGN_EXPAND);
	clear_button = WidgetButton::create("Clear");
	clear_button->getEventClicked().connect(this, &ProceduralMeshGenerator::on_clear_button);
	hbox->addChild(clear_button, Gui::ALIGN_EXPAND);
}

void ProceduralMeshGenerator::shutdown_gui()
{
	sample_description_window.shutdown();
	modes_map.clear();
	flags_map.clear();
}

void ProceduralMeshGenerator::set_gui_enabled(bool enabled)
{
	generate_button->setEnabled(enabled);
	clear_button->setEnabled(enabled);
}

void ProceduralMeshGenerator::on_generate_button()
{
	set_gui_enabled(false);

	last_mode = current_mode;

	create_objects();
}

void ProceduralMeshGenerator::on_clear_button()
{
	set_gui_enabled(false);
	clear_objects();
}

```

## ProceduralMeshModifier.cpp

```cpp
#include "ProceduralMeshModifier.h"

#include <UnigineAsyncQueue.h>
#include <UnigineGame.h>
#include <UnigineProfiler.h>
#include <UnigineThread.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ProceduralMeshModifier);


void ProceduralMeshModifier::init()
{
	init_gui();

	is_deleted = false;
	updated_meshvram_manual = is_meshvram_manual;

	isize = 30.f / size;

	mesh_ram = Mesh::create();
	mesh_vram = MeshRender::create();
	object = ObjectMeshStatic::create();
	object->setMeshProceduralMode(current_mode);
	object->setWorldPosition(Vec3_one);
}

void ProceduralMeshModifier::update()
{
	UNIGINE_PROFILER_FUNCTION;

	// check if mesh modification or applying is already in active state
	if (is_running || object->isMeshProceduralActive())
		return;

	is_running = true;

	is_meshvram_manual = updated_meshvram_manual;

	// set new procedural mode if needed
	if (object->getMeshProceduralMode() != current_mode)
	{
		object.deleteLater();
		object = ObjectMeshStatic::create();
		object->setMeshProceduralMode(current_mode);
		object->setWorldPosition(Vec3_one);
	}

	// check if mesh must be generated on Background or Main thread
	if (is_thread_async)
	{
		// updates mesh on Background thread without blocking Main thread
		// mesh modification will be executed on different thread for as long as it's needed without
		// affecting perfomance
		AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_BACKGROUND,
			MakeCallback(this, &ProceduralMeshModifier::async_update_ram));
	}
	else
	{
		// updates mesh in current frame before update ends
		update_ram();
		if (is_meshvram_manual)
			update_vram();
		apply_data();
	}
}

void ProceduralMeshModifier::shutdown()
{
	// signal for other threads that shutdown() was called on Main thread
	is_deleted = true;

	shutdown_gui();

	// if there is some active mesh modification in progress, wait till it's finished before
	// clearing meshes
	mesh_lock.wait();

	mesh_ram.clear();
	mesh_vram.clear();
	object.deleteLater();
}

void ProceduralMeshModifier::update_mesh(MeshPtr mesh)
{
	UNIGINE_PROFILER_FUNCTION;

	float time = Game::getTime();

	if (mesh->getNumSurfaces() != 1)
	{
		mesh->clear();
		mesh->addSurface("");
	}
	else
	{
		mesh->clearSurface();
	}

	auto &vertices = mesh->getVertices();
	vertices.reserve(size * size);

	for (int y = 0; y < size; y++)
	{
		float Y = y * isize - 15.0f;
		float Z = cos(Y + time);

		for (int x = 0; x < size; x++)
		{
			float X = x * isize - 15.0f;
			vertices.append(vec3(X, Y, Z * sin(X + time)));
		}
	}

	// reserve enough memory for indices so vector won't be reallocated every time it's capacity
	// ends
	auto &cindices = mesh->getCIndices();
	cindices.reserve((size - 1) * (size - 1) * 6);
	auto &tindices = mesh->getTIndices();
	tindices.reserve((size - 1) * (size - 1) * 6);

	auto addIndex = [&cindices, &tindices](int index) {
		cindices.append(index);
		tindices.append(index);
	};

	for (int y = 0; y < size - 1; y++)
	{
		int offset = size * y;
		for (int x = 0; x < size - 1; x++)
		{
			addIndex(offset);
			addIndex(offset + 1);
			addIndex(offset + size);
			addIndex(offset + size);
			addIndex(offset + 1);
			addIndex(offset + size + 1);
			offset++;
		}
	}

	mesh->createTangents();

	{
		UNIGINE_PROFILER_SCOPED("CreateCollisionData");

		// if you plan to use intersection and collision with this mesh then it's better to create
		// CollisionData. Otherwise intersections and collisions would be highly ineffective in
		// terms of perfomance
		if (is_collision_enabled)
		{
			// creates both Spatial Tree and Edges for effective intersection and collision
			// respectively
			mesh->createCollisionData();

			// you can create only Spatial Tree if you need only intersection
			//		mesh->createSpatialTree();
			// or you can create only Edges if you need only collision
			//		mesh->createEdges();
		}
		else
			// or you can create mesh without collision data or even delete existing one if there is
			// no need for it.
			// to check if mesh has collisionData you can use:
			//		mesh->hasCollisionData();
			//		mesh->hasSpatialTree();
			//		mesh->hasEdges();
			mesh->clearCollisionData();
	}

	mesh->createBounds();
}

void ProceduralMeshModifier::update_ram()
{
	UNIGINE_PROFILER_FUNCTION;

	// check that Main thread is stil active
	if (is_deleted.fetch())
		return;

	// lock mesh_ram so other threads won't interfere mesh update
	ScopedLock sl(mesh_lock);
	update_mesh(mesh_ram);
}

void ProceduralMeshModifier::update_vram()
{
	UNIGINE_PROFILER_FUNCTION;

	// check that Main thread is stil active
	if (is_deleted.fetch())
		return;

	// lock so other threads won't interfere mesh update
	ScopedLock sl(mesh_lock);
	mesh_vram->load(mesh_ram);
}

void ProceduralMeshModifier::async_update_ram()
{
	// modify mesh
	update_ram();

	if (is_meshvram_manual)
	{
		// if you need to load MeshRender manualy, do it on GPU_STREAM thread
		AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_GPU_STREAM,
			MakeCallback(this, &ProceduralMeshModifier::async_update_vram));
	}
	else
	{
		// if you don't need to load MeshRender manualy and automatic loading inside
		// apllyMeshProcedural methods is enough then return to Main thread
		AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_MAIN, MakeCallback([this, check = node]() {
			// check that sample's logic on Main thread is still alive. If it's not then stop
			// modification and return
			if (!check || check.isDeleted())
				return;
			apply_data();
		}));
	}
}

void ProceduralMeshModifier::async_update_vram()
{
	// update MeshRender
	update_vram();

	// return to Main thread to apply new mesh
	AsyncQueue::runAsync(AsyncQueue::ASYNC_THREAD_MAIN, MakeCallback([this, check = node]() {
		// check that sample's logic on Main thread is still alive. If it's not then stop
		// modification and return
		if (!check || check.isDeleted())
			return;
		apply_data();
	}));
}

// apply procedural mesh only on Main thread!
void ProceduralMeshModifier::apply_data()
{
	UNIGINE_PROFILER_FUNCTION;

	// if apply happens in async mode it will be processed on another thread without blocking Main
	// thread. Otherwise in Force mode Main thread won't leave the scope of this function until
	// apply is finished.

	if (is_async_mode)
	{
		if (is_meshvram_manual)
		{
			// you can use manualy created MeshRender only in Move mode
			object->applyMoveMeshProceduralAsync(mesh_ram, mesh_vram);
		}
		else
		{
			if (is_copy_mode)
				// with Copy mode data from mesh_ram will be copied for internal use and mesh_ram
				// itself won't be changed
				object->applyCopyMeshProceduralAsync(mesh_ram, current_mesh_render_flag);
			else
				// with Move mode data will be taken from mesh_ram for internal use so mesh_ram
				// will change
				object->applyMoveMeshProceduralAsync(mesh_ram, current_mesh_render_flag);
		}
	}
	else
	{
		if (is_meshvram_manual)
		{
			object->applyMoveMeshProceduralForce(mesh_ram, mesh_vram);
		}
		else
		{
			if (is_copy_mode)
				object->applyCopyMeshProceduralForce(mesh_ram, current_mesh_render_flag);
			else
				object->applyMoveMeshProceduralForce(mesh_ram, current_mesh_render_flag);
		}
	}

	// full cycle of mesh modification is finished
	is_running = false;
}

void ProceduralMeshModifier::init_gui()
{
	sample_description_window.createWindow(Gui::ALIGN_RIGHT);
	auto params = sample_description_window.getParameterGroupBox();

	auto gridbox = WidgetGridBox::create(2, 10);
	params->addChild(gridbox, Gui::ALIGN_EXPAND);

	//	--------Async/Force Mode Selector--------
	auto label = WidgetLabel::create("Thread");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	thread_combo = WidgetComboBox::create();
	thread_combo->addItem("Main");
	thread_combo->addItem("Background");
	gridbox->addChild(thread_combo, Gui::ALIGN_EXPAND);

	thread_combo->setCurrentItem(1);
	thread_combo->getEventChanged().connect(*this, [this]() {
		int item = thread_combo->getCurrentItem();
		is_thread_async = item != 0;
	});

	//	--------Procedural Mode Selector--------
	modes_map["Dynamic"] = ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC;
	modes_map["File"] = ObjectMeshStatic::PROCEDURAL_MODE_FILE;
	modes_map["Blob"] = ObjectMeshStatic::PROCEDURAL_MODE_BLOB;

	label = WidgetLabel::create("Procedural Mode");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	mode_combo = WidgetComboBox::create();
	mode_combo->addItem("Dynamic");
	mode_combo->addItem("File");
	mode_combo->addItem("Blob");
	gridbox->addChild(mode_combo, Gui::ALIGN_EXPAND);

	current_mode = ObjectMeshStatic::PROCEDURAL_MODE_DYNAMIC;
	mode_combo->setCurrentItem(0);
	mode_combo->getEventChanged().connect(*this, [this]() {
		auto item = mode_combo->getCurrentItemText();
		current_mode = modes_map[item];
	});

	//	--------MeshRender Flag Selector--------
	usage_map["None"] = 0;
	usage_map["DYNAMIC_VERTEX"] = MeshRender::USAGE_DYNAMIC_VERTEX;
	usage_map["DYNAMIC_INDICES"] = MeshRender::USAGE_DYNAMIC_INDICES;
	usage_map["DYNAMIC_ALL"] = MeshRender::USAGE_DYNAMIC_ALL;

	label = WidgetLabel::create("MeshRender Flag");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	usage_combo = WidgetComboBox::create();
	usage_combo->addItem("None");
	usage_combo->addItem("DYNAMIC_VERTEX");
	usage_combo->addItem("DYNAMIC_INDICES");
	usage_combo->addItem("DYNAMIC_ALL");
	gridbox->addChild(usage_combo, Gui::ALIGN_EXPAND);

	current_mesh_render_flag = 0;
	usage_combo->setCurrentItem(0);
	usage_combo->getEventChanged().connect(*this, [this]() {
		auto item = usage_combo->getCurrentItemText();
		current_mesh_render_flag = usage_map[item];
	});

	//	--------Async/Force Mode Selector--------
	label = WidgetLabel::create("Async Mode");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	async_combo = WidgetComboBox::create();
	async_combo->addItem("Async");
	async_combo->addItem("Force");
	gridbox->addChild(async_combo, Gui::ALIGN_EXPAND);

	async_combo->setCurrentItem(0);
	async_combo->getEventChanged().connect(*this, [this]() {
		int item = async_combo->getCurrentItem();
		is_async_mode = item == 0;
	});

	//	--------MeshRender Dynamic Usage Selector--------
	label = WidgetLabel::create("Apply mode");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	move_combo = WidgetComboBox::create();
	move_combo->addItem("Copy");
	move_combo->addItem("Move");
	gridbox->addChild(move_combo, Gui::ALIGN_EXPAND);

	is_copy_mode = true;
	move_combo->setCurrentItem(0);
	move_combo->getEventChanged().connect(*this, [this]() {
		auto item = move_combo->getCurrentItem();
		is_copy_mode = item == 0;
	});

	//	--------Create Collision Data--------
	label = WidgetLabel::create("Create CollisionData");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	auto collison_checkbox = WidgetCheckBox::create();
	gridbox->addChild(collison_checkbox, Gui::ALIGN_EXPAND);
	collison_checkbox->getEventChanged().connect(*this,
		[this, collison_checkbox]() { is_collision_enabled = collison_checkbox->isChecked(); });

	//	--------Create MeshRender Manualy--------
	label = WidgetLabel::create("Manual MeshRender");
	gridbox->addChild(label, Gui::ALIGN_LEFT);

	meshvram_checkbox = WidgetCheckBox::create();
	gridbox->addChild(meshvram_checkbox, Gui::ALIGN_EXPAND);
	meshvram_checkbox->getEventChanged().connect(*this, [this]() {
		updated_meshvram_manual = meshvram_checkbox->isChecked();
		warning_label->setHidden(!updated_meshvram_manual);
	});

	//	--------Create MeshRender Warning--------
	warning_label = WidgetLabel::create("MeshRender can be used only with mode \"Move\". Apply mode "
										"\"Copy\" will be ignored ");
	warning_label->setFontWrap(1);
	warning_label->setHidden(true);
	warning_label->setFontColor(vec4_red);

	params->setFontWrap(1);
	params->addChild(warning_label, Gui::ALIGN_EXPAND);
}

void ProceduralMeshModifier::shutdown_gui()
{
	sample_description_window.shutdown();
}

```

## Projectile.cpp

```cpp
#include "Projectile.h"

#include "Pawn.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(Projectile);

using namespace Unigine;
using namespace Math;

void Projectile::updateSyncThread()
{
	// get delta time between frames
	float ifps = Game::getIFps();

	// get the direction vector of the mesh from the second column (y axis) of the transformation
	// matrix
	Vec3 direction = node->getWorldTransform().getColumn3(1);

	// move forward
	node->setWorldPosition(node->getWorldPosition() + direction * speed * ifps);

	// lifetime update
	lifetime = lifetime - ifps;
}

void Projectile::update()
{
	// lifetime process
	if (lifetime < 0)
	{
		// destroy current node with its properties and components
		node.deleteLater();
		return;
	}

	// check the intersection with nodes
	VectorStack<NodePtr> nodes; // VectorStack much more faster than Vector, but has some limits
	World::getIntersection(node->getWorldBoundBox(), nodes);
	if (nodes.size() > 1) // (because the current node is also in this list)
	{
		for (int i = 0; i < nodes.size(); i++)
		{
			Pawn *pawn = getComponent<Pawn>(nodes[i]);
			if (pawn)
			{
				// hit the player!
				pawn->hit(damage);

				// ...and destroy current node
				node.deleteLater();
				return;
			}
		}
	}
}

void Projectile::setMaterial(const MaterialPtr &mat)
{
	checked_ptr_cast<Object>(node)->setMaterial(mat, "*");
}

```

## PropertyAnimationSample.cpp

```cpp
#include <UnigineGame.h>
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class PropertyAnimationSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(PropertyAnimationSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		// create tracks and playback
		create_animations();

		// create object for animation
		box = Primitives::createBox(vec3(1.0f, 1.0f, 1.0f));
		box->setID(123);
		box->setName("box");
		box->setWorldPosition(Vec3(0.f, 0.f, 1.15f));

		PropertyPtr prop = Properties::findPropertyByPath(joinPaths(getWorldRootPath(), "properties", "speed_prop.prop"));
		box->addProperty(prop);

		playback->play();

		gui.init(this);
	}

	void update()
	{
		PropertyPtr prop = box->getProperty();
		float speed = prop->getParameterPtr("speed")->getValueFloat();

		box->worldRotate(0.f, 0.f, speed * Game::getIFps());

		gui.update();
	}

	void shutdown()
	{
		gui.shutdown();
		playback->stop();
	}

	void create_animations()
	{
		// create new track
		AnimationTrackPtr track = AnimationTrack::create();

		// create property parameter animation object and add it to the track
		AnimationObjectPropertyParameterPtr anim_obj = AnimationObjectPropertyParameter::create("param");
		track->addObject(anim_obj);

		// bind the animation object to our node and property
		AnimationBindPropertyParameterPtr bind = anim_obj->getBind();
		bind->setAccess(AnimationBindPropertyParameter::ACCESS_FROM_NODE);
		bind->setNodePropertyDescription("speed_prop", 0);
		bind->setNodeDescription(123, "box");
		bind->setParameterPath("speed");
		anim_obj->setBind(bind);

		// animate speed value
		AnimationModifierFloatPtr param_modifier = AnimationModifierFloat::create("property_parameter.value_float");
		param_modifier->addValue(0.0f, 0.0f);
		param_modifier->addValue(3.0f, 120.0f);
		param_modifier->addValue(9.0f, -120.0f);
		param_modifier->addValue(12.0f, 0.0f);
		track->addObjectModifier(anim_obj, param_modifier);

		// create playback for track
		playback = AnimationPlayback::create();
		playback->setTrack(track);
		playback->setLoop(true);
	}

	// ========================================================================================

	struct SampleGui
	{
		void init(PropertyAnimationSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			auto w = sample_description_window.getWindow();
			auto state_gbox = WidgetGroupBox::create("State", 9, 3);
			w->addChild(state_gbox);

			auto gridbox = WidgetGridBox::create(2);
			state_gbox->addChild(gridbox, Gui::ALIGN_LEFT);

			auto add_parameter = [](const WidgetGridBoxPtr &gridbox, const char *name) {
				auto hbox = WidgetHBox::create();

				hbox->addChild(WidgetLabel::create(name));
				hbox->addChild(WidgetHBox::create(6));

				gridbox->addChild(hbox, Gui::ALIGN_LEFT);

				auto bg_color = WidgetEditLine::create();
				bg_color->setEditable(false);
				bg_color->setFontVOffset(-2);
				bg_color->setFontColor(vec4(vec3(.9f), 1.f));
				bg_color->setWidth(50);

				gridbox->addChild(bg_color, Gui::ALIGN_LEFT);
				return bg_color;
			};

			speed = add_parameter(gridbox, "speed_prop.speed");
		}

		void update()
		{
			PropertyPtr prop = sample->box->getProperty();
			float prop_speed = prop->getParameterPtr("speed")->getValueFloat();

			speed->setText(String::format("%.2f", prop_speed));
		}

		void shutdown() { sample_description_window.shutdown(); }

		PropertyAnimationSample *sample = nullptr;
		SampleDescriptionWindow sample_description_window;
		WidgetEditLinePtr speed;
	};

	NodePtr box;
	AnimationPlaybackPtr playback;
	SampleGui gui;
};

REGISTER_COMPONENT(PropertyAnimationSample);

```

## RadioButtons.cpp

```cpp
#include "RadioButtons.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(RadioButtons)

using namespace Unigine;

void RadioButtons::init()
{
	auto gui = WindowManager::getMainWindow()->getGui();

	p_vertical_layout = WidgetVBox::create(horizontal_layout_space.get(), vertical_layout_space.get());

	gui->addChild(p_vertical_layout, Gui::ALIGN_OVERLAP);

	p_vertical_layout->setPosition(widget_position.get().x, widget_position.get().y);
	p_vertical_layout->setBackground(1);

	p_first_rbutton = WidgetCheckBox::create(first_rbutton_text.get());
	p_first_rbutton->setChecked(true); // Set the first checkbox as selected by default

	p_vertical_layout->addChild(p_first_rbutton, Gui::ALIGN_LEFT);

	p_first_rbutton->setFontSize(font_size.get());

	p_first_rbutton->getEventChanged().connect(*this, [this]() {
		if (p_first_rbutton->isChecked())
			Console::onscreenMessageLine("Radio buttons: first option");
	});

	p_second_rbutton = WidgetCheckBox::create(second_rbutton_text.get());

	p_vertical_layout->addChild(p_second_rbutton, Gui::ALIGN_LEFT);
	p_first_rbutton->addAttach(p_second_rbutton); // Attach the second checkbox to the first to group them as radio buttons

	p_second_rbutton->setFontSize(font_size.get());

	p_second_rbutton->getEventChanged().connect(*this, [this]() {
		if (p_second_rbutton->isChecked())
			Console::onscreenMessageLine("Radio buttons: second option");
	});


	Console::setOnscreen(true);
}

void RadioButtons::shutdown()
{
	p_vertical_layout.deleteLater();
	Console::setOnscreen(false);
}

```

## RayIntersection.cpp

```cpp
#include "RayIntersection.h"

REGISTER_COMPONENT(RayIntersection)

using namespace Unigine;
using namespace Math;

void RayIntersection::init()
{
	// check parts of laser
	if (!laser_ray || !laser_hit)
	{
		Log::error("laser_ray or laser_hit is missing");
		return;
	}

	// create an intersection object to obtain the necessary information
	// about the intersection result
	intersection = WorldIntersectionNormal::create();

	// save the source laser ray scale for changing length after intersection
	laser_ray_scale = laser_ray->getWorldScale();

	init_gui();
}

void RayIntersection::update()
{
	// check parts of laser
	if (!laser_ray || !laser_hit)
		return;

	// get points to detect intersection based on the direction of the laser ray
	Vec3 first_point = laser_ray->getWorldPosition();
	Vec3 second_point =
		first_point + Vec3(laser_ray->getWorldDirection(AXIS_Y)) * laser_distance;

	// try to get intersection object
	ObjectPtr hit_object = World::getIntersection(
		first_point, second_point, intersection_mask, intersection);
	if (hit_object)
	{
		// show hit_object name and color it
		// int wall_idx = log2(hit_object->getIntersectionMask(0));
		int wall_idx = hit_object->getParent()->getChildIndex(hit_object);
		current_hit->setText(String::format(
				"Current Hit Object: <b><font color=\"%s\">%s</font></b>",
				colors[wall_idx], walls[wall_idx]).get());

		// set current laser ray length
		float length =
			(intersection->getPoint() - laser_ray->getWorldPosition()).length();
		laser_ray_scale.y = length;
		laser_ray->setWorldScale(laser_ray_scale);

		// activate laserHit if it was hidden earlier
		if (!laser_hit->isEnabled())
			laser_hit->setEnabled(true);

		// update laser hit transform based on intersection information
		laser_hit->setWorldPosition(intersection->getPoint());
		laser_hit->setWorldDirection(intersection->getNormal(), vec3_up, AXIS_Y);

	} else
	{
		// hide hit_object name
		auto parameters = window.getParameterGroupBox();
		static_ptr_cast<WidgetLabel>(parameters->getChild(3))
			->setText(
				"Current Hit Object: <font color=\"#ffffff\">None</font>");

		// set default ray length
		laser_ray_scale.y = laser_distance;
		laser_ray->setWorldScale(laser_ray_scale);

		// hide hit point
		laser_hit->setEnabled(false);
	}
}

void RayIntersection::shutdown()
{
	mask_text.deleteLater();
	window.shutdown();
}

void RayIntersection::init_gui()
{
	window.createWindow();

	auto parameters = window.getParameterGroupBox();

	int walls_size = walls.size();

	auto grid = WidgetGridBox::create(4, 10, 10);
	auto hbox = WidgetHBox::create();
	auto line = WidgetEditLine::create();
	auto label = WidgetLabel::create("Laser Mask: ");
	current_hit = WidgetLabel::create("Current Hit Object: None");
	current_hit->setFontRich(true);
	line->setWidth(100);
	line->setCapacity(8);
	line->setText("00000000");
	line->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(label);
	hbox->addChild(line);
	hbox->setPadding(0, 0, 5, 5);

	parameters->addChild(grid);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	parameters->addChild(current_hit, Gui::ALIGN_LEFT);

	prev_text = line->getText();
	line->getEventKeyPressed().connect(
		*this, [](const WidgetPtr &check, int key) {
			if (key == Input::KEY_ENTER)
			{
				check->removeFocus();
			}
		});
		
	line->getEventChanged().connect(*this, [this](const WidgetPtr &edit_line) {
		auto temp = static_ptr_cast<WidgetEditLine>(edit_line);
		String text = temp->getText();
		if (prev_text == text)
			return;

		String new_text;
		for (int i = 0, some = text.size(); i < some; ++i)
		{
			if (text[i] == '0' || text[i] == '1')
			{
				new_text.append(text[i]);
			} else
			{
				temp->setCursor(i);
			}
		}
		prev_text = temp->getText();
		temp->setText(new_text);
	});
	line->getEventFocusOut().connect(
		*this, [this, grid](const WidgetPtr &edit_line) {
			auto temp = static_ptr_cast<WidgetEditLine>(edit_line);
			String text = temp->getText();
			if (text.size() < 8)
			{
				String new_text;
				for (int i = text.size(); i < 8; ++i)
				{
					new_text.append('0');
				}
				new_text = new_text + text;
				temp->setText(new_text);
				prev_text = new_text;
			}

			for (int i = 0; i < 8; ++i)
			{
				static_ptr_cast<WidgetCheckBox>(grid->getChild(7 - i))
					->setChecked(temp->getText()[i] - '0' > 0);
			}
		});

	for (int i = 0; i < walls_size; ++i)
	{
		auto checkbox = WidgetCheckBox::create(walls[i]);
		int wall_intersection_mask = 1 << i;

		int ind = walls_size - 1 - i;
		checkbox->getEventClicked().connect(
			*this, [this, wall_intersection_mask, ind, line](
					   const WidgetPtr &check) {
				String new_text = line->getText();
				if (static_ptr_cast<WidgetCheckBox>(check)->isChecked())
				{
					new_text[ind] = '1';
					intersection_mask =
						intersection_mask | wall_intersection_mask;
				} else
				{
					new_text[ind] = '0';
					intersection_mask =
						intersection_mask & ~wall_intersection_mask;
				}
				line->setText(new_text);
			});

		checkbox->setChecked((intersection_mask & wall_intersection_mask) > 0);

		grid->addChild(checkbox, Gui::ALIGN_LEFT);
	}
}

```

## RenderTargetSample.cpp

```cpp
#include "RenderTargetSample.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

constexpr float DRAW_TIMEOUT = 0.5f;
const vec4 SPRITE_COLOR = {0.f, 0.f, 1.f, 0.7f, ConstexprTag{}};

REGISTER_COMPONENT(RenderTargetSample)

void RenderTargetSample::init()
{
	for (int i = 0; i < sprites.size(); i++)
	{
		String sprite_path = sprites[i].get();
		TexturePtr sprite_texture = Texture::create();
		sprite_texture->load(sprite_path);
		sprite_textures.push_back(std::move(sprite_texture));
	}

	wall = checked_ptr_cast<Object>(wall_param.get());
	wall_material = wall->getMaterialInherit(0);
	wall_albedo = Image::create();
	wall_albedo->load(wall_material->getTexturePath(wall_material->findTexture("albedo")));

	countdown = DRAW_TIMEOUT;

	const int width = wall_albedo->getWidth();
	const int height = wall_albedo->getHeight();

	render_target = RenderTarget::create();

	background_texture = Texture::create();
	background_texture->create2D(width, height, Texture::FORMAT_RGBA8,
		Texture::FORMAT_USAGE_RENDER);

	const TexturePtr albedo_texture = Texture::create();
	albedo_texture->create(wall_albedo);
	copy_texture(background_texture, albedo_texture);

	result_texture = Texture::create();
	result_texture->create2D(width, height, Texture::FORMAT_RGBA8, Texture::FORMAT_USAGE_RENDER);

	copy_texture(result_texture, background_texture);
	wall_material->setTexture(wall_material->findTexture("albedo"), result_texture);
}

void RenderTargetSample::update()
{
	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT))
	{
		Vec3 p0, p1;
		PlayerPtr player = Game::getPlayer();
		player->getDirectionFromMainWindow(p0, p1, Input::getMousePosition().x,
			Input::getMousePosition().y);
		Vec3 wall_p0 = wall->getIWorldTransform() * p0;
		Vec3 wall_p1 = wall->getIWorldTransform() * p1;

		ObjectIntersectionTexCoordPtr intersection = ObjectIntersectionTexCoord::create();
		if (wall->getIntersection(wall_p0, wall_p1, ~0, intersection, nullptr))
		{
			vec4 tex_coord = intersection->getTexCoord();
			draw_sprite(tex_coord.x, tex_coord.y);
		}
	}

	countdown -= Game::getIFps();
	if (countdown <= 0.0f)
	{
		float x = Game::getRandomFloat(0.0, 1.0f);
		float y = Game::getRandomFloat(0.0, 1.0f);
		draw_sprite(x, y);
		countdown = DRAW_TIMEOUT;
	}
}

void RenderTargetSample::shutdown()
{
	render_target->destroy();
	render_target.clear();

	for (int i = 0; i < sprite_textures.size(); i++)
	{
		if (sprite_textures[i])
		{
			sprite_textures[i]->destroy();
			sprite_textures[i].clear();
		}
	}

	background_texture->destroy();
	background_texture.clear();

	result_texture->destroy();
	result_texture.clear();
}

void RenderTargetSample::copy_texture(const TexturePtr &dest, const TexturePtr &src) const
{
	RenderState::saveState();
	RenderState::clearStates();
	render_target->bindColorTexture(0, dest);
	render_target->enable();
	{
		MaterialPtr material = Materials::findManualMaterial("Unigine::render_copy_2d");
		if (material)
		{
			int color_id = material->findTexture("color");
			material->setTexture(color_id, src);
			material->renderScreen(Render::PASS_POST);
			material->setTexture(color_id, nullptr);
		}
	}
	render_target->disable();
	render_target->unbindColorTextures();
	RenderState::restoreState();
}

void RenderTargetSample::draw_sprite(float uv_x, float uv_y)
{
	ShaderPtr shader = draw_sprite_material->getShaderForce(Render::PASS_POST);
	if (!shader)
	{
		return;
	}

	TexturePtr sprite_texture = sprite_textures[Game::getRandomInt(0, sprite_textures.size() - 1)];

	const float flip_sign = (Render::isFlipped() ? -1.0f : 1.0f);
	const float translate_x = 2.0f * uv_x - 1.0f;
	const float translate_y = flip_sign * (2.0f * uv_y - 1.0f);
	const float scale_x = itof(sprite_texture->getWidth()) / itof(background_texture->getWidth());
	const float scale_y = itof(sprite_texture->getHeight()) / itof(background_texture->getHeight());

	const mat4 transform = translate(translate_x, translate_y, 0.0f)
		* scale(scale_x, scale_y, 1.0f);

	RenderState::saveState();
	RenderState::clearStates();
	render_target->bindColorTexture(0, result_texture);
	render_target->enable();
	{
		shader->bind();
		shader->setParameterFloat4x4("ss_transform", transform);
		shader->setParameterFloat4("ss_color", SPRITE_COLOR);
		shader->flushParameters();

		RenderState::setTexture(RenderState::BIND_FRAGMENT, 0, background_texture);
		RenderState::setTexture(RenderState::BIND_FRAGMENT, 1, sprite_texture);
		draw_sprite_material->renderScreen(Render::PASS_POST);
	}
	render_target->disable();
	render_target->unbindColorTextures();
	RenderState::restoreState();

	copy_texture(background_texture, result_texture);

	result_texture->createMipmaps();
}

```

## RobotArmConnection.cpp

```cpp
#include "RobotArmConnection.h"

#include <UniginePhysicals.h>

REGISTER_COMPONENT(RobotArmConnection);

using namespace Unigine;
using namespace Math;

void RobotArmConnection::init()
{
	auto trigger = checked_ptr_cast<PhysicalTrigger>(connection_trigger.get());

	trigger->getEventEnter().connect(this, &RobotArmConnection::on_trigger_enter);
	trigger->getEventLeave().connect(this, &RobotArmConnection::on_trigger_leave);

	int num = node->getObjectBody()->findJoint("connection_joint");
	if (num != -1)
	{
		joint_fixed = checked_ptr_cast<JointFixed>(node->getObjectBody()->getJoint(num));
	}
}

void RobotArmConnection::update()
{
	if (Input::isKeyDown(Input::KEY_C) && connection_candidate != nullptr)
	{
		connected = true;

		joint_fixed->setBody1(connection_candidate);

		auto itransform = inverse(connection_candidate->getTransform());
		auto anchor_1_transform = itransform * connection_point.get()->getWorldTransform();
		joint_fixed->setAnchor1(anchor_1_transform.getTranslate());
		joint_fixed->setRotation1(anchor_1_transform.getRotate().getMat3());

		joint_fixed->setEnabled(true);
	}

	if (Input::isKeyDown(Input::KEY_V))
	{
		connected = false;
		joint_fixed->setEnabled(false);
	}
}

void RobotArmConnection::on_trigger_enter(const BodyPtr &body)
{
	if (!connection_candidate)
		connection_candidate = checked_ptr_cast<BodyRigid>(body);
}

void RobotArmConnection::on_trigger_leave(const BodyPtr& body)
{
	if (connection_candidate == checked_ptr_cast<BodyRigid>(body))
	{
		connection_candidate = nullptr;
		connected = false;
		joint_fixed->setEnabled(false);
	}
}

```

## RobotArmController.cpp

```cpp
#include "RobotArmController.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(RobotArmController);

using namespace Unigine;

void RobotArmController::ArmJoint::init()
{
	arm_joint_hinge = checked_ptr_cast<JointHinge>(arm_node.get()->getObjectBody()->getJoint(0));
}

void RobotArmController::ArmJoint::update(float ifps, Unigine::Input::KEY positiveAxis, Unigine::Input::KEY negativeAxis)
{
	if (Input::isKeyPressed(positiveAxis))
		rotate(speed.get() * ifps);

	if (Input::isKeyPressed(negativeAxis))
		rotate(-speed.get() * ifps);
}

void RobotArmController::ArmJoint::rotate(float angle)
{
	if (arm_joint_hinge)
	{
		float currentAngle = arm_joint_hinge->getAngularAngle();
		currentAngle += angle;
		if (currentAngle < -180)
			currentAngle += 360.0f;
		if (currentAngle > 180)
			currentAngle -= 360.0f;

		if (currentAngle < arm_joint_hinge->getAngularLimitFrom())
			currentAngle = arm_joint_hinge->getAngularLimitFrom();

		if (currentAngle > arm_joint_hinge->getAngularLimitTo())
			currentAngle = arm_joint_hinge->getAngularLimitTo();

		arm_joint_hinge->setAngularAngle(currentAngle);
	}
}

void RobotArmController::init()
{
	arm_joint_0.get().init();
	arm_joint_1.get().init();
	arm_joint_2.get().init();
	arm_joint_3.get().init();
	arm_joint_4.get().init();
	arm_joint_5.get().init();
}

void RobotArmController::update()
{
	arm_joint_0.get().update(Game::getIFps(), Input::KEY_H, Input::KEY_F);
	arm_joint_1.get().update(Game::getIFps(), Input::KEY_T, Input::KEY_G);
	arm_joint_2.get().update(Game::getIFps(), Input::KEY_I, Input::KEY_K);
	arm_joint_3.get().update(Game::getIFps(), Input::KEY_J, Input::KEY_L);
	arm_joint_4.get().update(Game::getIFps(), Input::KEY_U, Input::KEY_O);
	arm_joint_5.get().update(Game::getIFps(), Input::KEY_R, Input::KEY_Y);
}

```

## Rotator.cpp

```cpp
#include "Rotator.h"
#include <UnigineGame.h>

REGISTER_COMPONENT(Rotator);

using namespace Unigine;
using namespace Math;

void Rotator::update()
{
	vec3 delta = angular_velocity.get() * Game::getIFps();
	node->setRotation(node->getRotation() * quat{delta.x, delta.y, delta.z});
}
```

## SampleDescriptionWindow.cpp

```cpp
#include "SampleDescriptionWindow.h"

using namespace Unigine;
using namespace Math;


void SampleDescriptionWindow::createWindow(int align, int width)
{
	auto world_path = World::getPath();
	auto world_name = String::filename(world_path);

	String cpp_samples_xml_path = FileSystem::getAbsolutePath(String::joinPaths(Engine::get()->getDataPath(), "../cpp_samples.sample"));

	XmlPtr cpp_samples_xml = Xml::create();
	if (!cpp_samples_xml->load(cpp_samples_xml_path))
	{
		Unigine::Log::warning("SampleDescriptionWindow::createWindow(): cannot open %s file\n", cpp_samples_xml_path.get());
		return;
	}

	XmlPtr cpp_samples_samples_pack = cpp_samples_xml->getChild("samples_pack");
	XmlPtr samples_xml = cpp_samples_samples_pack->getChild("samples");

	String title;
	String description;
	String controls;

	for (int i = 0; i < samples_xml->getNumChildren(); ++i)
	{
		XmlPtr sample_xml = samples_xml->getChild(i);

		if (String::compare(sample_xml->getArg("id"), world_name) == 0)
		{
			title = sample_xml->getArg("title");
			description = sample_xml->getChild("desc")->getChildData("brief");
			if (sample_xml->isChild("controls"))
				controls = sample_xml->getChildData("controls");
			break;
		}
	}

	w_main_window = WidgetWindow::create(title.get());
	w_main_window->setWidth(width);
	w_main_window->arrange();
	WindowManager::getMainWindow()->addChild(w_main_window, Gui::ALIGN_OVERLAP | align);

	if (!description.empty())
	{
		w_about_group = WidgetGroupBox::create("About", 8, 8);
		w_main_window->addChild(w_about_group, Gui::ALIGN_LEFT);

		w_about_lbl = WidgetLabel::create(description.get());
		w_about_lbl->setFontWrap(1);
		w_about_lbl->setFontRich(1);
//		w_about_lbl->setWidth(width);
		w_about_group->addChild(w_about_lbl, Gui::ALIGN_EXPAND);
	}
	if (!controls.empty())
	{
		w_controls_group = WidgetGroupBox::create("Controls", 8, 8);
		w_main_window->addChild(w_controls_group, Gui::ALIGN_LEFT);

		w_controls_lbl = WidgetLabel::create(controls.get());
		w_controls_lbl->setFontWrap(1);
		w_controls_lbl->setFontRich(1);
//		w_controls_lbl->setWidth(width);
		w_controls_group->addChild(w_controls_lbl, Gui::ALIGN_EXPAND);
	}
}

void SampleDescriptionWindow::shutdown()
{
	disconnectAll();
	w_main_window.deleteLater();
}

Unigine::WidgetLabelPtr SampleDescriptionWindow::addLabel(
	const char *label_text)
{
	if (!w_parameters_grid)
		init_parameter_box();

	auto label = WidgetLabel::create(label_text);
	w_parameters_grid->addChild(WidgetLabel::create());
	w_parameters_grid->addChild(label);
	w_parameters_grid->addChild(WidgetLabel::create());
	return label;
}

WidgetSliderPtr SampleDescriptionWindow::addFloatParameter(const char *name, const char *tooltip,
                                                           float default_value, float min_value, float max_value, std::function<void(float)> on_change)
{
	if (!w_parameters_grid)
		init_parameter_box();

	auto label = WidgetLabel::create(name);
	label->setWidth(100);
	w_parameters_grid->addChild(label, Gui::ALIGN_LEFT);
	label->setToolTip(tooltip);

	auto slider = WidgetSlider::create();
	slider->setMinValue((int)(min_value * 100));
	slider->setMaxValue((int)(max_value * 100));
	slider->setValue((int)(default_value * 100));

	slider->setWidth(200);
	slider->setButtonWidth(20);
	slider->setButtonHeight(20);
	slider->setToolTip(tooltip);
	w_parameters_grid->addChild(slider, Gui::ALIGN_LEFT);

	label = WidgetLabel::create(String::ftoa(default_value, 2));
	label->setWidth(20);
	label->setToolTip(tooltip);
	w_parameters_grid->addChild(label);

	slider->getEventChanged().connect(*this, [this, label, slider, on_change]() {
		float v = slider->getValue() / 100.0f;
		label->setText(String::ftoa(v, 2));
		on_change(v);
	});

	return slider;
}

WidgetSliderPtr SampleDescriptionWindow::addIntParameter(const char *name, const char *tooltip,
	int default_value, int min_value, int max_value, std::function<void(int)> on_change)
{
	if (!w_parameters_grid)
		init_parameter_box();

	auto label = WidgetLabel::create(name);
	label->setWidth(100);
	label->setToolTip(tooltip);
	w_parameters_grid->addChild(label, Gui::ALIGN_LEFT);

	auto slider = WidgetSlider::create();
	slider->setMinValue(min_value);
	slider->setMaxValue(max_value);
	slider->setValue(default_value);

	slider->setWidth(200);
	slider->setButtonWidth(20);
	slider->setButtonHeight(20);
	slider->setToolTip(tooltip);
	w_parameters_grid->addChild(slider, Gui::ALIGN_LEFT);

	label = WidgetLabel::create(String::itoa(default_value));
	label->setWidth(20);
	label->setToolTip(tooltip);
	w_parameters_grid->addChild(label);

	slider->getEventChanged().connect(*this, [this, label, slider, on_change]() {
		int v = slider->getValue();
		label->setText(String::itoa(v));
		on_change(v);
	});

	return slider;
}

Unigine::WidgetCheckBoxPtr SampleDescriptionWindow::addBoolParameter(
	const char *name, const char *tooltip, bool default_value,
	std::function<void(bool)> on_change)
{
	if (!w_parameters_grid)
		init_parameter_box();

	auto label = WidgetLabel::create(name);
	label->setWidth(100);
	label->setToolTip(tooltip);
	auto checkbox = WidgetCheckBox::create();
	checkbox->setToolTip(tooltip);
	checkbox->setChecked(default_value);

	checkbox->getEventChanged().connect(*this, [this,
		checkbox,
		callback = std::move(on_change)]
		(const WidgetPtr &widget) {
		if (checkbox->isChecked())
			callback(true);
		else
			callback(false);
	});

	w_parameters_grid->addChild(label, Gui::ALIGN_LEFT);
	w_parameters_grid->addChild(checkbox, Gui::ALIGN_CENTER);
	w_parameters_grid->addChild(WidgetLabel::create(), Gui::ALIGN_LEFT);
	return checkbox;
}

void SampleDescriptionWindow::setStatus(const char *status)
{
	if (!w_status_lbl)
		init_status_box();

	w_status_lbl->setText(status);
	w_status_lbl->arrange();
}

const WidgetGroupBoxPtr &SampleDescriptionWindow::getParameterGroupBox()
{
	if (!w_parameters_grid)
		init_parameter_box();
	return w_parameters_group;
}

void SampleDescriptionWindow::init_parameter_box()
{
	w_parameters_group = WidgetGroupBox::create("Parameters", 8, 8);
	w_main_window->addChild(w_parameters_group, Gui::ALIGN_LEFT);
	w_parameters_grid = WidgetGridBox::create(3);
	w_parameters_group->addChild(w_parameters_grid);
}

void SampleDescriptionWindow::init_status_box()
{
	w_status_group = WidgetGroupBox::create("Status", 8, 8);
	w_main_window->addChild(w_status_group, Gui::ALIGN_LEFT);
	w_status_lbl = WidgetLabel::create();
	// w_status_lbl->setFontWrap(1);
	// w_status_lbl->setFontRich(1);
	w_status_lbl->setWidth(300);
	w_status_group->addChild(w_status_lbl, Gui::ALIGN_EXPAND);
}

void SampleDescriptionWindow::addParameterSpacer()
{
	for (int i = 0; i < 3; ++i)
	{
		auto spacer = WidgetSpacer::create();
		w_parameters_grid->addChild(spacer);
	}
}

```

## SamplesManager.cpp

```cpp
#include "SamplesManager.h"

#include <UnigineXml.h>
#include <UnigineFileSystem.h>
#include <UnigineEngine.h>

using namespace Unigine;

bool SamplesManager::parseMetaXml(Unigine::String path_relative_to_data)
{
	if (!isEmpty() && path_relative_to_data == meta_path)
		return true;

	String cpp_samples_xml_path = FileSystem::getAbsolutePath(
		String::joinPaths(Engine::get()->getDataPath(), path_relative_to_data));

	XmlPtr cpp_samples_xml = Xml::create();
	if (!cpp_samples_xml->load(cpp_samples_xml_path))
	{
		Unigine::Log::warning("SamplesMetaParser::parseMetaXml(): can't open %s file\n",
			cpp_samples_xml_path.get());
		return false;
	}

	clear();
	meta_path = path_relative_to_data;

	XmlPtr cpp_samples_samples_pack = cpp_samples_xml->getChild("samples_pack");
	XmlPtr categories_xml = cpp_samples_samples_pack->getChild("categories");
	XmlPtr samples_xml = cpp_samples_samples_pack->getChild("samples");

	HashMap<String, Category> categories_map;
	Vector<String> categories_id;
	HashSet<String> tags_set;

	for (int i = 0; i < categories_xml->getNumChildren(); ++i)
	{
		XmlPtr category_xml = categories_xml->getChild(i);

		String icon_path = category_xml->getArg("img");
		icon_path = icon_path.trimFirst("data/");

		Category c;
		c.icon = Image::create(icon_path.get());
		c.title = category_xml->getArg("name");

		c.id = category_xml->getArg("id");

		categories_id.append(c.id);
		categories_map[c.id] = c;
	}

	for (int i = 0; i < samples_xml->getNumChildren(); ++i)
	{
		XmlPtr sample_xml = samples_xml->getChild(i);

		Sample s;
		s.title = sample_xml->getArg("title");
		s.description = sample_xml->getChild("sdk_desc")->getData();
		s.world_name = sample_xml->getArg("id");

		XmlPtr tags_xml = sample_xml->getChild("tags");
		for (int j = 0; j < tags_xml->getNumChildren(); ++j)
		{
			String tag = tags_xml->getChild(j)->getData();

			if (!tags_set.contains(tag))
				tags_set.insert(tag);

			s.tags.push_back(tag);
		}

		s.category_id = sample_xml->getArg("category_id");

		if (categories_map.contains(s.category_id))
			categories_map[s.category_id].samples.push_back(s);
		else
			Unigine::Log::error("Category with id %s doesn't exist in .sample file\n",
				s.category_id.get());

		samples_map[s.world_name] = s;
	}

	categories.clear();

	for (const auto &id : categories_id)
	{
		if (categories_map.contains(id) && categories_map.value(id).samples.size() > 0)
			categories.push_back(categories_map.value(id));
	}
	categories_id.clear();

	tags.clear();
	for (const auto &t : tags_set)
	{
		tags.push_back(t.key);
	}

	return true;
}

bool SamplesManager::isEmpty() const
{
	if (meta_path.empty() || categories.empty())
		return true;
	else
		return false;
}

void SamplesManager::clear()
{
	meta_path = "";
	categories.clear();
	samples_map.clear();
	tags.clear();
}

const Category *SamplesManager::getCategoryBySampleID(const Unigine::String &sample_id) const
{
	if (isEmpty() || !samples_map.contains(sample_id))
		return nullptr;

	const Sample &sample = samples_map[sample_id];

	for (auto &category : categories)
	{
		if (category.id == sample.category_id)
			return &category;
	}

	return nullptr;
}

const Sample *SamplesManager::getSampleByWorldPath(Unigine::String world_path) const
{
	String sample_id = String::filename(world_path);
	return getSampleByID(sample_id);
}

const Sample *SamplesManager::getSampleByID(Unigine::String &id) const
{
	if (isEmpty() || !samples_map.contains(id))
		return nullptr;

	return &samples_map[id];
}

void SamplesManager::getPrevNextSamplesID(const Unigine::String &world_name,
	Unigine::String &prev_world, Unigine::String &next_world)
{
	auto *category = getCategoryBySampleID(world_name);
	if (!category)
	{
		prev_world = world_name;
		next_world = world_name;
		return;
	}

	auto &samples = category->samples;
	for (int i = 0; i < samples.size(); i++)
	{
		String id = samples[i].world_name;
		if (id != world_name)
			continue;

		prev_world = i == 0 ? samples.last().world_name : samples[i - 1].world_name;
		next_world = i == samples.size() - 1 ? samples.first().world_name
											 : samples[i + 1].world_name;
		return;
	}
}

```

## Screenshot.cpp

```cpp
#include "Screenshot.h"

using namespace Unigine;
using namespace Math;

void Screenshot::setWindow(const Unigine::EngineWindowPtr &window)
{
	disconnectAll();
	if (!window)
		return;

	window_ = window;
	window_->getEventFuncEndRender().connect(this, &Screenshot::render);
}

void Screenshot::render()
{
	if (!grab_flag)
	{
		return;
	}
	grab_flag = false;

	TexturePtr temporary_texture = Render::getTemporaryTexture2D(window_->getClientSize().x,
		window_->getClientSize().y, Texture::FORMAT_RGBA8, 0);

	// copy2D is the place where screenshot is made
	// this method copies color texture to our texture
	temporary_texture->copy2D();

	Render::asyncTransferTextureToImage(nullptr, MakeCallback([](ImagePtr image) {
		if (!Render::isFlipped())
		{
			image->flipY();
		}
		image->save("screenshot.dds");
		Log::message("Screenshot saved to \"data/screenshot.dds\"\n");
	}),
		temporary_texture);

	Render::releaseTemporaryTexture(temporary_texture);
}

```

## ScreenshotSample.cpp

```cpp
#include "ScreenshotSample.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ScreenshotSample);

void ScreenshotSample::init()
{
	screenshot.setWindow(WindowManager::getMainWindow());

	sample_description_window.createWindow();
	WidgetGroupBoxPtr parameters = sample_description_window.getParameterGroupBox();
	auto info_label = WidgetLabel::create("Screenshot will be saved in <b>data/screenshot.dds</b>");
	info_label->setFontRich(1);
	parameters->addChild(info_label, Gui::ALIGN_EXPAND);

	auto screenshot_button = WidgetButton::create("Take Screenshot");
	parameters->addChild(screenshot_button, Gui::ALIGN_EXPAND);
	screenshot_button->getEventClicked().connect(*this, [this]() { screenshot.grab(); });
}

void ScreenshotSample::shutdown()
{
	sample_description_window.shutdown();
}

```

## ScriptArrays.cpp

```cpp
#include "ScriptArrays.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineConsole.h>
#include <UnigineInterface.h>
#include <UnigineWorld.h>

REGISTER_COMPONENT(ScriptArrays)

using namespace Unigine;


void my_array_vector_set(const Variable &id, int index, const Variable &v)
{
	ArrayVector vector = ArrayVector::get(Interpreter::get(), id);
	vector.set(index, v);
}

Variable my_array_vector_get(const Variable &id, int index)
{
	ArrayVector vector = ArrayVector::get(Interpreter::get(), id);
	return vector.get(index);
}

void my_array_map_set(const Variable &id, const Variable &key, const Variable &v)
{
	ArrayMap map = ArrayMap::get(Interpreter::get(), id);
	map.set(key, v);
}

Variable my_array_map_get(const Variable &id, const Variable &key)
{
	ArrayMap map = ArrayMap::get(Interpreter::get(), id);
	return map.get(key);
}

void my_array_vector_generate(const Variable &id)
{
	ArrayVector vector = ArrayVector::get(Interpreter::get(), id);
	vector.clear();
	for (int i = 0; i < 4; i++)
		vector.append(Variable(i * i));
	vector.remove(0);
	vector.append(Variable("128"));
}

void my_array_map_generate(const Variable &id)
{
	ArrayMap map = ArrayMap::get(Interpreter::get(), id);
	map.clear();
	for (int i = 0; i < 4; i++)
		map.append(Variable(i * i), Variable(i * i));
	map.remove(Variable(0));
	map.append(Variable(128), Variable("128"));
}

void my_array_vector_enumerate(const Variable &id)
{
	ArrayVector vector = ArrayVector::get(Interpreter::get(), id);
	for (int i = 0; i < vector.size(); i++)
		Log::message("%s %d: %s\n", sourse_str, i, vector.get(i).getTypeInfo().get());
}

void my_array_map_enumerate_forward(const Variable &id)
{
	ArrayMap map = ArrayMap::get(Interpreter::get(), id);
	ArrayMap::Iterator end = map.end();
	for (ArrayMap::Iterator it = map.begin(); it != end; ++it)
		Log::message("%s %d: %s\n", sourse_str, it.key().getInt(), it.get().getTypeInfo().get());
}

void my_array_map_enumerate_backward(const Variable &id)
{
	ArrayMap map = ArrayMap::get(Interpreter::get(), id);
	ArrayMap::Iterator end = map.end();
	for (ArrayMap::Iterator it = map.back(); it != end; --it)
		Log::message("%s %d: %s\n", sourse_str, it.key().getInt(), it.get().getTypeInfo().get());
}

USCInterpreter arrays_interpreter([]() {
	Interpreter::addExternFunction("my_array_vector_set",
		MakeExternFunction(&my_array_vector_set, "[]"));
	Interpreter::addExternFunction("my_array_vector_get",
		MakeExternFunction(&my_array_vector_get, "[]"));
	Interpreter::addExternFunction("my_array_map_set", MakeExternFunction(&my_array_map_set, "[]"));
	Interpreter::addExternFunction("my_array_map_get", MakeExternFunction(&my_array_map_get, "[]"));
	Interpreter::addExternFunction("my_array_vector_generate",
		MakeExternFunction(&my_array_vector_generate, "[]"));
	Interpreter::addExternFunction("my_array_map_generate",
		MakeExternFunction(&my_array_map_generate, "[]"));
	Interpreter::addExternFunction("my_array_vector_enumerate",
		MakeExternFunction(&my_array_vector_enumerate, "[]"));
	Interpreter::addExternFunction("my_array_map_enumerate_forward",
		MakeExternFunction(&my_array_map_enumerate_forward, "[]"));
	Interpreter::addExternFunction("my_array_map_enumerate_backward",
		MakeExternFunction(&my_array_map_enumerate_backward, "[]"));
});


void ScriptArrays::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenHeight(100);
	Console::setOnscreenTime(1000);
}

void ScriptArrays::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptCallbacks.cpp

```cpp
#include "ScriptCallbacks.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptCallbacks)

using namespace Unigine;


const Variable &runWorldFunction(const Variable &name, const Variable &v)
{
	Log::message("%s runWorldFunction(%s,%s): called\n", sourse_str, name.getTypeName().get(),
		v.getTypeName().get());

	return Engine::get()->runWorldFunction(name, v);
}

USCInterpreter callbacks_interpreter([]() {
	Interpreter::addExternFunction("runWorldFunction", MakeExternFunction(&runWorldFunction));
});


void ScriptCallbacks::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptCallbacks::update()
{
	Variable ret = Engine::get()->runWorldFunction(Variable("counter"));
	if (ret.getInt() != -1)
		Log::message("%s counter is: %d\n", sourse_str, ret.getInt());
	if (ret.getInt() == 3)
	{
		Variable path = Engine::get()->runWorldFunction(Variable("engine.world.getPath"));
		Log::message("\n%s world path is: \"%s\"\n", sourse_str, path.getString());
	}
}

void ScriptCallbacks::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptClasses.cpp

```cpp
#include "ScriptClasses.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptClasses)

using namespace Unigine;
using namespace Math;


//////////////////////////////////////////////////////////////////////////
// User class
//////////////////////////////////////////////////////////////////////////

Variable user_object;

void SetMyUserObject(Variable &v)
{
	Log::message("%s SetMyUserObject(%s): called\n", sourse_str, v.getTypeName().get());
	user_object = v;
}

const Variable &GetMyUserObject()
{
	Log::message("%s GetMyUserObject(): called\n", sourse_str);
	return user_object;
}

//////////////////////////////////////////////////////////////////////////
// Extern class
//////////////////////////////////////////////////////////////////////////

MyExternObject::MyExternObject()
	: mass(0.0f)
{
	Log::message("%s MyExternObject::MyExternObject(): called\n", sourse_str);
}

MyExternObject::MyExternObject(const vec3 &size, float mass)
	: size(size)
	, mass(mass)
{
	Log::message("%s MyExternObject::MyExternObject((%g,%g,%g),%g): called\n", sourse_str, size.x,
		size.y, size.z, mass);
}

MyExternObject::~MyExternObject()
{
	Log::message("%s MyExternObject::~MyExternObject(): called\n", sourse_str);
}

void MyExternObject::setSize(const vec3 &s)
{
	Log::message("%s MyExternObject::setSize((%g,%g,%g)): called\n", sourse_str, s.x, s.y, s.z);
	size = s;
}

void MyExternObject::setMass(float m)
{
	Log::message("%s MyExternObject::setMass(%g): called\n", sourse_str, m);
	mass = m;
}


MyExternObject *MakeMyExternObject(const vec3 &size, float mass)
{
	return new MyExternObject(size, mass);
}

void DeleteMyExternObject(MyExternObject *object)
{
	delete object;
}

void MyExternObjectSetSize(MyExternObject *object, const vec3 &size)
{
	object->setSize(size);
}

const vec3 &MyExternObjectGetSize(MyExternObject *object)
{
	return object->getSize();
}


USCInterpreter calsses_interpreter([]() {
	Interpreter::addExternFunction("SetMyUserObject", MakeExternFunction(&SetMyUserObject));
	Interpreter::addExternFunction("GetMyUserObject", MakeExternFunction(&GetMyUserObject));

	// export extern class
	ExternClass<MyExternObject> *my_object = MakeExternClass<MyExternObject>();
	my_object->addConstructor();
	my_object->addConstructor<const vec3 &, float>();
	my_object->addFunction("setSize", &MyExternObject::setSize);
	my_object->addFunction("getSize", &MyExternObject::getSize);
	my_object->addFunction("setMass", &MyExternObject::setMass);
	my_object->addFunction("getMass", &MyExternObject::getMass);
	Interpreter::addExternClass("MyExternObject", my_object);

	// export extern class functions
	Interpreter::addExternFunction("DeleteMyExternObject",
		MakeExternFunction(&DeleteMyExternObject));
	Interpreter::addExternFunction("MakeMyExternObject", MakeExternFunction(&MakeMyExternObject));
	Interpreter::addExternFunction("MyExternObjectSetSize",
		MakeExternFunction(&MyExternObjectSetSize));
	Interpreter::addExternFunction("MyExternObjectGetSize",
		MakeExternFunction(&MyExternObjectGetSize));
});


void ScriptClasses::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptClasses::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptFunctions.cpp

```cpp
#include "ScriptFunctions.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptFunctions)

using namespace Unigine;
using namespace Math;

//////////////////////////////////////////////////////////////////////////
// User defined functions
//////////////////////////////////////////////////////////////////////////

Variable my_sum(const Variable &v0, const Variable &v1)
{
	if (v0.getType() == Variable::INT && v1.getType() == Variable::INT)
	{
		Log::message("%s my_sum(%d,%d): called\n", sourse_str, v0.getInt(), v1.getInt());
		return Variable(v0.getInt() + v1.getInt());
	}

	if (v0.getType() == Variable::STRING && v1.getType() == Variable::STRING)
	{
		Log::message("%s my_sum(%s,%s): called\n", sourse_str, v0.getString(), v1.getString());
		return Variable((String(v0.getString()) + "+" + String(v1.getString())).get());
	}

	Log::message("%s my_sum(%s,%s): called\n", sourse_str, v0.getTypeName().get(),
		v1.getTypeName().get());
	return Variable("unknown");
}

float my_mul(float a, float b)
{
	Log::message("%s my_mul(%g,%g): called\n", sourse_str, a, b);
	return a * b;
}

float my_dot(const vec3 &v0, const vec3 &v1)
{
	Log::message("%s my_dot((%g,%g,%g),(%g,%g,%g)): called\n", sourse_str, v0.x, v0.y, v0.z, v1.x,
		v1.y, v1.z);
	return dot(v0, v1);
}

//////////////////////////////////////////////////////////////////////////
// User defined class member functions
//////////////////////////////////////////////////////////////////////////

class MyApplication
{
public:
	MyApplication()
		: seed(1)
	{}

	void init(int s = 1)
	{
		Log::message("%s MyApplication::init(%d) called\n", sourse_str, s);
		seed = s;
	}

	void shutdown()
	{
		Log::message("%s MyApplication::shutdown() called\n", sourse_str);
		seed = 1;
	}

	int update()
	{
		seed = (seed * 3877 + 29573) % 139968;
		return seed;
	}

	int get() const { return seed; }

private:
	int seed;
} my_application;


USCInterpreter functions_interpreter([]() {
	// export functions
	Interpreter::addExternFunction("my_sum", MakeExternFunction(&my_sum, ",1"));
	Interpreter::addExternFunction("my_mul", MakeExternFunction(&my_mul));
	Interpreter::addExternFunction("my_dot", MakeExternFunction(&my_dot));

	// export class member functions
	Interpreter::addExternLibrary("my_application");
	Interpreter::addExternFunction("my_application.init",
		MakeExternObjectFunction(&my_application, &MyApplication::init, "1"));
	Interpreter::addExternFunction("my_application.shutdown",
		MakeExternObjectFunction(&my_application, &MyApplication::shutdown));
	Interpreter::addExternFunction("my_application.update",
		MakeExternObjectFunction(&my_application, &MyApplication::update));
	Interpreter::addExternFunction("my_application.get",
		MakeExternObjectFunction(&my_application, &MyApplication::get));
});


void ScriptFunctions::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptFunctions::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptInheritance.cpp

```cpp
#include "ScriptInheritance.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptInheritance)

using namespace Unigine;

//////////////////////////////////////////////////////////////////////////
// User defined class
//////////////////////////////////////////////////////////////////////////

class MyBaseClass
{
public:
	MyBaseClass() { Log::message("%s MyBaseClass::MyBaseClass(): called\n", sourse_str); }
	virtual ~MyBaseClass() { Log::message("%s MyBaseClass::~MyBaseClass(): called\n", sourse_str); }

	void function() { Log::message("%s MyBaseClass::function(): called\n", sourse_str); }
	virtual const char *getName() = 0;
};

class MyNodeClass : public MyBaseClass
{
public:
	MyNodeClass() { Log::message("%s MyNodeClass::MyNodeClass(): called\n", sourse_str); }
	virtual ~MyNodeClass() { Log::message("%s MyNodeClass::~MyNodeClass(): called\n", sourse_str); }

	void function() { Log::message("%s MyNodeClass::function(): called\n", sourse_str); }
	virtual const char *getName() { return "MyNodeClass"; }
};

class MyObjectClass : public MyNodeClass
{
public:
	MyObjectClass() { Log::message("%s MyObjectClass::MyObjectClass(): called\n", sourse_str); }
	virtual ~MyObjectClass() { Log::message("%s MyObjectClass::~MyObjectClass(): called\n", sourse_str); }

	void function() { Log::message("%s MyObjectClass::function(): called\n", sourse_str); }
	virtual const char *getName() { return "MyObjectClass"; }
};


USCInterpreter inheritance_interpreter([]() {
	// export classes
	ExternClass<MyBaseClass> *my_base = MakeExternClass<MyBaseClass>();
	my_base->addFunction("function", &MyBaseClass::function);
	my_base->addFunction("getName", &MyBaseClass::getName);
	Interpreter::addExternClass("MyBaseClass", my_base);

	ExternClass<MyNodeClass> *my_node = MakeExternClass<MyNodeClass>();
	my_node->addConstructor();
	my_node->addFunction("function", &MyNodeClass::function);
	my_node->addBaseClass(my_base);
	Interpreter::addExternClass("MyNodeClass", my_node);

	ExternClass<MyObjectClass> *my_object = MakeExternClass<MyObjectClass>();
	my_object->addConstructor();
	my_object->addFunction("function", &MyObjectClass::function);
	my_object->addBaseClass(my_node);
	Interpreter::addExternClass("MyObjectClass", my_object);
});


void ScriptInheritance::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptInheritance::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptStack.cpp

```cpp
#include "ScriptStack.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptStack)

using namespace Unigine;

//////////////////////////////////////////////////////////////////////////
// Format function
//////////////////////////////////////////////////////////////////////////

String my_format(const char *format)
{
	String ret;

	const char *s = format;

	while (*s)
	{
		// format symbol
		if (*s == '%')
		{
			s++;

			// format symbol
			if (*s == '%')
			{
				ret += *s++;
				continue;
			}

			// check stack depth
			if (Interpreter::getStack() < 1)
				Interpreter::error("my_format(): stack underflow\n");

			// pop a variable from the stack
			Variable v = Interpreter::popStack();

			// integer
			if (*s == 'd' || *s == 'i')
			{
				ret += String::format("%d", v.getInt());
				s++;
			}

			// float
			else if (*s == 'f')
			{
				ret += String::format("%f", v.getFloat());
				s++;
			}

			// string
			else if (*s == 's')
			{
				ret += String::format("%s", v.getString());
				s++;
			}

			// unknown format
			else
				Interpreter::error("my_format(): unknown format %c\n", *s);
		}

		// copy symbol
		else
			ret += *s++;
	}

	return ret;
}


USCInterpreter stack_interpreter([]() {
	// export format function
	Interpreter::addExternFunction("my_format", MakeExternFunction(&my_format, ",..."));
});


void ScriptStack::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptStack::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptStructure.cpp

```cpp
#include "ScriptStructure.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptStructure)

using namespace Unigine;

//////////////////////////////////////////////////////////////////////////
// Extern struct
//////////////////////////////////////////////////////////////////////////
struct MyVector
{
	MyVector()
		: x(0.0f)
		, y(0.0f)
		, z(0.0f)
		, w(0.0f)
	{}

	float x;
	float y;
	float z;
	float w;
};


USCInterpreter structure_interpreter([]() {
	// export extern struct
	ExternClass<MyVector> *my_vector = MakeExternClass<MyVector>();
	my_vector->addConstructor();
	my_vector->addSetFunction("setX", &MyVector::x);
	my_vector->addGetFunction("getX", &MyVector::x);
	my_vector->addSetFunction("setY", &MyVector::y);
	my_vector->addGetFunction("getY", &MyVector::y);
	my_vector->addSetFunction("setZ", &MyVector::z);
	my_vector->addGetFunction("getZ", &MyVector::z);
	my_vector->addSetFunction("setW", &MyVector::w);
	my_vector->addGetFunction("getW", &MyVector::w);
	Interpreter::addExternClass("MyVector", my_vector);
});


void ScriptStructure::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptStructure::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptTransfer.cpp

```cpp
#include "ScriptTransfer.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptTransfer)

using namespace Unigine;


//////////////////////////////////////////////////////////////////////////
// Info function
//////////////////////////////////////////////////////////////////////////

void my_image_info_0(ImagePtr image)
{
	Log::message("%s my_image_info_0(): %s %d %d (%p)\n", sourse_str, image->getFormatName(),
		image->getWidth(), image->getHeight(), image.get());
}

void my_image_info_1(const Variable &v)
{
	ImagePtr image = v.getImage(Interpreter::get());

	Log::message("%s my_image_info_1(): %s %d %d (%p)\n", sourse_str, image->getFormatName(),
		image->getWidth(), image->getHeight(), image.get());
}

void my_image_info_2(const Variable &v)
{
	ImagePtr image = VariableToType<ImagePtr>(Interpreter::get(), v).value;

	Log::message("%s my_image_info_2(): %s %d %d (%p)\n", sourse_str, image->getFormatName(),
		image->getWidth(), image->getHeight(), image.get());
}

//////////////////////////////////////////////////////////////////////////
// Create function
//////////////////////////////////////////////////////////////////////////

ImagePtr image_0;
ImagePtr image_1;
ImagePtr image_2;

ImagePtr my_image_create_0()
{
	image_0 = Image::create();
	image_0->create2D(128, 128, Image::FORMAT_RG8);

	return image_0;
}

Variable my_image_create_1()
{
	image_1 = Image::create();
	image_1->create2D(128, 128, Image::FORMAT_RG8);

	Variable v;
	v.setImage(Interpreter::get(), image_1);
	return v;
}

Variable my_image_create_2()
{
	image_2 = Image::create();
	image_2->create2D(128, 128, Image::FORMAT_RG8);

	return TypeToVariable<ImagePtr>(Interpreter::get(), image_2).value;
}


USCInterpreter transfer_interpreter([]() {
	// export functions
	Interpreter::addExternFunction("my_image_info_0", MakeExternFunction(&my_image_info_0));
	Interpreter::addExternFunction("my_image_info_1", MakeExternFunction(&my_image_info_1));
	Interpreter::addExternFunction("my_image_info_2", MakeExternFunction(&my_image_info_2));
	Interpreter::addExternFunction("my_image_create_0", MakeExternFunction(&my_image_create_0));
	Interpreter::addExternFunction("my_image_create_1", MakeExternFunction(&my_image_create_1));
	Interpreter::addExternFunction("my_image_create_2", MakeExternFunction(&my_image_create_2));
});


void ScriptTransfer::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptTransfer::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptTypes.cpp

```cpp
#include "ScriptTypes.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptTypes)

using namespace Unigine;
using namespace Unigine::Math;

//////////////////////////////////////////////////////////////////////////
// User defined vector
//////////////////////////////////////////////////////////////////////////

class MyVector3
{
public:
	MyVector3()
		: x(0.0f)
		, y(0.0f)
		, z(0.0f)
	{}
	MyVector3(float x, float y, float z)
		: x(x)
		, y(y)
		, z(z)
	{}

	float X() const { return x; }
	float Y() const { return y; }
	float Z() const { return z; }
	float &X() { return x; }
	float &Y() { return y; }
	float &Z() { return z; }

private:
	float x;
	float y;
	float z;
};

MyVector3 my_add(const MyVector3 &v0, const MyVector3 &v1)
{
	return MyVector3(v0.X() + v1.X(), v0.Y() + v1.Y(), v0.Z() + v1.Z());
}

MyVector3 my_sub(MyVector3 v0, MyVector3 v1)
{
	return MyVector3(v0.X() - v1.X(), v0.Y() - v1.Y(), v0.Z() - v1.Z());
}

float my_vec_dot(MyVector3 v0, MyVector3 v1)
{
	return v0.X() * v1.X() + v0.Y() * v1.Y() + v0.Z() * v1.Z();
}

//////////////////////////////////////////////////////////////////////////
// User data type conversion
//////////////////////////////////////////////////////////////////////////

namespace Unigine
{
template<>
struct TypeToVariable<MyVector3>
{
	TypeToVariable(void *i, const MyVector3 &v) { value.setVec3(vec3(v.X(), v.Y(), v.Z())); }
	Variable value;
};

template<>
struct VariableToType<MyVector3>
{
	VariableToType(void *i, const Variable &variable)
	{
		vec3 v = variable.getVec3();
		value = MyVector3(v.x, v.y, v.z);
	}
	MyVector3 value;
};

template<>
struct VariableToType<const MyVector3 &>
{
	VariableToType(void *i, const Variable &variable)
	{
		vec3 v = variable.getVec3();
		value = MyVector3(v.x, v.y, v.z);
	}
	MyVector3 value;
};
} // namespace Unigine


USCInterpreter types_interpreter([]() {
	// export class member functions
	Interpreter::addExternFunction("my_add", MakeExternFunction(my_add));
	Interpreter::addExternFunction("my_sub", MakeExternFunction(my_sub));
	Interpreter::addExternFunction("my_vec_dot", MakeExternFunction(my_vec_dot));
});


void ScriptTypes::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);
}

void ScriptTypes::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## ScriptVariables.cpp

```cpp
#include "ScriptVariables.h"

#include "../../utils/UnigineScriptsInterpreter.h"

#include <UnigineInterface.h>
#include <UnigineWorld.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(ScriptVariables)

using namespace Unigine;
using namespace Unigine::Math;

void my_typeinfo(const Variable &v)
{
	switch (v.getType())
	{
	case Variable::INT: Log::message("%s my_typeinfo(): int: %d\n", sourse_str, v.getInt()); break;
	case Variable::LONG:
		Log::message("%s my_typeinfo(): long: %lld\n", sourse_str, v.getLong());
		break;
	case Variable::FLOAT:
		Log::message("%s my_typeinfo(): float: %g\n", sourse_str, v.getFloat());
		break;
	case Variable::DOUBLE:
		Log::message("%s my_typeinfo(): double: %g\n", sourse_str, v.getDouble());
		break;
	case Variable::VEC3:
		Log::message("%s my_typeinfo(): vec3: %g %g %g\n", sourse_str, v.getVec3().x, v.getVec3().y,
			v.getVec3().z);
		break;
	case Variable::VEC4:
		Log::message("%s my_typeinfo(): vec4: %g %g %g %g\n", sourse_str, v.getVec4().x,
			v.getVec4().y, v.getVec4().z, v.getVec4().w);
		break;
	case Variable::DVEC3:
		Log::message("%s my_typeinfo(): dvec3: %g %g %g\n", sourse_str, v.getDVec3().x,
			v.getDVec3().y, v.getDVec3().z);
		break;
	case Variable::DVEC4:
		Log::message("%s my_typeinfo(): dvec4: %g %g %g %g\n", sourse_str, v.getDVec4().x,
			v.getDVec4().y, v.getDVec4().z, v.getDVec4().w);
		break;
	case Variable::IVEC3:
		Log::message("%s my_typeinfo(): ivec3: %d %d %d\n", sourse_str, v.getIVec3().x,
			v.getIVec3().y, v.getIVec3().z);
		break;
	case Variable::IVEC4:
		Log::message("%s my_typeinfo(): ivec4: %d %d %d %d\n", sourse_str, v.getIVec4().x,
			v.getIVec4().y, v.getIVec4().z, v.getIVec4().w);
		break;
	}
}


void ScriptVariables::init()
{
	Console::setOnscreen(true);
	Console::setOnscreenFontSize(15);
	Console::setOnscreenTime(1000);
	Console::setOnscreenHeight(100);

	Engine *engine = Engine::get();
	Variable value, ret;

	// function identifier
	Variable my_typeinfo_id = Variable(engine->getWorldFunction("my_typeinfo", 1));

	// integer
	value.setInt(13);
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// long long
	value.setLong(13LL);
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// float
	value.setFloat(13.0f);
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// double
	value.setDouble(13.0);
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// vec3
	value.setVec3(vec3(1.0f, 2.0f, 3.0f));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// vec4
	value.setVec4(vec4(1.0f, 2.0f, 3.0f, 4.0f));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// dvec3
	value.setDVec3(dvec3(1.0, 2.0, 3.0));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// dvec4
	value.setDVec4(dvec4(1.0, 2.0, 3.0, 4.0));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// ivec3
	value.setIVec3(ivec3(1, 2, 3));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);

	// ivec4
	value.setIVec4(ivec4(1, 2, 3, 4));
	ret = engine->runWorldFunction(my_typeinfo_id, value);
	my_typeinfo(ret);
}

void ScriptVariables::shutdown()
{
	Console::setOnscreen(false);
	Console::setOnscreenHeight(30);
}

```

## Scroll.cpp

```cpp
#include "Scroll.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(Scroll);

using namespace Unigine;
using namespace Math;

void Scroll::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_scroll = WidgetScroll::create(gui);

	gui->addChild(widget_scroll, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_scroll->setPosition(position.get().x, position.get().y);
	widget_scroll->setOrientation(0);

	widget_scroll->getEventChanged().connect(*this, [this]() {
		String msg = String("Scroll: ") + String::itoa(widget_scroll->getValue());
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void Scroll::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_scroll);

		widget_scroll.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## Seeker.cpp

```cpp
#include "Seeker.h"

#include <UnigineVisualizer.h>
#include <UnigineGame.h>

#include "Target.h"

REGISTER_COMPONENT(Seeker);

using namespace Unigine;
using namespace Unigine::Math;

void Seeker::init()
{
	Visualizer::setEnabled(true);
	
	route = PathRoute::create();
	route->setRadius(route_radius);
	route->setHeight(route_height);
}

void Seeker::update()
{
	if (!target)
		return;
	
	float ifps = Game::getIFps();
	
	if (route->isReached())
	{
		vec3 direction { route->getPoint(1) - route->getPoint(0) };
		auto target_component = getComponent<PathfindingTarget>(target);
		float target_radius = 0.5f;
		
		if (target_component)
			target_radius = target_component->radius;
			
		if (distance(node->getWorldPosition(), target->getWorldPosition()) < target_radius)
		{
			if (target_component)
				target_component->onReached();
		}
		
		else
		{
			auto last_valid_position = node->getWorldPosition();
			auto current_rotation = node->getWorldRotation();
			auto target_rotation = current_rotation;
			
			if (direction.length2() > FLT_EPSILON)
				target_rotation = rotationFromDir(direction);
			
			float movement_speed_factor = 1.f - getAngle(current_rotation, target_rotation) * (1.f / 180.f);
			
			node->setWorldRotation(rotateTowards(current_rotation, target_rotation, rotation_speed * ifps), true);
			node->translate(Vec3_forward * movement_speed * movement_speed_factor * ifps);
			
			calculate_route();
			
			if (!is_inside_navigation())
				node->setWorldPosition(last_valid_position);
		}
		
		route->renderVisualizer(route_color);
	}
	
	else
	{
		Visualizer::renderLine3D(node->getWorldPosition(), target->getWorldPosition(), vec4_red, ifps);
		calculate_route();
	}
}

bool Seeker::is_inside_navigation()
{
	for (int i = 0; i < route->getNumPoints(); i += 1)
	{
		NavigationPtr navigation = route->getNavigation(i);
		bool is_inside = false;
		
		switch (route_type.get())
		{
			case Route2D:
				is_inside = navigation->inside2D(node->getWorldPosition(), route_radius);
				break;
			
			case Route3D:
				is_inside = navigation->inside3D(node->getWorldPosition(), route_radius);
				break;
		}
		
		if (is_inside)
			return true;
	}
	
	return false;
}

void Seeker::calculate_route()
{
	switch (route_type)
	{
		case Route2D:
			route->create2D(node->getWorldPosition(), target->getWorldPosition());
			break;
		
		case Route3D:
			route->create3D(node->getWorldPosition(), target->getWorldPosition());
			break;
	}
}

void Seeker::shutdown()
{
	Visualizer::setEnabled(false);
}

```

## Selection.cpp

```cpp
#include "Selection.h"
#include "UnitSelectionCircle.h"
#include <UnigineVisualizer.h>
#include <UnigineWindowManager.h>
#include <UnigineGame.h>
#include <UnigineConsole.h>

REGISTER_COMPONENT(Selection);

using namespace Unigine;
using namespace Math;

Unigine::Math::Vec3 Selection::getCenter()
{
	updateBoundShpere();
	return selected_objects_bound_sphere_position;
}

float Selection::getBoundRadius()
{
	updateBoundShpere();
	return selected_objects_bound_sphere_radius;
}

bool Selection::hasSelection()
{
	return selected_objects.size() != 0;
}

void Selection::update()
{
	// works only when the Concole is inactive
	if (!Console::isActive())
	{
		Visualizer::setEnabled(true);

		// if the left mouse button is pressed, save cursor coordinates and set a flag indicating that selection has started
		if (Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT))
		{
			is_selection = true;
			selection_start_mouse_position = Input::getMousePosition() - WindowManager::getMainWindow()->getClientPosition();
		}

		// render selection box
		if (is_selection)
		{
			auto windowSize = WindowManager::getMainWindow()->getClientRenderSize();
			upper_left_selection_corner = vec2(selection_start_mouse_position.x * 1.0f / windowSize.x, 1.0f - selection_start_mouse_position.y * 1.0f / windowSize.y);
			ivec2 currentMousePosition = Input::getMousePosition() - WindowManager::getMainWindow()->getClientPosition();
			bottom_right_selection_corner = vec2(currentMousePosition.x * 1.0f / windowSize.x, 1.0f - currentMousePosition.y * 1.0f / windowSize.y);

			Visualizer::renderRectangle(vec4(upper_left_selection_corner, bottom_right_selection_corner), vec4_green);
		}

		// when the left mouse button is released, start looking for objects in selection box
		if (Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT))
		{
			PlayerPtr camera = Game::getPlayer();

			// unselect previously selected objects
			for (const ObjectPtr& it : selected_objects)
			{
				auto unitSelectionComponent = getComponent<UnitSelectionCircle>(it);
				unitSelectionComponent->setSelected(false);
			}

			// setting a flag indicating that selection action has stopped and calculate width and height of selection box
			is_selection = false;

			// getting perspective projection matrix for frustum
			ivec2 selectionFinishPosition(Input::getMousePosition() - WindowManager::getMainWindow()->getPosition());
			mat4 perspective = camera->getProjectionFromMainWindow(selection_start_mouse_position.x, selection_start_mouse_position.y, selectionFinishPosition.x, selectionFinishPosition.y);

			// setting frustum matrices
			frustum.set(perspective, inverse(camera->getWorldTransform()));
			// getting objects inside the selection box with initial mouse coordinates
			World::getIntersection(frustum, selected_objects);
			if (selected_objects.size() == 0)
			{
				vec3 dir(camera->getDirectionFromMainWindow(Input::getMousePosition().x, Input::getMousePosition().y));
				ObjectPtr objectUnderCursor = World::getIntersection(camera->getWorldPosition(), camera->getWorldPosition() + Vec3(dir) * 1000, ~0);
				if (objectUnderCursor)
					selected_objects.push_back(objectUnderCursor);
			}

			// mark selected objects
			for (int i = 0; i < selected_objects.size(); i++)
			{
				auto unitSelectionComponent = getComponent<UnitSelectionCircle>(selected_objects[i]);
				if (unitSelectionComponent)
				{
					unitSelectionComponent->setSelected(true);
				}
				else
				{
					selected_objects.removeFast(i);
					i--;
				}
			}
			updateBoundShpere();
		}
	}
}

void Selection::updateBoundShpere()
{
	WorldBoundSphere bs;
	for (int i = 0; i < selected_objects.size(); i++)
	{
		bs.expand(selected_objects[i]->getWorldBoundSphere());
	}
	selected_objects_bound_sphere_position = bs.center;
	selected_objects_bound_sphere_radius = (float)bs.radius * 4.0f;
}

```

## SimpleAsyncRequestSample.cpp

```cpp
#include "SimpleAsyncRequestSample.h"

#include <UniginePlayers.h>
#include <UnigineGame.h>
#include <UnigineInput.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(SimpleAsyncRequestSample);

using namespace Unigine;
using namespace Math;

void SimpleAsyncRequestSample::init()
{
	init_gui();

	Visualizer::setEnabled(true);
}

void SimpleAsyncRequestSample::update()
{
	// update player intersection
	PlayerPtr main_player = Game::getPlayer();
	if (main_player)
	{
		if (is_player_completed)
		{
			is_player_completed = false;

			Vec3 p0 = main_player->getWorldPosition();
			const auto mouse_coord = Input::getMousePosition();
			Vec3 p1 = p0 + Vec3(main_player->getDirectionFromMainWindow(mouse_coord.x, mouse_coord.y)) * intersection_distance.get();

			NodePtr check_deleted = node; // capture the smart pointer to prevent the lambda from being called on a destroyed object
			Intersections::getAsync(p0, p1, 1, [this, check_deleted](IntersectionRequest *r)
			{
				if (!check_deleted)
					return;

				is_player_completed = true;

				if (r->isIntersection())
				{
					player_result.point = r->getPoint();
					player_result.normal = r->getNormal();
				}
				player_result.is_intersected = r->isIntersection();

				player_latency[player_latency_index] = r->getAsyncFrameLatency();
				player_latency_index++;
				if (player_latency_index == PLAYER_LATENCY_COUNT)
					player_latency_index = 0;

				avg_player_latency = 0.0f;
				max_player_latency = 0;
				for (int i = 0; i < PLAYER_LATENCY_COUNT; i++)
				{
					max_player_latency = max(max_player_latency, player_latency[i]);
					avg_player_latency += player_latency[i];
				}
				avg_player_latency /= PLAYER_LATENCY_COUNT;

			});
		}

		if (player_result.is_intersected)
			Visualizer::renderVector(player_result.point, player_result.point + Vec3(player_result.normal) * 10.0f, vec4_green);
	}

	String text = String::format("Latency (number of frames per result)\nPlayer: avg %f, max %lld\n\n", avg_player_latency, max_player_latency);
	sample_description_window.setStatus(text.get());
}

void SimpleAsyncRequestSample::shutdown()
{
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

void SimpleAsyncRequestSample::init_gui()
{
	sample_description_window.createWindow();
}

```

## SimpleHttpRequestSample.cpp

```cpp
#include "SimpleHttpRequestSample.h"

#include <UnigineWidgets.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(SimpleHttpRequestSample);

using namespace Unigine;
using namespace Math;

void SimpleHttpRequestSample::init()
{
	init_gui();

	ThreadQueue::get().run();
}

void SimpleHttpRequestSample::update()
{
	if (city_request.size() && city_request.last()->isCompleted())
	{
		w_list->clear();

		if (httplib::Result &result = city_request.last()->get())
		{
			JsonPtr json = Json::create();
			json->parse(result->body.c_str());
			Log::message("response:\n%s\n", json->getFormattedSubTree().get());
			auto arr = json->getChild("results");
			if (arr && arr->getNumChildren() != 0)
			{
				for (int i = 0; i < arr->getNumChildren(); i++)
				{
					auto child = arr->getChild(i);
					String name = child->getChild("name")->getString();
					if (child->isChild("country"))
						name += ", " + child->getChild("country")->getString();
					if (child->isChild("admin1"))
						name += ", " + child->getChild("admin1")->getString();

					int item = w_list->addItem(name);

					double lat = child->getChild("latitude")->getNumber();
					double lon = child->getChild("longitude")->getNumber();
					String data = String::format("latitude=%f&longitude=%f", lat, lon);

					w_list->setItemData(item, data);
				}
			} else
			{
				w_search->setFontColor(vec4_red);
			}
		} else
		{
			String error = httplib::to_string(result.error()).c_str();
			Log::error("%s\n", error.get());
		}
		city_request.clear();
	}

	if (forecast_request && forecast_request->isCompleted())
	{
		String res;

		if (httplib::Result &result = forecast_request->get())
		{
			JsonPtr json = Json::create();
			json->parse(result->body.c_str());
			Log::message("response:\n%s\n", json->getFormattedSubTree().get());

			res += "Temperature: ";
			res += String::ftoa(toFloat(json->getChild("current")->getChild("temperature_2m")->getNumber()), 1);
			res += json->getChild("current_units")->getChild("temperature_2m")->getString();
			res += "\n";

			res += "Humidity: ";
			res += String::ftoa(toFloat(json->getChild("current")->getChild("relative_humidity_2m")->getNumber()), 1);
			res += json->getChild("current_units")->getChild("relative_humidity_2m")->getString();
			res += "\n";

			res += "Precipitation: ";
			res += String::ftoa(toFloat(json->getChild("current")->getChild("precipitation")->getNumber()), 1);
			res += json->getChild("current_units")->getChild("precipitation")->getString();
			res += "\n";

			res += "Wind Speed: ";
			res += String::ftoa(toFloat(json->getChild("current")->getChild("wind_speed_10m")->getNumber()), 1);
			res += json->getChild("current_units")->getChild("wind_speed_10m")->getString();
			res += "\n";

			res += "Wind Direction: ";
			res += String::ftoa(toFloat(json->getChild("current")->getChild("wind_direction_10m")->getNumber()), 1);
			res += json->getChild("current_units")->getChild("wind_direction_10m")->getString();
			res += "\n";
		} else
		{
			String error = httplib::to_string(result.error()).c_str();
			Log::error("%s\n", error.get());
		}
		sample_description_window.setStatus(res);

		forecast_request.reset();
	}
}

void SimpleHttpRequestSample::shutdown()
{
	ThreadQueue::get().stop();
	sample_description_window.shutdown();
}

void SimpleHttpRequestSample::init_gui()
{
	sample_description_window.createWindow();

	sample_description_window.getWindow()->arrange();
	auto size = Gui::getCurrent()->getSize() / 2 - ivec2(sample_description_window.getWindow()->getWidth(), sample_description_window.getWindow()->getHeight()) / 2;
	sample_description_window.getWindow()->setPosition(size.x, size.y);

	auto gui = Gui::getCurrent();

	auto &parent = sample_description_window.getWindow();

	auto w_group_search = WidgetGroupBox::create("Search", 20, 10);
	parent->addChild(w_group_search, Gui::ALIGN_EXPAND);

	w_search = WidgetEditLine::create(gui);
	w_search->setToolTip("search city by name");
	w_group_search->addChild(w_search, Gui::ALIGN_EXPAND);

	w_search->getEventKeyPressed().connect(*this, [this]()
		{
		w_search->setFontColor(vec4_white);
		String str = "/v1/search?name=";
		str += w_search->getText();

		// create new async request, and place it in array
		// http://geocoding-api.open-meteo.com/v1/search?name=name
		city_request.push_back(std::make_unique<AsyncTask<httplib::Result>>([str]() -> httplib::Result {
				httplib::Client cli("geocoding-api.open-meteo.com");
				return cli.Get(str.get());
			})); });

	w_list = WidgetListBox::create(gui);
	w_group_search->addChild(w_list, Gui::ALIGN_LEFT);
	w_list->getEventChanged().connect(*this, [this]()
		{
			sample_description_window.setStatus("");
			if (w_list->getCurrentItem() != -1)
			{
				sample_description_window.setStatus("request...");
				// create new request
				// api.open-meteo.com/v1/forecast?latitude=12.34&longitude=12.34&current=temperature_2m,relative_humidity_2m,precipitation,wind_speed_10m,wind_direction_10m
				auto request_str = String::format("/v1/forecast?%s&current=temperature_2m,relative_humidity_2m,precipitation,wind_speed_10m,wind_direction_10m", w_list->getCurrentItemData());
				forecast_request = std::make_unique<AsyncTask<httplib::Result>>([request_str]() -> httplib::Result {
					httplib::Client cli("api.open-meteo.com");
					return cli.Get(request_str.get());
				});
			}
		});

	sample_description_window.setStatus("Type city name");
}

```

## SimpleHttpResponseSample.cpp

```cpp
#include "SimpleHttpResponseSample.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(SimpleHttpResponseSample);

using namespace Unigine;
using namespace Math;

void SimpleHttpResponseSample::init_gui()
{
	auto object_text = checked_ptr_cast<ObjectText>(pedestal_text.get());
	object_text->setFontRich(1);
	object_text->setText("<p>Open:</p><p>http://" + String(host_ip.get()) + ":" + String::itoa(port) + "/player_pos</p>");
	auto prev_pos = object_text->getPosition();
	object_text->setPosition(Vec3(object_text->getTextWidth() / 2, prev_pos.y, prev_pos.z));
}

void SimpleHttpResponseSample::init()
{
	init_gui();

	server = new HttpServer(host_ip.get(), port.get());

	server->get("/player_pos", [](const httplib::Request& req, httplib::Response& res) {
		// This function will be called from main thread because it is not marked as asynchronous
		auto player = Game::getPlayer();

		if (player)
		{
			Vec3 position = player->getWorldPosition();
			String response = "Player position:\r\n";
			response += "x: " + String::ftoa(position.x) + "\r\n";
			response += "y: " + String::ftoa(position.y) + "\r\n";
			response += "z: " + String::ftoa(position.z) + "\r\n";
			res.set_content(response.get(), "text/plain");
		}
		else
		{
			res.status = 500;
			res.set_content("The player is currently unspecified.", "text/plain");
		}
	});

	server->run();

}

void SimpleHttpResponseSample::shutdown()
{
	server->stop();
	delete server;
	server = nullptr;
}

```

## SimpleInformationBox.cpp

```cpp
#include "SimpleInformationBox.h"
#include <UnigineWindowManager.h>

REGISTER_COMPONENT(SimpleInformationBox);

using namespace Unigine;
using namespace Math;

void SimpleInformationBox::init()
{
	window = WidgetWindow::create();
	WindowManager::getMainWindow()->addChild(window, Gui::ALIGN_OVERLAP);
	window->setMaxWidth(500);

	main_background = WidgetVBox::create();
	window->addChild(main_background, Gui::ALIGN_EXPAND);

	about_groupbox = WidgetGroupBox::create("About", 8, 8);
	main_background->addChild(about_groupbox, Gui::ALIGN_LEFT);

	about_label = WidgetLabel::create();
	about_label->setFontWrap(1);
	about_label->setFontRich(1);
	about_label->setWidth(600);
	about_groupbox->addChild(about_label, Gui::ALIGN_EXPAND);

	main_gridbox = WidgetGridBox::create(0);
	main_background->addChild(main_gridbox, Gui::ALIGN_EXPAND);

	window->arrange();

	previous_handle = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
}

void SimpleInformationBox::shutdown()
{
	widget_connections.disconnectAll();
	window.deleteLater();
	Input::setMouseHandle(previous_handle);
}

void SimpleInformationBox::setAboutInfo(const char* str)
{
	about_label->setText(str);
	window->arrange();
}

void SimpleInformationBox::setParametersInfo(int index, const char *str)
{
	if (index < parameters_labels.size())
		parameters_labels[index]->setText(str);
	window->arrange();
}

WidgetPtr SimpleInformationBox::getColumn(int index)
{
	return main_gridbox->getChild(index);
}

void SimpleInformationBox::setColumnsCount(int count)
{
	while (main_gridbox->getNumChildren() > 0)
	{
		auto child = main_gridbox->getChild(0);
		main_gridbox->removeChild(child);
		child.deleteForce();
	}

	parameters_groupboxes.clear();
	parameters_labels.clear();
	additional_widgets.clear();

	main_gridbox->setNumColumns(count);

	for (int i = 0; i < count; i++)
	{
		auto background = WidgetVBox::create();
		main_gridbox->addChild(background, Gui::ALIGN_TOP);

		auto parameters_groupbox = WidgetGroupBox::create("Parameters", 8, 2);
		background->addChild(parameters_groupbox, Gui::ALIGN_LEFT);
		parameters_groupboxes.append(parameters_groupbox);

		auto parameters_label = WidgetLabel::create();
		parameters_label->setFontWrap(1);
		parameters_label->setFontRich(1);
		parameters_label->setWidth(width_in_pixels);
		parameters_groupbox->addChild(parameters_label, Gui::ALIGN_LEFT);
		parameters_labels.append(parameters_label);

		auto grid = WidgetGridBox::create(3);
		additional_widgets.append(grid);
		parameters_groupbox->addChild(grid, Gui::ALIGN_EXPAND);
	}

	window->arrange();
}

void SimpleInformationBox::setWidth(int width)
{
	if (width > 0)
	{
		width_in_pixels = width;
		about_label->setWidth(width_in_pixels*parameters_labels.size() + 1);
		for(auto& it : parameters_labels)
			it->setWidth(width_in_pixels);
	}
	window->arrange();
}

WidgetComboBoxPtr SimpleInformationBox::addCombobox(int index, const char* name, const char* tooltip)
{
	if (index >= parameters_groupboxes.size())
		return nullptr;

	auto combobox_container = additional_widgets[index];
	auto combobox_name_Label = WidgetLabel::create(name);
	combobox_container->addChild(combobox_name_Label, Gui::ALIGN_LEFT);
	auto combobox = WidgetComboBox::create();
	combobox_container->addChild(combobox, Gui::ALIGN_EXPAND);
	auto label_spacer = WidgetLabel::create();
	combobox_container->addChild(label_spacer);

	combobox_name_Label->setToolTip(tooltip);
	combobox->setToolTip(tooltip);


	return combobox;
}

Unigine::WidgetSliderPtr SimpleInformationBox::addSlider(int index, const char* name, float multiplier, const char* tooltip)
{
	if (index >= parameters_groupboxes.size())
		return nullptr;

	auto slider_container = additional_widgets[index];
	auto slider_name_Label = WidgetLabel::create(name);
	slider_container->addChild(slider_name_Label, Gui::ALIGN_LEFT);
	auto slider = WidgetSlider::create();
	slider_container->addChild(slider, Gui::ALIGN_EXPAND);
	auto slider_value_label = WidgetLabel::create();
	slider_value_label->setWidth(45);
	slider->getEventChanged().connect(widget_connections, [slider, slider_value_label, multiplier]() {
		slider_value_label->setText(String::format("%.2f", slider->getValue() * multiplier));
		});
	slider_value_label->setText(String::format("%.2f", slider->getValue() * multiplier));
	slider_container->addChild(slider_value_label, Gui::ALIGN_LEFT);

	slider_name_Label->setToolTip(tooltip);
	slider->setToolTip(tooltip);
	slider_value_label->setToolTip(tooltip);

	return slider;
}

void SimpleInformationBox::pushBackAboutInfo( const char* str, INFO_ALIGN align)
{

	String labelText = about_label->getText();

	switch (align)
	{
	case INFO_ALIGN::LEFT:
		labelText += "<p align=left>";
		break;
	case INFO_ALIGN::CENTER:
		labelText += "<p align=center>";
		break;
	case INFO_ALIGN::RIGHT:
		labelText += "<p align=right>";
		break;
	case INFO_ALIGN::JUSTIFY:
		labelText += "<p align=justify>";
		break;
	default:
		labelText += "<p>";
	}

	labelText += str;
	labelText += "</p>";

	about_label->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::pushBackAboutInfo(const char* str1, const char* str2, INFO_ALIGN align)
{
	String labelText = about_label->getText();

	switch (align)
	{
	case INFO_ALIGN::LEFT:
		labelText += "<p align=left>";
		break;
	case INFO_ALIGN::CENTER:
		labelText += "<p align=center>";
		break;
	case INFO_ALIGN::RIGHT:
		labelText += "<p align=right>";
		break;
	case INFO_ALIGN::JUSTIFY:
		labelText += "<p align=justify>";
		break;
	default:
		labelText += "<p>";
	}

	labelText += str1;
	labelText += ":";
	labelText += "<right>";
	labelText += str2;
	labelText += "<left></p>";

	about_label->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::pushBackParametersInfo(int index, const char* str, INFO_ALIGN align)
{
	if (index >= parameters_labels.size())
		return;

	String labelText = parameters_labels[index]->getText();

	switch (align)
	{
	case INFO_ALIGN::LEFT:
		labelText += "<p align=left>";
		break;
	case INFO_ALIGN::CENTER:
		labelText += "<p align=center>";
		break;
	case INFO_ALIGN::RIGHT:
		labelText += "<p align=right>";
		break;
	case INFO_ALIGN::JUSTIFY:
		labelText += "<p align=justify>";
		break;
	default:
		labelText += "<p>";
	}

	labelText += str;
	labelText += "</p>";

	parameters_labels[index]->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::pushBackParametersInfo(int index, const char* str1, const char* str2, INFO_ALIGN align)
{
	if (index >= parameters_labels.size())
		return;

	String labelText = parameters_labels[index]->getText();

	switch (align)
	{
	case INFO_ALIGN::LEFT:
		labelText += "<p align=left>";
		break;
	case INFO_ALIGN::CENTER:
		labelText += "<p align=center>";
		break;
	case INFO_ALIGN::RIGHT:
		labelText += "<p align=right>";
		break;
	case INFO_ALIGN::JUSTIFY:
		labelText += "<p align=justify>";
		break;
	default:
		labelText += "<p>";
	}

	labelText += str1;
	labelText += ":";
	labelText += "<right>";
	labelText += str2;
	labelText += "<left></p>";

	parameters_labels[index]->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::pushBackWhiteSpaceLineAboutInfo()
{
	String labelText = about_label->getText();
	labelText += "<br>";
	about_label->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::pushBackWhiteSpaceLineParametersInfo(int index)
{
	if (index >= parameters_labels.size())
		return;

	String labelText = parameters_labels[index]->getText();
	labelText += "<br>";
	parameters_labels[index]->setText(labelText);
	window->arrange();
}

void SimpleInformationBox::showAdditionalWidgets(int index, bool value)
{
	if (index >= parameters_groupboxes.size())
		return;
	parameters_groupboxes[index]->setHidden(!value);
}

```

## SimpleMovement.cpp

```cpp
#include "SimpleMovement.h"

#include "UnigineConsole.h"
#include "UnigineGame.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(SimpleMovement);
REGISTER_COMPONENT(SimpleMovement2);
REGISTER_COMPONENT(SimpleMovement3);

/*=============== Simple Movement variant 1 ===============*/

/*
* Move with Node::translate method
* Turn with Node::rotate method
*/

void SimpleMovement::update()
{
	if (Console::isActive())
		return;

	/* determine forward or backward move */
	int move_sign = int(Input::isKeyPressed(Input::KEY_W)) - int(Input::isKeyPressed(Input::KEY_S));
	if (move_sign)
	{
		move(Vec3(0.0f, float(move_sign), 0.0f));
	}

	/* determine left or right turn */
	int rotate_sign = int(Input::isKeyPressed(Input::KEY_A)) - int(Input::isKeyPressed(Input::KEY_D));
	if (rotate_sign)
	{
		turn(vec3(0.0f, 0.0f, float(rotate_sign)));
	}
}

void SimpleMovement::move(const Unigine::Math::Vec3& dir)
{
	Vec3 delta_movement = dir * velocity * Game::getIFps();

	node->translate(delta_movement);
}

void SimpleMovement::turn(const Unigine::Math::vec3& dir)
{
	vec3 delta_rotation = dir * angular_velocity * Game::getIFps();
	node->rotate(delta_rotation);
}


/*=============== Simple Movement variant 2 ===============*/

/*
* Move with Node::setPosition method
* Turn with Node::setRotation method
*/

void SimpleMovement2::update()
{
	if (Console::isActive())
		return;

	/* determine forward or backward move */
	int move_sign = int(Input::isKeyPressed(Input::KEY_W)) - int(Input::isKeyPressed(Input::KEY_S));
	if (move_sign)
	{
		move(Vec3(0.0f, float(move_sign), 0.0f));
	}

	/* determine left or right turn */
	int rotate_sign = int(Input::isKeyPressed(Input::KEY_A)) - int(Input::isKeyPressed(Input::KEY_D));
	if (rotate_sign)
	{
		turn(vec3(0.0f, 0.0f, float(rotate_sign)));
	}
}

void SimpleMovement2::move(const Unigine::Math::Vec3& dir)
{
	Vec3 deltaMovement = node->getRotation() * (dir * velocity * Game::getIFps());
	Vec3 oldPosition = node->getPosition();
	node->setPosition(oldPosition + deltaMovement);
}

void SimpleMovement2::turn(const Unigine::Math::vec3& dir)
{
	float deltaRotation = angular_velocity * Game::getIFps();
	quat oldRotation = node->getRotation();
	node->setRotation(oldRotation * quat(dir, deltaRotation));
}


/*=============== Simple Movement variant 3 ===============*/

/*
* Move with Node::setTransform method
* Turn with Node::setTransform method
*/

void SimpleMovement3::update()
{
	if (Console::isActive())
		return;

	/* determine forward or backward move */
	int move_sign = int(Input::isKeyPressed(Input::KEY_W)) - int(Input::isKeyPressed(Input::KEY_S));
	if (move_sign)
	{
		move(Vec3(0.0f, float(move_sign), 0.0f));
	}

	/* determine left or right turn */
	int rotate_sign = int(Input::isKeyPressed(Input::KEY_A)) - int(Input::isKeyPressed(Input::KEY_D));
	if (rotate_sign)
	{
		turn(vec3(0.0f, 0.0f, float(rotate_sign)));
	}
}

void SimpleMovement3::move(const Unigine::Math::Vec3& dir)
{
	Mat4 transform = node->getTransform();
	Vec3 delta_movement = dir * velocity * Game::getIFps();
	Mat4 delta_transform = translate(delta_movement);
	node->setTransform(transform * delta_transform);
}

void SimpleMovement3::turn(const Unigine::Math::vec3& dir)
{
	Mat4 transform = node->getTransform();
	float deltaRotation = angular_velocity * Game::getIFps();
	Mat4 delta_transform = Unigine::Math::rotate(Vec3(dir), deltaRotation);
	node->setTransform(transform * delta_transform);
}

```

## SimpleMovementInfo.cpp

```cpp
#include "SimpleMovementInfo.h"

#include "SimpleMovement.h"

REGISTER_COMPONENT(SimpleMovementInfo);

using namespace Unigine;
using namespace Math;

void SimpleMovementInfo::init()
{
	init_components();

	sample_description_window.createWindow();

	sample_description_window.addFloatParameter("Velocity", "Velocity", 3.f, 1.f, 50.f, [this](float v) {
		simple_movement->velocity = v;
		simple_movement2->velocity = v;
		simple_movement3->velocity = v;
	});

	sample_description_window.addFloatParameter("Angular Velocity", "Angular Velocity", 50.f, 1.f, 100.f,
		[this](float v) {
			simple_movement->angular_velocity = v;
			simple_movement2->angular_velocity = v;
			simple_movement3->angular_velocity = v;
		});

	auto parameters = sample_description_window.getParameterGroupBox();
	auto reset_button = WidgetButton::create("Reset Position");
	reset_button->getEventClicked().connect(*this, [this](const Ptr<Widget> &, int) {
		simple_movement_node->setTransform(simple_movement_start_transform);
		simple_movement2_node->setTransform(simple_movement2_start_transform);
		simple_movement3_node->setTransform(simple_movement3_start_transform);
	});
	parameters->addChild(reset_button, Gui::ALIGN_LEFT | Gui::ALIGN_EXPAND);
}

void SimpleMovementInfo::shutdown()
{
	sample_description_window.shutdown();
}

void SimpleMovementInfo::init_components()
{
	simple_movement = getComponent<SimpleMovement>(simple_movement_node);
	simple_movement2 = getComponent<SimpleMovement2>(simple_movement2_node);
	simple_movement3 = getComponent<SimpleMovement3>(simple_movement3_node);

	if (!simple_movement)
	{
		Log::error("SimpleMovementInfo::init: cannot find SimpleMovement node!\n");
	}
	else
	{
		simple_movement_start_transform = simple_movement_node->getTransform();
	}

	if (!simple_movement2)
	{
		Log::error("SimpleMovementInfo::init: cannot find SimpleMovement2 node!\n");
	}
	else
	{
		simple_movement2_start_transform = simple_movement2_node->getTransform();
	}

	if (!simple_movement3)
	{
		Log::error("SimpleMovementInfo::init: cannot find SimpleMovement3 node!\n");
	}
	else
	{
		simple_movement3_start_transform = simple_movement3_node->getTransform();
	}
}

```

## SimplePathControl.cpp

```cpp
#include "SimplePathControl.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

void recursiveCall(const Unigine::NodePtr &node, std::function<void(const Unigine::NodePtr &)> func)
{
	if (!node)
	{
		return;
	}

	func(node);

	if (node->getType() == Unigine::Node::NODE_REFERENCE)
	{
		auto ref = Unigine::checked_ptr_cast<Unigine::NodeReference>(node);
		if (ref && ref->getReference())
		{
			recursiveCall(ref->getReference(), func);
		}
	}

	for (int i = 0; i < node->getNumChildren(); i++)
	{
		recursiveCall(node->getChild(i), func);
	}
}

REGISTER_COMPONENT(SimplePathControl);

void SimplePathControl::init()
{
	float min_distance = Consts::INF;
	if (path_node.get())
	{
		for (int i = 0; i < path_node->getNumChildren(); i++)
		{
			auto p = path_node->getChild(i)->getWorldTransform();
			float distance = (float)length2(node->getWorldPosition() - p.getTranslate());
			if (distance < min_distance)
			{
				current_path_index = i;
				min_distance = distance;
			}
			path.append(p);
		}
	}
}

void SimplePathControl::update()
{
	if (!enable_button.get())
	{
		return;
	}
	if (init_button)
	{
		path.clear();
		init();
		init_button = 0;
	}

	if (path.empty())
	{
		return;
	}

	if (Game::getTime() < wait_before_start)
	{
		return;
	}

	auto current_position = node->getWorldPosition();
	auto current_rot = node->getWorldRotation();


	auto route = path[current_path_index];

	float ifps = Game::getIFps();
	if (ifps == 0)
	{
		return;
	}

	vec3 ddir = vec3(route.getTranslate() - current_position).normalizeValid();
	Visualizer::renderLine3D(current_position, route.getTranslate(), vec4_red);

	float d = dot(current_rot.getMat3().getAxisX(), ddir);
	if (isnan(d))
	{
		d = 0;
	}
	rot_acceleration += (d > rot_acceleration ? ifps : -ifps);

	current_rot = current_rot * quat(vec3_up, torque_param * ifps * -rot_acceleration);

	current_position = current_position + Vec3(current_rot.getMat3().getAxisY()) * ifps * speed;

	node->setWorldPosition(current_position);
	node->setWorldRotation(current_rot);

	float distance_to_target = (float)length(route.getTranslate() - current_position);

	if (distance_to_target < 10)
	{
		current_path_index += dir;

		if (current_path_index == path.size())
		{
			if (circle)
			{
				current_path_index = 0;
			}
			else
			{
				dir *= -1;
				current_path_index += dir;
			}
		}
		else if (current_path_index == -1)
		{
			if (circle)
			{
				current_path_index = path.size() - 1;
			}
			else
			{
				dir *= -1;
				current_path_index += dir;
			}
		}
	}
}

void SimplePathControl::shutdown() {}

```

## SingletonAnimationSample.cpp

```cpp
#include <UnigineGame.h>
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class SingletonAnimationSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(SingletonAnimationSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		// create tracks and playbacks
		create_animations();

		playback->play();

		gui.init();
	}

	void update()
	{
		gui.update();
	}

	void shutdown()
	{
		gui.shutdown();

		// all of the animation tracks, playbacks and objects are managed by the animation system and have the "engine lifetime",
		// i.e. they exist from the point they're loaded / created to when the engine shutdowns,
		// and therefore are preserved between different worlds

		// you have to stop active playbacks when switching to another world, if you don't want them continue playing there
		playback->stop();

		// restore render fade color
		Render::setBackgroundColor(vec4(0.f, 0.f, 0.f, 0.f));
	}

	void create_animations()
	{
		// create new track
		AnimationTrackPtr track = AnimationTrack::create();

		// animate gravity
		auto gravity_modifier = AnimationModifierFloat::create("physics.gravity_z");
		gravity_modifier->addValue(0.0f, -9.8f);
		gravity_modifier->addValue(3.0f, 2.5f);
		gravity_modifier->addValue(4.0f, -1.0f);
		gravity_modifier->addValue(5.0f, -4.5f);
		gravity_modifier->addValue(6.0f, -9.8f);
		track->addSingletonModifier(gravity_modifier);

		// animate fade color
		auto color_modifier = AnimationModifierFloat::create("render.background_color_w");
		color_modifier->addValue(0.0f, 0.0f);
		color_modifier->addValue(3.0f, 1.0f);
		color_modifier->addValue(4.0f, 1.0f);
		color_modifier->addValue(5.0f, 0.5f);
		color_modifier->addValue(6.0f, 0.0f);
		track->addSingletonModifier(color_modifier);

		// create track playback
		playback = AnimationPlayback::create();
		playback->setTrack(track);
		playback->setLoop(true);

		// you can save the created tracks and playbacks to disk if you want to use them later ...
		Dir::mkdir(FileSystem::getAbsolutePath(joinPaths(getWorldRootPath(), "tracks")));
		Animations::saveTrack(track, joinPaths(getWorldRootPath(), "tracks", "singletons.utrack"));
		Animations::savePlayback(playback, joinPaths(getWorldRootPath(), "tracks", "singletons.uplay"));

		// ... and then load them manually if they weren't loaded automatically at the engine initialization stage
		Animations::RESULT result = Animations::loadPlayback(joinPaths(getWorldRootPath(), "tracks", "singletons.uplay"));
		if (result != Animations::RESULT_PLAYBACK_ERROR)
		{
			// you can access tracks and playbacks from the animation system by their index, guid, file guid or file path
			playback = Animations::getPlaybackByPath(joinPaths(getWorldRootPath(), "tracks", "singletons.uplay"));
		}
	}

	// ========================================================================================

	struct SampleGui
	{
		void init()
		{
			sample_description_window.createWindow();

			auto w = sample_description_window.getWindow();
			auto state_gbox = WidgetGroupBox::create("State", 9, 3);
			w->addChild(state_gbox);

			auto gridbox = WidgetGridBox::create(2);
			state_gbox->addChild(gridbox, Gui::ALIGN_LEFT);

			auto add_parameter = [](const WidgetGridBoxPtr &gridbox, const char *name) {
				auto hbox = WidgetHBox::create();

				hbox->addChild(WidgetLabel::create(name));
				hbox->addChild(WidgetHBox::create(6));

				gridbox->addChild(hbox, Gui::ALIGN_LEFT);

				auto bg_color = WidgetEditLine::create();
				bg_color->setEditable(false);
				bg_color->setFontVOffset(-2);
				bg_color->setFontColor(vec4(vec3(.9f), 1.f));
				bg_color->setWidth(50);

				gridbox->addChild(bg_color, Gui::ALIGN_LEFT);
				return bg_color;
			};

			bg_color = add_parameter(gridbox, "render.background_color.a");
			gravity = add_parameter(gridbox, "physics.gravity.z");
		}

		void update()
		{
			bg_color->setText(String::format("%.2f", Render::getBackgroundColor().w));
			gravity->setText(String::format("%.1f", Physics::getGravity().z));
		}

		void shutdown() { sample_description_window.shutdown(); }

		SampleDescriptionWindow sample_description_window;
		WidgetEditLinePtr bg_color;
		WidgetEditLinePtr gravity;
	};

	AnimationPlaybackPtr playback;
	SampleGui gui;
};

REGISTER_COMPONENT(SingletonAnimationSample);

```

## Slider.cpp

```cpp
#include "Slider.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(Slider);

using namespace Unigine;
using namespace Math;

void Slider::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_slider = WidgetSlider::create(gui);

	gui->addChild(widget_slider, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_slider->setPosition(position.get().x, position.get().y);
	widget_slider->setWidth(size.get().x);
	widget_slider->setHeight(size.get().y);
	widget_slider->setButtonWidth(button_width.get());

	widget_slider->getEventChanged().connect(*this, [this]() {
		String msg = String("Slider: ") + String::itoa(widget_slider->getValue());
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void Slider::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_slider);

		widget_slider.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## SlingRope.cpp

```cpp
#include "SlingRope.h"

#include <UnigineGame.h>
#include <UniginePhysics.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(SlingRope)

void SlingRope::setLength(float len)
{
	// minimum of two segments are required for joints to work properly
	len = Math::max(2.0f * segment_length, len);
	if (len == rope_length)
		return;

	rope_length = len;

	// get integer and fractional part on number of segments
	float segments = rope_length / segment_length;
	int new_num_segments = ftoi(ceilf(segments));
	segments_offset = frac(segments);

	// update rope anchor position to change length smoothly
	if (rope_obj)
	{
		Vec3 anchor_pos = anchor_obj->getWorldPosition();
		if (segments_offset != 0.0f)
			anchor_pos += Vec3_up * segment_length * (1.0f - segments_offset);

		anchor_body->setTransform(translate(anchor_pos));
	}

	// add new segments
	if (new_num_segments != num_segments)
		change_num_segments(new_num_segments - num_segments);
}

void SlingRope::attachBag()
{
	if (bag_attached)
		return;

	bag_node->setWorldTransform(translate(rope_body->getParticlePosition(0)
		- (bag_anchor->getWorldPosition() - bag_body->getPosition())));
	rope_body->setParticlePosition(0, bag_anchor->getWorldPosition());

	bag_attached = create_bag_joint();
}

void SlingRope::detachBag()
{
	if (bag_attached && bag_joint)
	{
		if (rope_body)
			rope_body->removeJoint(bag_joint);
		bag_joint.deleteLater();
		bag_attached = false;
	}
}

void SlingRope::setBagMass(float mass)
{
	if (bag_body)
	{
		if (bag_body->isShapeBased() && bag_body->getNumShapes() > 0)
			bag_body->getShape(0)->setMass(mass);
		else
			bag_body->setMass(mass);
	}
}

float SlingRope::getBagMass() const
{
	if (bag_body)
		return bag_body->getMass();

	return 0.0;
}

void SlingRope::setTensionCompensationEnabled(bool enable)
{
	tension_enabled = enable;
	if (!enable)
		rope_body->setMass(mass);
}

void SlingRope::setDebugEnabled(bool enable)
{
	debug_enabled = enable;
	Visualizer::setEnabled(debug_enabled);
}

void SlingRope::init()
{
	// init anchor object and dummy body where rope will be attached to crane
	anchor_obj = checked_ptr_cast<ObjectDummy>(node);
	if (!anchor_obj)
	{
		Log::error("%s(): SlingRope node must be ObjectDummy!\n", __FUNCTION__);
		return;
	}
	anchor_body = checked_ptr_cast<BodyDummy>(anchor_obj->getBody());
	if (!anchor_body)
		anchor_body = BodyDummy::create(anchor_obj);

	// create ObjectMeshDynamic responsible for rope visualization
	rope_obj = ObjectMeshDynamic::create();
	rope_obj->setParent(anchor_obj);
	rope_obj->setMaterial(rope_mat.get(), "*");

	// init bag body
	if (bag_node.nullCheck())
	{
		Log::error("%s(): bag node must be not null!\n", __FUNCTION__);
		return;
	}

	bag_body = bag_node->getObjectBodyRigid();
	if (!bag_body)
	{
		Log::error("%s(): node \"%s\" must have BodyRigid!\n", __FUNCTION__, bag_node->getName());
		return;
	}
	bag_body->setFreezable(false);
	bag_body->setFrozen(false);

	// init bag anchor node where rope will be attached to bag
	if (bag_anchor_node.nullCheck())
		bag_anchor = bag_node;
	else
		bag_anchor = bag_anchor_node.get();

	// create rope from crane anchor point to bag anchor point
	setLength(static_cast<float>(
		length(bag_anchor->getWorldPosition() - anchor_obj->getWorldPosition())));

	min_tension_cos = Math::cos(min_tension_angle * Consts::DEG2RAD);
}

void SlingRope::update()
{
	// TODO remove joint visualizer
	if (bag_joint)
		bag_joint->renderVisualizer(vec4(1.f, 1.f, 0.f, 1.f));

	collect_particles_data();
	if (debug_enabled)
		show_debug();
	else
		refresh_mesh();

	if (tension_enabled)
	{
		// adjust rope mass to compensate tension
		if (check_tension())
			rope_body->setMass(tension_mass_multiplier * bag_body->getMass());
		else
			rope_body->setMass(mass);
	}
}

void SlingRope::shutdown()
{
	Visualizer::setEnabled(false);

	// remove all joints
	if (anchor_joint)
	{
		if (rope_body)
			rope_body->removeJoint(anchor_joint);
		anchor_joint.deleteLater();
	}

	if (bag_joint)
	{
		if (rope_body)
			rope_body->removeJoint(bag_joint);
		bag_joint.deleteLater();
	}

	// remove rope
	rope_body.deleteLater();
	base_rope_obj.deleteLater();
	rope_obj.deleteLater();

	particles_position.clear();
	particles_velocity.clear();
}

bool SlingRope::check_tension()
{
	if (!bag_attached || !rope_body || !bag_body)
		return false;

	if (rope_length < min_tension_length)
		return true;

	if (rope_body->getNumContacts())
		return false;

	for (int i = 0; i < particles_position.size() - 2; i++)
	{
		Vec3 p0 = particles_position[i];
		Vec3 p1 = particles_position[i + 1];
		Vec3 p2 = particles_position[i + 2];

		float cos = static_cast<float>(dot((p1 - p0).normalize(), (p2 - p1).normalize()));
		if (cos < min_tension_cos)
			return false;
	}
	return true;
}

void SlingRope::change_num_segments(int num)
{
	// save rope info
	collect_particles_data();

	float current_mass = mass;
	if (rope_body)
	{
		current_mass = rope_body->getMass();
		rope_body.deleteLater();
	}

	// remove anchor joint
	if (anchor_joint)
		anchor_joint.deleteLater();

	// remove bag joint
	if (bag_joint)
		bag_joint.deleteLater();

	num_segments += num;
	if (num_segments < 1)
		num_segments = 1;

	// create new base rope object for BodyRope
	update_internal_mesh();

	// create rope body
	rope_body = BodyRope::create(base_rope_obj);
	rope_body->setRadius(radius);
	rope_body->setMass(current_mass);
	rope_body->setNumIterations(iterations);
	rope_body->setLinearDamping(linear_damping);
	rope_body->setRigidity(rigidity);
	rope_body->setLinearRestitution(linear_restitution);
	rope_body->setAngularRestitution(angular_restitution);

	// restore particles position and velocity
	num_particles = rope_body->getNumParticles();
	int size = min(num_particles, particles_position.size());
	for (int i = 0; i < size; i++)
	{
		rope_body->setParticlePosition(i, particles_position[i]);
		rope_body->setParticleVelocity(i, particles_velocity[i]);
	}

	if (num_particles > 0)
	{
		if (bag_attached && bag_body)
			rope_body->setParticlePosition(0, bag_anchor->getWorldPosition());
		rope_body->setParticlePosition(num_particles - 1, anchor_body->getPosition());
	}

	// create anchor joint
	anchor_joint = JointParticles::create(anchor_body, rope_body, anchor_body->getPosition(),
		vec3(0.01f));
	anchor_joint->setNumIterations(iterations);

	// create bag joint
	if (bag_attached)
		create_bag_joint();
}

void SlingRope::update_internal_mesh()
{
	if (!base_rope_obj)
	{
		base_rope_obj = ObjectMeshDynamic::create();
		base_rope_obj->setCastShadow(false, 0);
		base_rope_obj->setCastWorldShadow(false, 0);
		base_rope_obj->setWorldPosition(anchor_obj->getWorldPosition() + Vec3_down * rope_length);
		base_rope_obj->setMaterial(invisible_base_mat.get(), "*");
	}

	base_rope_obj->clearSurfaces();
	base_rope_obj->clearIndices();
	base_rope_obj->clearVertex();

	base_rope_obj->addVertex(dir1 * radius);
	base_rope_obj->addVertex(dir2 * radius);
	base_rope_obj->addVertex(dir3 * radius);

	base_rope_obj->addIndex(0);
	base_rope_obj->addIndex(1);
	base_rope_obj->addIndex(2);

	for (int i = 0; i < num_segments; i++)
	{
		vec3 up(0.0f, 0.0f, segment_length * (i + 1));

		base_rope_obj->addVertex(dir1 * radius + up);
		base_rope_obj->addVertex(dir2 * radius + up);
		base_rope_obj->addVertex(dir3 * radius + up);

		int index_offset = 3 * i;

		base_rope_obj->addIndex(index_offset + 0);
		base_rope_obj->addIndex(index_offset + 1);
		base_rope_obj->addIndex(index_offset + 3);

		base_rope_obj->addIndex(index_offset + 4);
		base_rope_obj->addIndex(index_offset + 3);
		base_rope_obj->addIndex(index_offset + 1);

		base_rope_obj->addIndex(index_offset + 4);
		base_rope_obj->addIndex(index_offset + 1);
		base_rope_obj->addIndex(index_offset + 2);

		base_rope_obj->addIndex(index_offset + 5);
		base_rope_obj->addIndex(index_offset + 4);
		base_rope_obj->addIndex(index_offset + 2);

		base_rope_obj->addIndex(index_offset + 5);
		base_rope_obj->addIndex(index_offset + 2);
		base_rope_obj->addIndex(index_offset + 0);

		base_rope_obj->addIndex(index_offset + 3);
		base_rope_obj->addIndex(index_offset + 5);
		base_rope_obj->addIndex(index_offset + 0);
	}

	base_rope_obj->addIndex(num_segments * 3);
	base_rope_obj->addIndex(num_segments * 3 + 1);
	base_rope_obj->addIndex(num_segments * 3 + 2);

	base_rope_obj->setMaterial(invisible_base_mat.get(), "*");

	base_rope_obj->updateTangents();
	base_rope_obj->updateBounds();
	base_rope_obj->flushVertex();
	base_rope_obj->flushIndices();
}

void SlingRope::show_debug()
{
	if (rope_obj && rope_obj->getNumVertex())
	{
		rope_obj->clearVertex();
		rope_obj->clearIndices();

		rope_obj->updateTangents();
		rope_obj->updateBounds();
		rope_obj->flushVertex();
		rope_obj->flushIndices();
	}

	if (!rope_body)
		return;

	for (int i = 1; i < num_particles; i++)
	{
		Visualizer::renderVector(particles_position[i - 1], particles_position[i], vec4_red);
		Visualizer::renderSolidSphere(radius, translate(particles_position[i - 1]), vec4_blue);
	}

	if (bag_body)
		Visualizer::renderMessage3D(bag_anchor->getWorldPosition() + Vec3_right, vec3_zero,
			String::ftoa(bag_body->getMass()), vec4_blue, 1, 20);
}

void SlingRope::refresh_mesh()
{
	if (!rope_body)
		return;

	// collect particles transforms for visible rope mesh
	Vector<Mat4> transforms;
	transforms.resize(num_particles);
	for (int i = 1; i < num_particles - 1; i++)
	{
		Vec3 prev = particles_position[i - 1];
		Vec3 curr = particles_position[i];
		Vec3 next = particles_position[i + 1];

		Vec3 forward = (next - curr).normalize();
		Vec3 up = cross(forward, prev - curr).normalize();

		if (i != 1)
		{
			if (dot(up, transforms[i - 1].getAxisZ()) <= 0.0f)
				up = -up;
		}

		Vec3 right = cross(forward, up).normalize();

		Mat4 t;
		t.setColumn3(0, right);
		t.setColumn3(1, forward);
		t.setColumn3(2, up);
		t.setColumn3(3, curr);
		transforms[i] = t;
	}

	if (num_particles > 1)
	{
		Vec3 forward = (particles_position[1] - particles_position[0]).normalize();
		Vec3 up = transforms[1].getAxisZ();

		// TODO ????
		//		if (dot(up, transforms[1].getAxisZ()) < 0)
		//			up = -up;

		Vec3 right = cross(forward, up).normalize();

		transforms[0].setColumn3(0, right);
		transforms[0].setColumn3(1, forward);
		transforms[0].setColumn3(2, up);
		transforms[0].setColumn3(3, particles_position[0]);
	}

	transforms[num_particles - 1] = transforms[0];
	transforms[num_particles - 1].setColumn3(3, particles_position[num_particles - 1]);

	rope_obj->clearVertex();
	rope_obj->clearIndices();

	// vertices
	for (int i = 0; i < num_particles; i++)
	{
		Mat4 t = transforms[i];
		vec3 p(t.getTranslate());

		vec3 p1 = p - vec3(t.getAxisX() * radius);
		vec3 p2 = p + vec3(t.getAxisX() * radius);

		rope_obj->addVertex(rope_obj->getIWorldTransform() * p1);
		rope_obj->addVertex(rope_obj->getIWorldTransform() * p2);

		rope_obj->addVertex(rope_obj->getIWorldTransform() * p1);
		rope_obj->addVertex(rope_obj->getIWorldTransform() * p2);
	}

	// indices
	for (int i = 0; i < num_particles - 1; i++)
	{
		int index_offset = 4 * i + 2;

		rope_obj->addIndex(index_offset + 0);
		rope_obj->addIndex(index_offset + 1);
		rope_obj->addIndex(index_offset + 3);

		rope_obj->addIndex(index_offset + 0);
		rope_obj->addIndex(index_offset + 3);
		rope_obj->addIndex(index_offset + 2);
	}

	rope_obj->updateTangents();
	rope_obj->updateBounds();
	rope_obj->flushVertex();
	rope_obj->flushIndices();
}

bool SlingRope::create_bag_joint()
{
	if (!rope_body || !bag_body)
		return false;

	if (bag_joint)
		bag_joint.deleteLater();

	bag_joint = JointParticles::create(bag_body, rope_body, bag_anchor->getWorldPosition(),
		vec3(0.01f));
	bag_joint->setNumIterations(iterations);
	bag_joint->setCollision(1);
	bag_joint->setLinearSoftness(joint_linear_softness);
	bag_joint->setAngularSoftness(joint_angular_softness);
	bag_joint->setLinearRestitution(joint_linear_restitution);
	bag_joint->setAngularRestitution(joint_angular_restitution);
	return true;
}

void SlingRope::collect_particles_data()
{
	if (!rope_body)
		num_particles = 0;
	else
		num_particles = rope_body->getNumParticles();

	particles_position.resize(num_particles);
	particles_velocity.resize(num_particles);

	if (num_particles < 1)
		return;

	for (int i = 0; i < num_particles; i++)
	{
		particles_position[i] = rope_body->getParticlePosition(i);
		particles_velocity[i] = rope_body->getParticleVelocity(i);
	}

	if (bag_attached && bag_body)
		particles_position[0] = bag_anchor->getWorldPosition();
}

```

## SoundAmbient.cpp

```cpp
#include "SoundAmbient.h"

REGISTER_COMPONENT(SoundAmbient)


using namespace Unigine;

void SoundAmbient::init()
{
	sample_description_window.createWindow();

	String file_path = sound_file.get();
	if (file_path.empty())
	{
		Log::error("SoundSourceController::init(): Sound File path is empty\n");
		return;
	}

	ambient_source = AmbientSource::create(file_path);
	if (!ambient_source)
	{
		Log::error("SoundAmbient::init(): Sound File is not valid\n");
		return;
	}

	ambient_source->setLoop(1);
	ambient_source->setGain(1.f);
	ambient_source->play();

	// create settings UI
	auto parameters = sample_description_window.getParameterGroupBox();

	WidgetButtonPtr button_play = WidgetButton::create("Play");
	WidgetButtonPtr button_stop = WidgetButton::create("Stop");

	button_play->getEventClicked().connect(*this, [this]() { ambient_source->play(); });
	button_stop->getEventClicked().connect(*this, [this]() { ambient_source->stop(); });

	WidgetHBoxPtr hbox_buttons = WidgetHBox::create(10, 0);
	hbox_buttons->addChild(button_play);
	hbox_buttons->addChild(button_stop);
	parameters->addChild(hbox_buttons, Gui::ALIGN_LEFT);

	sample_description_window.addBoolParameter("Loop:", "Loop", ambient_source->getLoop(),
		[this](bool activate) { ambient_source->setLoop(activate ? 1 : 0); });

	sample_description_window.addBoolParameter("Stream:", "Stream", is_stream,
		[this](bool active) { change_souce_type(); });

	sample_description_window.addFloatParameter("Gain:", "Gain", ambient_source->getGain(), 0.0f,
		1.0f, [this](float val) { ambient_source->setGain(val); });

	sample_description_window.addFloatParameter("Pitch:", "Pitch", ambient_source->getPitch(), 0.1f,
		5.0f, [this](float val) { ambient_source->setPitch(val); });
}

void SoundAmbient::shutdown()
{
	ambient_source.deleteLater();
	sample_description_window.shutdown();
}

void SoundAmbient::change_souce_type()
{
	int is_loop = ambient_source->getLoop();
	bool is_playing = ambient_source->isPlaying();
	float gain = ambient_source->getGain();
	float pitch = ambient_source->getPitch();

	ambient_source.deleteLater();

	is_stream = !is_stream;
	if (is_stream)
		ambient_source = AmbientSource::create(sound_file, 1);
	else
		ambient_source = AmbientSource::create(sound_file, 0);

	ambient_source->setLoop(is_loop);
	ambient_source->setGain(gain);
	ambient_source->setPitch(pitch);

	if (is_playing)
		ambient_source->play();
	else
		ambient_source->stop();
}

```

## SoundReverbController.cpp

```cpp
#include "SoundReverbController.h"

#include <UnigineVisualizer.h>

REGISTER_COMPONENT(SoundReverbController)

using namespace Unigine;
using namespace Math;


void SoundReverbController::init()
{
	sound_source = checked_ptr_cast<SoundSource>(sound_node.get());
	if (!sound_source)
		Log::error("SoundReverbController::init(): Sound Source node must be SoundeSource type\n");

	sound_reverb = SoundReverb::create(vec3(20.0f, 20.0f, 20.0f));
	sound_reverb->setWorldTransform(Mat4_identity);
	sound_reverb->setThreshold(vec3(10.0f, 10.0f, 10.0f));

	update_reverb_settings();

	// create settings UI
	sample_description_window.createWindow();

	sample_description_window.addFloatParameter("Gain:", "Gain", reverb_power, 0.0f, 1.0f,
		[this](float val) {
			reverb_power = val;
			update_reverb_settings();
		});

	Visualizer::setEnabled(true);
}

void SoundReverbController::update()
{
	if (!sound_reverb || !sound_source)
		return;

	sound_reverb->renderVisualizer();
	sound_source->renderVisualizer();
}

void SoundReverbController::shutdown()
{
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

void SoundReverbController::update_reverb_settings()
{
	sound_reverb->setDensity(clamp(1.0f - reverb_power, 0.0f, 1.0f));
	sound_reverb->setDiffusion(clamp(1.0f - reverb_power, 0.0f, 1.0f));
	sound_reverb->setDecayTime(clamp(0.1f + 19.9f * reverb_power, 0.1f, 20.0f));
	sound_reverb->setReflectionGain(clamp(3.16f * reverb_power, 0.0f, 2.16f));
	sound_reverb->setLateReverbGain(clamp(10.0f * reverb_power, 0.0f, 10.0f));
}

```

## SoundSourceController.cpp

```cpp
#include "SoundSourceController.h"

#include <UnigineVisualizer.h>

REGISTER_COMPONENT(SoundSourceController)

using namespace Unigine;


void SoundSourceController::init()
{
	sample_description_window.createWindow();

	String file_path = sound_file.get();
	if (file_path.empty())
	{
		Log::error("SoundSourceController::init(): Sound File path is empty\n");
		return;
	}

	sound_source = SoundSource::create(file_path.get());
	if (!sound_source)
	{
		Log::error("SoundSourceController::init(): Sound File is not valid\n");
		return;
	}

	sound_source->setMinDistance(5.0f);
	sound_source->setMaxDistance(50.0f);
	sound_source->setLoop(1);
	sound_source->play();

	// create settings UI
	auto parameters = sample_description_window.getParameterGroupBox();

	WidgetButtonPtr button_play = WidgetButton::create("Play");
	WidgetButtonPtr button_stop = WidgetButton::create("Stop");

	button_play->getEventClicked().connect(*this, [this]() { sound_source->play(); });
	button_stop->getEventClicked().connect(*this, [this]() { sound_source->stop(); });

	WidgetHBoxPtr hbox_buttons = WidgetHBox::create(10, 0);
	hbox_buttons->addChild(button_play);
	hbox_buttons->addChild(button_stop);
	parameters->addChild(hbox_buttons, Gui::ALIGN_LEFT);

	sample_description_window.addBoolParameter("Loop:", "Loop", sound_source->getLoop(),
		[this](bool activate) { sound_source->setLoop(activate ? 1 : 0); });

	sample_description_window.addBoolParameter("Stream:", "Stream", sound_source->isStream(),
		[this](bool active) { sound_source->setStream(active); });

	sample_description_window.addFloatParameter("Gain:", "Gain", sound_source->getGain(), 0.0f,
		1.0f, [this](float val) { sound_source->setGain(val); });

	sample_description_window.addFloatParameter("Pitch:", "Pitch", sound_source->getPitch(), 0.1f,
		5.0f, [this](float val) { sound_source->setPitch(val); });

	Visualizer::setEnabled(true);
}

void SoundSourceController::update()
{
	if (!sound_source)
		return;

	sound_source->renderVisualizer();
}

void SoundSourceController::shutdown()
{
	Visualizer::setEnabled(false);
	sample_description_window.shutdown();
}

```

## Spawner.cpp

```cpp
#include "Spawner.h"
#include "UnigineComponentSystem.h"
#include <UnigineGame.h>

REGISTER_COMPONENT(Spawner);

using namespace Unigine;

void Spawner::init()
{
	last_spawn_time = Time::getSeconds();
	started = false;
}

void Spawner::update()
{
	if (!start_with_cooldown && !started)
	{
		spawn();
		started = true;
		return;
	}

	auto time = Time::getSeconds();
	if (time - last_spawn_time < spawn_interval)
		return;

	spawn();
}

void Spawner::spawn()
{
	last_spawn_time = Time::getSeconds();

	auto spawn_node = World::loadNode(spawn_node_path);
	if (!spawn_node)
		return;

	auto spread = spawn_spread.get() * (Math::randDirection() * 2 - Math::vec3_one);
	spawn_node->setWorldPosition(node->getWorldPosition() + Math::Vec3(spread));
}

```

## SpectatorController.cpp

```cpp
#include "SpectatorController.h"
#include <UnigineGame.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(SpectatorController)

void SpectatorController::init()
{
	//Create physics shape
	p_shape_sphere = ShapeSphere::create(collision_radius.get());
	p_shape_sphere->setContinuous(0);

	//Assign inputs keys
	_forward_key = Input::getKeyByName(forward_key.get());
	_backward_key = Input::getKeyByName(backward_key.get());
	_right_key = Input::getKeyByName(right_key.get());
	_left_key = Input::getKeyByName(left_key.get());
	_up_key = Input::getKeyByName(up_key.get());
	_down_key = Input::getKeyByName(down_key.get());
	_turn_up_key = Input::getKeyByName(turn_up_key.get());
	_turn_down_key = Input::getKeyByName(turn_down_key.get());
	_turn_left_key = Input::getKeyByName(turn_left_key.get());
	_turn_right_key = Input::getKeyByName(turn_right_key.get());
	_accelerate_key = Input::getKeyByName(accelerate_key.get());

	p_player = checked_ptr_cast<Player>(node);

	on_transform_changed(); //get start parameters of node
}

void SpectatorController::update()
{
	if (transform != node->getTransform()) // if somebody change our position outside -> update all internal params.
		on_transform_changed(); 

	updateControls();
	flushTransform();

	transform = node->getTransform();
}

void SpectatorController::shutdown()
{
	p_shape_sphere.deleteLater(); // delete the shape we created
}

// UpdateControls handles user input processing and triggers movement updates.
// This method reads control states (mouse and buttons) and passes 
// the relevant data to UpdateMovement for velocity computation.

void SpectatorController::updateControls()
{
	vec3 up = p_player->getUp();

	vec3 impulse = vec3_zero;

	vec3 tangent, binormal;
	orthoBasis(p_player->getUp(), tangent, binormal);

	if (is_controlled.get() && !Console::isActive())
	{
		if (Input::isMouseCursorHide())
		{ 
			phi_angle += Input::getMouseDeltaPosition().x * mouse_sensitivity.get();
			theta_angle += Input::getMouseDeltaPosition().y * mouse_sensitivity.get();
		}

		theta_angle += turning * Game::getIFps() * (Input::isKeyPressed(_turn_down_key) - Input::isKeyPressed(_turn_up_key));
		theta_angle = clamp(theta_angle, min_theta_angle, max_theta_angle);

		phi_angle += turning * Game::getIFps() * (Input::isKeyPressed(_turn_right_key) - Input::isKeyPressed(_turn_left_key));

		vec3 x = (quat(up, -phi_angle) * quat(tangent, -theta_angle)) * binormal;
		vec3 y = normalizeValid(cross(up, x));
		vec3 z = normalizeValid(cross(x, y));

		direction = x;

		impulse += x * float(Input::isKeyPressed(_forward_key) - Input::isKeyPressed(_backward_key));
		impulse += y * float(Input::isKeyPressed(_left_key) - Input::isKeyPressed(_right_key));
		impulse += z * float(Input::isKeyPressed(_up_key) - Input::isKeyPressed(_down_key));

		impulse.normalizeValid();

		impulse *= Input::isKeyPressed(_accelerate_key) ? max_velocity.get() : min_velocity.get();
	}

	float time = Game::getIFps();

	float target_velocity = length(impulse);

	Vec3 player_velocity = Vec3(p_player->getVelocity());

	// Use do-while to ensure at least one update is processed,
	// even when the remaining time is very small (e.g., at high FPS).
	do
	{
		// Clamp the simulation step to a maximum fixed time interval (PLAYER_SPECTATOR_IFPS).
		// This prevents instability or large jumps in movement and collisions when frame time is high (e.g., during frame drops).
		float ifps = min(time, PLAYER_SPECTATOR_IFPS);
		time -= ifps;
		update_movement(impulse, ifps, target_velocity);
	} while (time > Consts::EPS);
}


// Applies the final transformation matrix to the scene Node based on 
// the updated movement and orientation values computed in the previous steps.
void SpectatorController::flushTransform()
{
	vec3 up = p_player->getUp();

	if (last_position != position || last_direction != direction || last_up != up)
	{
		node->setWorldTransform(setTo(position, position + Vec3(direction), up));
		on_transform_changed(); // update all internal params

		last_position = position;
		last_direction = direction;
		last_up = up;
	}
}

// Syncs this component's internal state with the transform of the node.
void SpectatorController::on_transform_changed()
{
	vec3 up = p_player->getUp();

	vec3 tangent, binormal;
	orthoBasis(up, tangent, binormal);

	position = node->getWorldTransform().getColumn3(3);
	direction = normalizeValid(vec3(-node->getWorldTransform().getColumn3(2)));

	phi_angle = Math::atan2(dot(direction, tangent), dot(direction, binormal)) * Consts::RAD2DEG;
	theta_angle = Math::acos(clamp(dot(direction, up), -1.0f, 1.0f)) * Consts::RAD2DEG - 90.0f;
	theta_angle = clamp(theta_angle, min_theta_angle, max_theta_angle);
	direction = (quat(up, -phi_angle) * quat(tangent, -theta_angle)) * binormal;

	last_position = position;
	last_direction = direction;
	last_up = up;
}

// Calculates the player's current velocity and adjusts camera position 
// if collisions are detected. Called after input is processed in UpdateControls.
void SpectatorController::update_movement(const vec3& impulse, float ifps, float target_velocity)
{
	float old_velocity = length(p_player->getVelocity());

	p_player->setVelocity(p_player->getVelocity() + impulse * acceleration.get() * ifps);

	float current_velocity = length(p_player->getVelocity());
	if (target_velocity < Consts::EPS || current_velocity > target_velocity)
		p_player->setVelocity(p_player->getVelocity() * Math::exp(-damping * ifps));

	current_velocity = length(p_player->getVelocity());
	if (current_velocity > old_velocity && current_velocity > target_velocity)
		p_player->setVelocity(p_player->getVelocity() * target_velocity / current_velocity);

	if (current_velocity < Consts::EPS)
		p_player->setVelocity(vec3_zero);

	position += Vec3(p_player->getVelocity() * ifps);

	contacts.clear();

	if (p_shape_sphere->isEnabled() && is_collided.get())
	{
		for (int i = 0; i < PLAYER_SPECTATOR_COLLISIONS; i++)
		{
			p_shape_sphere->setCenter(position);
			p_shape_sphere->getCollision(contacts, ifps);
			if (contacts.size() == 0)
				break;

			// Calculate the inverse of the number of contacts to evenly distribute the total push-out
			// This prevents applying the full depth for every contact, which would overcompensate the position
			float inum_contacts = 1.0f / Math::itof(contacts.size());
			for (int j = 0; j < contacts.size(); j++)
			{
				const ShapeContactPtr c = contacts[j];

				// Push the player out along the contact normal, scaled by penetration depth and evenly divided by contact count
				position += Vec3(c->getNormal() * (c->getDepth() * inum_contacts));

				// Remove the velocity component that's directed into the contact surface
				// This prevents the player from continuing to move into the object
				p_player->setVelocity(p_player->getVelocity() - c->getNormal() * dot(p_player->getVelocity(), c->getNormal()));
			}
		}
	}

	p_shape_sphere->setCenter(position);
}

// These methods are used to control the player's view direction 
// externally from this class. They provide access to and allow manipulation of 
// the camera's orientation

void SpectatorController::setPhiAngle(float newAngle)
{
	newAngle = newAngle - phi_angle;
	direction = quat(p_player->getUp(), newAngle) * direction;
	phi_angle += newAngle;

	flushTransform();
}

void SpectatorController::setThetaAngle(float newAngle)
{
	newAngle = clamp(newAngle, min_theta_angle.get(), max_theta_angle.get()) - theta_angle;
	direction = quat(cross(p_player->getUp(), direction), newAngle) * direction;
	theta_angle += newAngle;

	flushTransform();
}

void SpectatorController::setViewDirection(const vec3 &newView)
{
	direction = normalizeValid(newView);

	// ortho basis
	vec3 tangent, binormal;
	orthoBasis(p_player->getUp(), tangent, binormal);

	// decompose view direction
	phi_angle = Math::atan2(dot(direction, tangent), dot(direction, binormal)) * Consts::RAD2DEG;
	theta_angle = Math::acos(clamp(dot(direction, p_player->getUp()), -1.0f, 1.0f)) * Consts::RAD2DEG - 90.0f;
	theta_angle = clamp(theta_angle, min_theta_angle.get(), max_theta_angle.get());

	flushTransform();
}

// This block contains methods for querying detailed information about collision contacts.
// These accessors provide data such as contact points, normals, depth of penetration, and 
// the involved objects and surfaces. Useful for physics responses.

const ShapeContactPtr SpectatorController::getContact(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContact(): bad contact number");
	return contacts[num];
}

float SpectatorController::getContactDepth(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactDepth(): bad contact number");
	return contacts[num]->getDepth();
}

vec3 SpectatorController::getContactNormal(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactNormal(): bad contact number");
	return contacts[num]->getNormal();
}

ObjectPtr SpectatorController::getContactObject(int num)
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactObject(): bad contact number");
	return contacts[num]->getObject();
}

Vec3 SpectatorController::getContactPoint(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactPoint(): bad contact number");
	return contacts[num]->getPoint();
}

ShapePtr SpectatorController::getContactShape(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactShape(): bad contact number");
	return contacts[num]->getShape0();
}

int SpectatorController::getContactSurface(int num) const
{
	assert(num >= 0 && num < getNumContacts() && "PlayerSpectator::getContactSurface(): bad contact number");
	return contacts[num]->getSurface();
}




```

## SpectatorControllerSample.cpp

```cpp
#include "SpectatorControllerSample.h"
#include "SpectatorController.h"
#include <UnigineGame.h>


REGISTER_COMPONENT(SpectatorControllerSample)

using namespace Unigine;

void SpectatorControllerSample::init()
{
	spectator = getComponentInChildren<SpectatorController>(Game::getPlayer());

	mouse_handle_at_init = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	is_controlled = spectator->is_controlled > 0;
	is_collided = spectator->is_collided > 0;

	current_mouse_sensetivity = spectator->mouse_sensitivity;
	current_turning = spectator->turning;
	current_velocity = spectator->min_velocity;
	current_sprint_velocity = spectator->max_velocity;

	description_window.createWindow();

	description_window.addFloatParameter("Mouse sensetivity",
		"Mouse sensetivity", 
		current_mouse_sensetivity, 
		min_mouse_sensetivity, 
		max_mouse_sensetivity, 
		[this](float value) {
			current_mouse_sensetivity = value;
			spectator->mouse_sensitivity = current_mouse_sensetivity;
		});

	description_window.addFloatParameter("Turning speed",
		"Turning speed",
		current_turning,
		min_turning,
		max_turning,
		[this](float value) {
			current_turning = value;
			spectator->turning = current_turning;
		});

	description_window.addFloatParameter("Velocity",
		"Velocity",
		current_velocity,
		min_velocity,
		max_velocity,
		[this](float value) {
			current_velocity = value;
			spectator->min_velocity = current_velocity;
		});

	description_window.addFloatParameter("Sprint velocity",
		"Sprint velocity",
		current_sprint_velocity,
		min_sprint_velocity,
		max_sprint_velocity,
		[this](float value) {
			current_sprint_velocity = value;
			spectator->max_velocity = current_sprint_velocity;
		});

	WidgetGroupBoxPtr parameters = description_window.getParameterGroupBox();
	
	WidgetCheckBoxPtr controlls_checkbox = WidgetCheckBox::create("Set camera receive inputs");
	parameters->addChild(controlls_checkbox, Gui::ALIGN_LEFT);
	controlls_checkbox->setChecked(is_controlled);

	controlls_checkbox->getEventClicked().connect(*this, [this, controlls_checkbox]() 
	{
		is_controlled = controlls_checkbox->isChecked();
		spectator->is_controlled = is_controlled;
	});

	WidgetCheckBoxPtr collisions_checkbox = WidgetCheckBox::create("Set camera collision");
	parameters->addChild(collisions_checkbox, Gui::ALIGN_LEFT);
	collisions_checkbox->setChecked(is_collided);

	collisions_checkbox->getEventClicked().connect(*this, [this, collisions_checkbox]() 
	{
		is_collided = collisions_checkbox->isChecked();
		spectator->is_collided = is_collided;
	});
}

void SpectatorControllerSample::shutdown()
{
	Input::setMouseHandle(mouse_handle_at_init);

	description_window.shutdown();
}
```

## SpinBox.cpp

```cpp
#include "SpinBox.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(SpinBox);

using namespace Unigine;
using namespace Math;

void SpinBox::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_editline = WidgetEditLine::create(gui, "0");
	widget_editline->setPosition(position.get().x, position.get().y);
	widget_editline->setFontOutline(1);

	gui->addChild(widget_editline, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_spinbox = WidgetSpinBox::create(gui);
	widget_spinbox->setOrder(widget_editline->getOrder() + 1);
	widget_editline->addAttach(widget_spinbox);

	gui->addChild(widget_spinbox, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_spinbox->getEventChanged().connect(*this, [this]() {
		String msg = String("SpinBox: ") + String::itoa(widget_spinbox->getValue());
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void SpinBox::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_editline);
		gui->removeChild(widget_spinbox);

		widget_editline.deleteLater();
		widget_spinbox.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## Spinner.cpp

```cpp
#include "Spinner.h"

#include "Projectile.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(Spinner);

using namespace Unigine;
using namespace Math;

void Spinner::init()
{
	// get current material (from the first surface)
	ObjectPtr obj = checked_ptr_cast<Object>(node);
	if (obj && obj->getNumSurfaces() > 0)
		material = obj->getMaterialInherit(0);

	// init randoms
	time_to_spawn = Game::getRandomFloat(min_spawn_delay, max_spawn_delay);
	color_offset = Game::getRandomFloat(0, 360.0f);
	start_turn_speed = turn_speed;
}

void Spinner::update()
{
	// rotate spinner
	float ifps = Game::getIFps();
	turn_speed = turn_speed + acceleration * ifps;
	node->setRotation(node->getRotation() * quat(0, 0, turn_speed * ifps));

	// change color
	int id = material->findParameter("albedo_color");
	if (id != -1)
	{
		float hue = Math::mod(Game::getTime() * 60.0f + color_offset, 360.0f);
		material->setParameterFloat4(id, vec4(hsv2rgb(hue, 1, 1), 1.0f));
	}

	// spawn projectiles
	time_to_spawn -= ifps;
	if (time_to_spawn < 0 && spawn_node.get())
	{
		// reset timer and increase difficulty
		time_to_spawn = Game::getRandomFloat(min_spawn_delay, max_spawn_delay)
			/ (turn_speed / start_turn_speed);

		// create node
		NodePtr spawned = spawn_node.get()->clone();
		spawned->setEnabled(1);
		spawned->setWorldTransform(node->getWorldTransform());

		// create component
		Projectile *proj_component = addComponent<Projectile>(spawned);

		// there are three ways to change variables inside another component:
		// 1) direct change via component (fast, easy)
		proj_component->speed = Game::getRandomFloat(proj_component->speed * 0.5f,
			proj_component->speed * 1.5f);

		// 2) change via property of the node (more slow, more awkward)
		for (int i = 0; i < spawned->getNumProperties(); i++)
		{
			PropertyPtr prop = spawned->getProperty(i);
			if (prop && (!strcmp(prop->getName(), "Projectile") || prop->isParent("Projectile")))
				prop->getParameterPtr("damage")->setValueInt(Game::getRandomInt(75, 100));
		}

		// 3) change via property of the component
		PropertyPtr proj_property = proj_component->getProperty();
		proj_property->getParameterPtr("lifetime")
			->setValueFloat(Game::getRandomFloat(5.0f, 10.0f));

		// call public method of another component
		proj_component->setMaterial(material);
	}
}

// H - [0, 360), S,V - [0, 1]
vec3 Spinner::hsv2rgb(float h, float s, float v)
{
	float p, q, t, fract;

	h /= 60.0f;
	fract = h - Math::floor(h);

	p = v * (1.0f - s);
	q = v * (1.0f - s * fract);
	t = v * (1.0f - s * (1.0f - fract));

	if (0.0f <= h && h < 1.0f) return vec3(v, t, p);
	else if (1.0f <= h && h < 2.0f) return vec3(q, v, p);
	else if (2.0f <= h && h < 3.0f) return vec3(p, v, t);
	else if (3.0f <= h && h < 4.0f) return vec3(p, q, v);
	else if (4.0f <= h && h < 5.0f) return vec3(t, p, v);
	else if (5.0f <= h && h < 6.0f) return vec3(v, p, q);
	else return vec3(0, 0, 0);
}

```

## Spline.cpp

```cpp
#include "Spline.h"

using namespace Unigine;
using namespace Math;

Vec3 getBezierPoint(const Vec3 &p0, const Vec3 &p1, const Vec3 &p2, const Vec3 &p3, float k0)
{
	float k1 = 1.0f - k0;
	float k00 = k0 * k0;
	float k11 = k1 * k1;
	return p0 * (k11 * k1) + p1 * (3.0f * k11 * k0) + p2 * (3.0f * k00 * k1) + p3 * (k00 * k0);
}

void getAutoHandles(const Vec3 &prev, const Vec3 &current, const Vec3 &next, Vec3 &left, Vec3 &right)
{
	left = (prev - current) / 3.0f;
	right = (next - current) / 3.0f;
	left = (left - right) / 2.0f;
	right = -left;
}

void SplineNode::init(const NodePtr &container, const ObjectMeshStaticPtr &reference)
{
	for (int i = 0; i < container->getNumChildren(); i++)
	{
		nodes.append(container->getChild(i));
		nodes_pos.append();
		nodes_rot.append();
	}
}

void SplineNode::setSubdivLevel(int in_level)
{
	subdiv = in_level;
}

int SplineNode::getSubdivLevel() const
{
	return subdiv;
}

void SplineNode::setOffset(float in_offset)
{
	offset = in_offset;
}

float SplineNode::getOffset() const
{
	return offset;
}

void SplineNode::setSpacing(float in_spacing)
{
	spacing = in_spacing;
}

float SplineNode::getSpacing() const
{
	return spacing;
}

void SplineNode::update()
{
	mesh_transforms.clear();
	// get node positions and rotations
	for (int i = 0; i < nodes.size(); i++)
	{
		NodePtr& n = nodes[i];
		nodes_pos[i] = n->getPosition();
		nodes_rot[i] = n->getRotation();
	}

	// calculate spline
	int obj_num = 0;
	float current_spline_length = 0;
	float dist = spacing - Math::mod(offset, spacing);
	float real_spacing = total_obj_num == 0 ? spacing : spline_length / total_obj_num;
	
	for (int i = 0; i < nodes.size(); i++)
	{
		int prev_i = (i - 1 < 0 ? (nodes.size() - 1) : (i - 1));
		int cur_i = i;
		int next_i = (i + 1 < nodes.size() ? (i + 1) : 0);
		int next_next_i = ((i + 2) < nodes.size() ? (i + 2) : ((i + 2) % nodes.size()));

		const Vec3 &prev_point = nodes_pos[prev_i];
		const Vec3 &cur_point = nodes_pos[cur_i];
		const Vec3 &next_point = nodes_pos[next_i];
		const Vec3 &next_next_point = nodes_pos[next_next_i];

		Vec3 tmp, handle_right, handle_left;
		getAutoHandles(prev_point, cur_point, next_point, tmp, handle_right);
		getAutoHandles(cur_point, next_point, next_next_point, handle_left, tmp);

		Vec3 last_p = cur_point;
		for (int z = 0; z <= subdiv; z++)
		{
			float t = float(z + 1) / (subdiv + 1);
			Vec3 p = getBezierPoint(cur_point, cur_point + handle_right, handle_left + next_point, next_point, t);

			// update cluster
			float len = static_cast <float>(length(p - last_p));
			if (dist + len >= real_spacing) {
				int count = int(Math::floor((dist + len) / real_spacing));
				for (int j = 1; j <= count; j++) {
					float percent = (j * real_spacing - dist) / len;

					// add transform
					mesh_transforms.append(
						translate(lerp(last_p, p, percent)) *
						Mat4(rotate(slerp(nodes_rot[cur_i], nodes_rot[next_i], t + percent / (subdiv + 1)))));
					Mat4 &cur_t = mesh_transforms.last();
					cur_t = parent_world_transform * (cur_t * Mat4(rotateY(90.0f)));
					obj_num++;
				}
				dist = Math::mod((dist + len), real_spacing);
			}
			else
				dist += len;

			current_spline_length += len;
			last_p = p;
		}
	}
	spline_length = current_spline_length;
	total_obj_num = total_obj_num == 0 ? obj_num : total_obj_num;
}

float SplineNode::getLength() const
{
	return spline_length;
}
```

## SplineGraphSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineMathLibCommon.h>
#include <UnigineSplineGraph.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

namespace
{
	vec3 random_vec3(const vec3 &from, const vec3 &to)
	{
		return {
			Game::getRandomFloat(from.x, to.x),
			Game::getRandomFloat(from.y, to.y),
			Game::getRandomFloat(from.z, to.z)
		};
	}

	vec3 random_vec3(const vec3 &size)
	{
		return random_vec3(- size * .5f, size * .5f);
	}
}

class SplineGraphSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(SplineGraphSample, ComponentBase)
	COMPONENT_INIT(init)
	COMPONENT_UPDATE(update)
	COMPONENT_SHUTDOWN(shutdown)

	PROP_PARAM(File, mesh_file);

private:
	void init()
	{
		Unigine::String mesh_path = mesh_file.get();
		if (mesh_path.size() <= 0)
		{
			Unigine::Log::error("SplineGraphSample::init(): Mesh File param is empty!\n");
		}

		spline_graph = SplineGraph::create();
		box = ObjectMeshStatic::create();
		box->setMeshPath(mesh_path);

		generate_graph();

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
	}

	void update()
	{
		render_graph();
		move_box_along_graph();
	}

	void shutdown()
	{
		Visualizer::setEnabled(visualizer_enabled);
	}

	void generate_graph()
	{
		int num_points = 4;
		vec3 size = { 3.f, 3.f, 2.f };
		Vec3 offset { 0.f, 3.f, size.z * .5f + 1.f };

		Game::setSeed(int(Time::get()));

		for (int i = 0; i < num_points; i += 1)
			spline_graph->addPoint(Vec3(::random_vec3(size)) + offset);

		for (int i = 0; i < num_points; i += 1)
		{
			int index_window[4] = {
				(num_points + (i - 1) % num_points) % num_points,
				i,
				(i + 1) % num_points,
				(i + 2) % num_points,
			};

			vec3 from_tangent = vec3(normalize(spline_graph->getPoint(index_window[2]) - spline_graph->getPoint(index_window[0])));
			vec3 to_tangent = - vec3(normalize(spline_graph->getPoint(index_window[3]) - spline_graph->getPoint(index_window[1])));

			spline_graph->addSegment(index_window[1], from_tangent, vec3_up, index_window[2], to_tangent, vec3_up);
		}
	}

	void render_graph()
	{
		const int num_segments = 32;
		for (int i = 0; i < spline_graph->getNumPoints(); i++)
		{
			Vec3 p = Vec3(spline_graph->getPoint(i));
			Visualizer::renderPoint3D(p, 0.05f, vec4_white);
		}

		for (int i = 0; i < spline_graph->getNumSegments(); i++)
		{
			vec4 tangent_color = vec4(vec3(89, 204, 249) / 255.f, 1.f);

			Vec3 start_point	=	Vec3(spline_graph->getSegmentStartPoint(i));
			Vec3 start_tangent	=	Vec3(spline_graph->getSegmentStartTangent(i));
			Vec3 end_point		=	Vec3(spline_graph->getSegmentEndPoint(i));
			Vec3 end_tangent	=	Vec3(spline_graph->getSegmentEndTangent(i));

			Visualizer::renderVector(start_point, start_point + start_tangent, tangent_color, 0.15f);
			Visualizer::renderVector(end_point, end_point + end_tangent, tangent_color, 0.15f);

			for (int j = 0; j < num_segments; j++)
			{
				Vec3 p0 = Vec3(spline_graph->calcSegmentPoint(i, float(j) / num_segments));
				Vec3 p1 = Vec3(spline_graph->calcSegmentPoint(i, float(j + 1) / num_segments));
				Visualizer::renderLine3D(p0, p1, vec4_white);
			}
		}
	}

	void move_box_along_graph()
	{
		float time = Game::getTime();

		float t = time - Math::floor(time / spline_graph->getNumSegments()) * spline_graph->getNumSegments();
		int segment_id = int(t);
		t -= float(segment_id);

		Vec3 p = Vec3(spline_graph->calcSegmentPoint(segment_id, t));
		vec3 direction = spline_graph->calcSegmentTangent(segment_id, t);
		vec3 up = spline_graph->calcSegmentUpVector(segment_id, t);

		box->setWorldPosition(p);
		box->setWorldDirection(direction, up);
	}

	// ========================================================================================

	bool visualizer_enabled = false;
	SplineGraphPtr spline_graph;
	ObjectMeshStaticPtr box;
};

REGISTER_COMPONENT(SplineGraphSample);

```

## SplitScreenTexture.cpp

```cpp
#include "SplitScreenTexture.h"

#include <UnigineGame.h>
#include <UnigineGui.h>
#include <UniginePlayers.h>
#include <UnigineTextures.h>
#include <UnigineWindowManager.h>

REGISTER_COMPONENT(SplitScreenTexture);

using namespace Unigine;
using namespace Math;

void SplitScreenTexture::init()
{
	init_gui();
	cached_camera_top = checked_ptr_cast<Player>(camera_top.get())->getCamera();
	cached_camera_bottom = checked_ptr_cast<Player>(camera_bottom.get())->getCamera();

	texture_top = Texture::create();
	create_texture_2D(*texture_top);
	texture_bottom = Texture::create();
	create_texture_2D(*texture_bottom);
	viewport_top = Viewport::create();
	viewport_bottom = Viewport::create();
	bind_texture(display_player1.get(), texture_top);
	bind_texture(display_player2.get(), texture_bottom);
}

void SplitScreenTexture::init_gui()
{
	ivec2 window_size = WindowManager::getMainWindow()->getSize();
	current_width = window_size.x;
	current_height = window_size.y;
	auto gui = Gui::getCurrent();
	Render::setEnabled(false);
	widget_top = WidgetSprite::create(gui);
	widget_bottom = WidgetSprite::create(gui);
	lay = WidgetVBox::create();
	gui->addChild(lay, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);
	lay->addChild(widget_top);
	lay->addChild(widget_bottom);
	wasd_label = setup_label(gui, "Use WASD to move");
	arrows_label = setup_label(gui, "Use arrows to move");
	update_labels_pos();
}

WidgetLabelPtr SplitScreenTexture::setup_label(Unigine::GuiPtr gui, const char *text)
{
	auto label = WidgetLabel::create(gui, text);
	label->setFontColor(vec4(1.f, 1.f, 1.f, 1.f));
	label->setFontSize(24);
	gui->addChild(label, Gui::ALIGN_OVERLAP);
	label->arrange();
	return label;
}

void SplitScreenTexture::update_labels_pos()
{
	wasd_label->setPosition(current_width - 30 - wasd_label->getWidth(), 10);
	arrows_label->setPosition(current_width - 30 - arrows_label->getWidth(),
	 	current_height / 2 + 10);
}

void SplitScreenTexture::bind_texture(const NodePtr &tv_display, const TexturePtr &texture)
{
	auto obj = checked_ptr_cast<ObjectMeshStatic>(tv_display);
	auto mat = obj->getMaterial(0);
	mat = mat->inherit();
	mat->setTexture(mat->findTexture("albedo"), texture);
	mat->setParameterFloat4("uv_transform", vec4(-1.f, Render::isFlipped() ? 1.f : -1.f, 0.f, 0.f));
	obj->setMaterial(mat, 0);
}

void SplitScreenTexture::create_texture_2D(Texture &texture)
{
	texture.create2D(current_width, current_height / 2, Texture::FORMAT_RG11B10F,
		Texture::SAMPLER_FILTER_LINEAR | Texture::SAMPLER_ANISOTROPY_16
			| Texture::FORMAT_USAGE_RENDER);
}

void SplitScreenTexture::update()
{
	update_screen_size();
	viewport_top->renderTexture2D(cached_camera_top, texture_top);
	viewport_bottom->renderTexture2D(cached_camera_bottom, texture_bottom);
	widget_top->setRender(texture_top, !Render::isFlipped());
	widget_bottom->setRender(texture_bottom, !Render::isFlipped());
}

void SplitScreenTexture::update_screen_size()
{
	ivec2 window_size = WindowManager::getMainWindow()->getSize();
	int app_width = window_size.x;
	bool need_update = false;
	if (app_width != current_width)
	{
		current_width = app_width;
		need_update = true;
	}
	int app_height = window_size.y;
	if (app_height != current_height)
	{
		need_update = true;
		current_height = app_height;
	}
	if (need_update)
	{
		create_texture_2D(*texture_top);
		create_texture_2D(*texture_bottom);
		update_labels_pos();
	}
}

void SplitScreenTexture::shutdown()
{
	Render::setEnabled(true);
	lay.deleteLater();
	widget_top.deleteLater();
	widget_bottom.deleteLater();
	wasd_label.deleteLater();
	arrows_label.deleteLater();
}

```

## SpringEasy.cpp

```cpp
#include "SpringEasy.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(SpringEasy);

using namespace Unigine;
using namespace Math;

void SpringEasy::refresh_spring_settings()
{
	float frac_log = Math::log(fraction_of_amplitude);
	stiffness = Math::pow(frac_log, 2) / (Math::pow(duration, 2) * Math::pow(damping_ratio, 2));
	damping = 2.0f * sqrtf(stiffness) * damping_ratio;
}
```

## SpringMotion.cpp

```cpp
#include "SpringMotion.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

void SpringMotion::init()
{
	MotionMode::init();
	physics_ifps = 1.0f / physicsFPS;
	refresh_spring_settings();
	on_enable();
}

void SpringMotion::update()
{
	Vec3 cur_pos = persecutor->getPosition();
	Vec3 prev_pos = cur_pos;
	Vec3 target_pos = targetNode.get()->getWorldPosition();
	// align target to persecutor's plane
	target_pos.z = cur_pos.z;

	// calculate persecutor's new position and direction
	finished = false;
	Vec3 target_dir;
	cur_pos = update_physics(cur_pos, target_pos, finished, target_dir);

	// apply calculations to persecutor
	if (!finished)
		persecutor->setRotation(target_dir);

	persecutor->setPosition(cur_pos);

	float real_speed = (float)length(cur_pos - prev_pos) / Game::getIFps();
	persecutor->setAnimation(real_speed, finished);
}

void SpringMotion::on_enable()
{
	// refresh persecutor's position to continue movement from its last point
	cur_out_p = persecutor->getPosition();
	prev_out_p = cur_out_p;
	position = cur_out_p;
	velocity = Vec3_zero;
}

Vec3 SpringMotion::update_physics(const Vec3 &src, const Vec3 &dst, bool &out_finished,
	Vec3 &out_dir)
{
	// find distance and direction to the destination point
	Vec3 offset = dst - src;
	float dist = (float)length(offset);
	if (dist > 0)
		out_dir = offset / dist;

	out_finished = dist < distance_epsilon;

	float ifps = Game::getIFps();
	// avoid "spiral of death"
	ifps = min(ifps, 0.25f);

	accumulator += ifps;
	// check if we've reached next physical frame
	if (accumulator >= physics_ifps)
	{
		// update input
		prev_in = cur_in;
		cur_in = dst;

		// update physics
		int steps = ftoi(Math::floor(accumulator / physics_ifps));
		for (int i = 0; i < steps; i++)
		{
			// interpolate input for each physical frame: (0, 1]
			float alpha_in = itof(i + 1) / steps;

			prev_out_p = cur_out_p;
			integrate_spring(lerp(prev_in, cur_in, alpha_in), physics_ifps);
			cur_out_p = position;
		}
		// reset counter
		accumulator -= steps * physics_ifps;
	}

	// interpolate output position
	float alpha_out = accumulator / physics_ifps;
	lerped_position = lerp(prev_out_p, cur_out_p, alpha_out);

	return lerped_position;
}

void SpringMotion::integrate_spring(const Unigine::Math::Vec3 &target_position, float ifps)
{
	// calculate spring dynamics
	Vec3 force_spring = (target_position - position) * stiffness;
	Vec3 force_damping = -velocity * damping;
	Vec3 acceleration = (force_spring + force_damping) / mass;

	// use semi-implicit euler integrator
	velocity += acceleration * ifps;
	position += velocity * ifps;
}

```

## SpringRegular.cpp

```cpp
#include "SpringRegular.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(SpringRegular);

using namespace Unigine;
using namespace Math;

void SpringRegular::RefreshSpring()
{
	refresh_spring_settings();
}

void SpringRegular::on_disable()
{
	refresh_spring_settings();
}

void SpringRegular::refresh_spring_settings()
{
	stiffness = defaultStiffness;
	damping = defaultDamping;
}
```

## Sprite.cpp

```cpp
#include "Sprite.h"

REGISTER_COMPONENT(Sprite);

using namespace Unigine;
using namespace Math;

void Sprite::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_sprite = WidgetSprite::create(gui, sprite_image.get());

	gui->addChild(widget_sprite, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_sprite->setPosition(position.get().x, position.get().y);
	widget_sprite->setWidth(size.get().x);
	widget_sprite->setHeight(size.get().y);
}

void Sprite::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_sprite);

		widget_sprite.deleteLater();
	}
}

```

## StateMachine.cpp

```cpp
#include "StateMachine.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>
#include <UnigineEngine.h>

using namespace Unigine;
using namespace Math;

namespace AnimationSystem
{

UNIGINE_INLINE mat4 getTransformProj(const mat4 &t, AXIS axis_forward)
{
	vec3 forward_axis;
	switch (axis_forward) {
		case AXIS_X: forward_axis = t.getAxisX(); break;
		case AXIS_Y: forward_axis = t.getAxisY(); break;
		case AXIS_Z: forward_axis = t.getAxisZ(); break;
		case AXIS_NX: forward_axis = -t.getAxisX(); break;
		case AXIS_NY: forward_axis = -t.getAxisY(); break;
		case AXIS_NZ: forward_axis = -t.getAxisZ(); break;
	}
	vec3 position = projectOntoPlane(t.getTranslate(), vec3_up);
	forward_axis = projectOntoPlane(forward_axis, vec3_up);
	forward_axis.normalize();
	vec3 right_axis = cross(forward_axis, vec3_up);
	right_axis.normalize();

	mat4 proj_t;
	proj_t.setColumn3(0, right_axis);
	proj_t.setColumn3(1, forward_axis);
	proj_t.setColumn3(2, vec3_up);
	proj_t.setColumn3(3, position);
	return proj_t;
}

UNIGINE_INLINE mat4 getLayerBoneTransformProj(const ObjectMeshSkinnedPtr &skinned, int layer, int bone, AXIS axis_forward)
{
	const mat4 bone_t = skinned->getLayerBoneTransform(layer, bone);
	return getTransformProj(bone_t, axis_forward);
}

///////////////////////////////////////////////////////////////////////////////////
// Interpolator
///////////////////////////////////////////////////////////////////////////////////

void Interpolator::initSrcValues(const ObjectMeshSkinnedPtr &skinned)
{
	int num = skinned->getNumBones();

	src_positions.resize(num);
	src_rotations.resize(num);

	for (int i = 0; i < num; i++)
	{
		src_positions[i] = skinned->getLayerBonePosition(LAYER_RESULT, i);
		src_rotations[i] = skinned->getLayerBoneRotation(LAYER_RESULT, i);
	}
}

void Interpolator::initDstValues(const ObjectMeshSkinnedPtr &skinned)
{
	int num = skinned->getNumBones();

	dst_positions.resize(num);
	dst_rotations.resize(num);

	for (int i = 0; i < num; i++)
	{
		dst_positions[i] = skinned->getLayerBonePosition(LAYER_RESULT, i);
		dst_rotations[i] = skinned->getLayerBoneRotation(LAYER_RESULT, i);
	}
}

void Interpolator::calculateOffsets(float in_half_life)
{
	// don't accumulate offsets as this leads to problems when states change frequently
	// just resets them
	for (int i = 0; i < src_positions.size(); i++)
		offset_positions[i] = src_positions[i] - dst_positions[i];

	for (int i = 0; i < src_rotations.size(); i++)
		offset_rotations[i] = abs(src_rotations[i] * inverse(dst_rotations[i]));

	for (int i = 0; i < src_positions.size(); i++)
		offset_linear_velocities[i] = vec3_zero;

	for (int i = 0; i < src_positions.size(); i++)
		offset_angular_velocities[i] = vec3_zero;

	src_positions.clear();
	src_rotations.clear();
	dst_positions.clear();
	dst_rotations.clear();

	half_life = in_half_life;
	active_time = half_life * 10.0f;
}

void Interpolator::update(float ifps)
{
	if (active_time < 0.0f)
		return;
	active_time -= ifps;

	const float y = (4.0f * Consts::LOG2) / Math::max(half_life, Consts::EPS) / 2.0f;
	const float exp_value = Math::exp(-y * ifps);

	for (int i = 0; i < offset_positions.size(); i++)
	{
		// position offset
		{
			vec3 j1_ifps = (offset_linear_velocities[i] + offset_positions[i] * y) * ifps;

			offset_positions[i] = (offset_positions[i] + j1_ifps) * exp_value;
			offset_linear_velocities[i] = (offset_linear_velocities[i] - j1_ifps * y) * exp_value;
		}

		// rotation offset
		{
			vec3 j0 = log(offset_rotations[i]) * 2.0f;
			vec3 j1_ifps = (offset_angular_velocities[i] + j0 * y) * ifps;

			offset_rotations[i] = exp((j0 + j1_ifps) * exp_value * 0.5f);
			offset_angular_velocities[i] = (offset_angular_velocities[i] - j1_ifps * y) * exp_value;
		}
	}
}

void Interpolator::reset(const ObjectMeshSkinnedPtr &skinned)
{
	int num = skinned->getNumBones();
	offset_positions.resize(vec3_zero, num);
	offset_rotations.resize(quat_identity, num);
	offset_linear_velocities.resize(vec3_zero, num);
	offset_angular_velocities.resize(vec3_zero, num);

	src_positions.resize(vec3_zero, num);
	src_rotations.resize(quat_identity, num);

	dst_positions.resize(vec3_zero, num);
	dst_rotations.resize(quat_identity, num);

	active_time = 0.0f;
	half_life = 0.2f;
}

void Interpolator::applyCurrentOffsets(ObjectMeshSkinnedPtr &skinned)
{
	if (active_time < 0.0f)
		return;

	int num_bones = skinned->getNumBones();

	vec3 pos;
	quat rot;
	for (int i = 0; i < num_bones; i++)
	{
		pos = skinned->getLayerBonePosition(LAYER_RESULT, i);
		rot = skinned->getLayerBoneRotation(LAYER_RESULT, i);

		pos += offset_positions[i];
		rot = offset_rotations[i] * rot;

		skinned->setLayerBonePosition(LAYER_RESULT, i, pos);
		skinned->setLayerBoneRotation(LAYER_RESULT, i, rot);
	}
}

void Interpolator::clearOffsets()
{
	for (int i = 0; i < offset_positions.size(); i++)
	{
		offset_positions[i] = vec3_zero;
		offset_rotations[i] = quat_identity;
		offset_linear_velocities[i] = vec3_zero;
		offset_angular_velocities[i] = vec3_zero;
	}
}

///////////////////////////////////////////////////////////////////////////////////
// Transition
///////////////////////////////////////////////////////////////////////////////////

void Transition::parseConditions(const StateMachine &state_machine, const char *conditions_str)
{
	conditions.clear();

	auto condition_parts = String::split(conditions_str, "AND");
	for (int i = 0; i < condition_parts.size(); i++)
	{
		String condition_str = condition_parts[i];
		condition_str = condition_str.trim();
		Transition::Condition condition;

		if (String::compare(condition_str, "end") == 0)
		{
			condition.func = Transition::FUNC_END;
			conditions.append(condition);
			continue;
		}

		auto parts = String::split(condition_str, " ");
		if (parts.size() != 3)
			continue;

		if (state_machine.containsVariable(parts[0]) == false)
			continue;

		condition.var_type = state_machine.getVariableType(parts[0]);
		condition.var_id = state_machine.getVariableID(condition.var_type, parts[0]);

		if (String::compare(parts[1], "<") == 0)
		{
			condition.func = Transition::FUNC_LESS;
			condition.const_0 = String::atof(parts[2]);
			conditions.append(condition);
			continue;
		}

		if (String::compare(parts[1], ">") == 0)
		{
			condition.func = Transition::FUNC_GREATER;
			condition.const_0 = String::atof(parts[2]);
			conditions.append(condition);
			continue;
		}

		if (String::compare(parts[1], "==") == 0)
		{
			condition.func = Transition::FUNC_EQUAL;
			condition.const_0 = String::atof(parts[2]);
			conditions.append(condition);
			continue;
		}

		if (String::compare(parts[1], "!=") == 0)
		{
			condition.func = Transition::FUNC_NOT_EQUAL;
			condition.const_0 = String::atof(parts[2]);
			conditions.append(condition);
			continue;
		}

		if (String::compare(parts[1], "in") == 0)
		{
			auto values = String::split(parts[2], ";");
			if (values.size() == 2)
			{
				condition.func = Transition::FUNC_IN_RANGE;
				condition.const_0 = String::atof(values[0]);
				condition.const_1 = String::atof(values[1]);
				conditions.append(condition);
				continue;
			}
		}

		if (String::compare(parts[1], "out") == 0)
		{
			auto values = String::split(parts[2], ";");
			if (values.size() == 2)
			{
				condition.func = Transition::FUNC_OUT_RANGE;
				condition.const_0 = String::atof(values[0]);
				condition.const_1 = String::atof(values[1]);
				conditions.append(condition);
				continue;
			}
		}
	}
}

bool Transition::check(const StateMachine &state_machine, const State *state) const
{
	auto check_condition = [this, &state_machine, state](const Condition &condition)
	{
		if (condition.func == FUNC_END)
			return state->isEnd();

		if (condition.var_type == VAR_TYPE_NONE || condition.var_id == -1)
			return false;

		const float var_value = state_machine.getStateVariable(condition.var_type, condition.var_id);
		switch (condition.func)
		{
			case FUNC_GREATER:   return var_value > condition.const_0;
			case FUNC_LESS:      return var_value < condition.const_0;
			case FUNC_EQUAL:     return toBool(compare(var_value, condition.const_0));
			case FUNC_NOT_EQUAL: return toBool(compare(var_value, condition.const_0)) == false;
			case FUNC_IN_RANGE:  return (condition.const_0 < var_value && var_value < condition.const_1);
			case FUNC_OUT_RANGE: return (var_value < condition.const_0 || condition.const_1 < var_value);
		}

		return false;
	};

	for (const auto &condition : conditions)
	{
		if (check_condition(condition) == false)
			return false;
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////
// State
///////////////////////////////////////////////////////////////////////////////////

State::State(const char *name, int type, AXIS axis_forward)
	: name(name)
	, type(type)
	, axis_forward(axis_forward)
{}

void State::addTransition(const StateMachine &state_machine, const char *next_state, const char *conditions, float half_life)
{
	Transition &transition = transitions.append();
	transition.next_state = next_state;
	transition.parseConditions(state_machine, conditions);
	transition.half_life = half_life;
}

const char *State::checkTransition(const StateMachine &state_machine, float &out_transition_half_life)
{
	if (state_time < min_playback_time)
		return nullptr;

	out_transition_half_life = 0.0f;
	for (const auto &transition : transitions)
	{
		if (transition.check(state_machine, this))
		{
			out_transition_half_life = transition.half_life;
			return transition.next_state;
		}
	}

	return nullptr;
}

void State::init(const StateMachine &state_machine, ObjectMeshSkinnedPtr &skinned)
{
	if (animations_data.empty())
		return;

	switch (type)
	{
		case TYPE_ANIMATION:
		{
			// choose animation
			current_anim_index = 0;
			if (isUseRandomAnimation())
				current_anim_index = Game::getRandomInt(0, animations_data.size());

			// get num frames
			num_frames = animations_data[current_anim_index].animation->num_frames;

			resetForFrame(state_machine, skinned, 0.0f);
			break;
		}
		case TYPE_BLEND_1D:
		case TYPE_BLEND_2D:
		{
			// get num frames
			num_frames = animations_data[0].animation->num_frames;

			resetForFrame(state_machine, skinned, 0.0f);
			break;
		}
	}
}

void State::resetForFrame(const StateMachine &state_machine, ObjectMeshSkinnedPtr &skinned, float in_frame, int anim_index /*= -1*/)
{
	if (animations_data.empty())
		return;

	switch (type)
	{
		case TYPE_ANIMATION:
		{
			// set current animation
			if (anim_index != -1)
				current_anim_index = anim_index;

			// update num frames
			num_frames = animations_data[current_anim_index].animation->num_frames;

			// set frame and previous root transform
			setFrame(in_frame, state_machine, skinned);

			if (state_machine.isUseRootMotion())
			{
				animations_data[current_anim_index].prev_root_t = getLayerBoneTransformProj(skinned, LAYER_RESULT, state_machine.getRootBone(), axis_forward);
				animations_data[current_anim_index].root_motion_delta = mat4_identity;
			}

			break;
		}
		case TYPE_BLEND_1D:
		case TYPE_BLEND_2D:
		{
			// set frames and previous root transform
			if (anim_index == -1)
				anim_index = 0;

			float current_frame = (in_frame / (animations_data[anim_index].animation->num_frames - 1)) * (getNumFrames() - 1);
			setFrame(current_frame, state_machine, skinned);

			if (state_machine.isUseRootMotion())
			{
				const float normalized_frame = getNormalizedFrame();
				for (int i = 0; i < animations_data.size(); i++)
				{
					float f = normalized_frame * (animations_data[i].animation->num_frames - 1);

					skinned->setLayerAnimationResourceID(LAYER_AUXILIARY, animations_data[i].anim_id);
					skinned->setLayerFrame(LAYER_AUXILIARY, f);

					animations_data[i].prev_root_t = getLayerBoneTransformProj(skinned, LAYER_AUXILIARY, state_machine.getRootBone(), axis_forward);
					animations_data[current_anim_index].root_motion_delta = mat4_identity;
				}
			}

			break;
		}
	}

	root_motion_delta = mat4_identity;
}

void State::findBestFootAnimation(int &out_anim_index, int &out_frame, const StateMachine &state_machine,
								  const vec3 &left_foot_pos, const vec3 &right_foot_pos)
{
	out_anim_index = current_anim_index;
	out_frame = 0;

	if (animations_data.empty())
		return;

	auto get_frame_error = [this](const StateMachine &state_machine, int anim_index, int frame,
								  const vec3 &left_foot_pos, const vec3 &right_foot_pos)
	{
		const vec3 &dst_left_foot_pos = animations_data[anim_index].animation->left_foot_positions[frame];
		const vec3 &dst_right_foot_pos = animations_data[anim_index].animation->right_foot_positions[frame];

		float error = (dst_left_foot_pos - left_foot_pos).length2() + (dst_right_foot_pos - right_foot_pos).length2();
		return error;
	};

	float min_error = Consts::INF;
	if (foot_matching_override || type == TYPE_BLEND_1D || type == TYPE_BLEND_2D)
	{
		for (int i = 0; i < animations_data.size(); i++)
		{
			int num = animations_data[i].animation->num_frames;
			for (int j = ftoi(num * foot_matching_begin); j < ftoi(num * foot_matching_end); j++)
			{
				float error = get_frame_error(state_machine, i, j, left_foot_pos, right_foot_pos);
				if (error < min_error)
				{
					out_anim_index = i;
					out_frame = j;
					min_error = error;
				}
			}
		}
	} else
	{
		int num = animations_data[out_anim_index].animation->num_frames;
		for (int j = ftoi(num * foot_matching_begin); j < ftoi(num * foot_matching_end); j++)
		{
			float error = get_frame_error(state_machine, out_anim_index, j, left_foot_pos, right_foot_pos);
			if (error < min_error)
			{
				out_frame = j;
				min_error = error;
			}
		}
	}
}

void State::update(float ifps, float speed, const StateMachine &state_machine, Interpolator *interpolator,
				   ObjectMeshSkinnedPtr &skinned)
{
	switch (type)
	{
		case TYPE_ANIMATION: update_animation(ifps, speed, state_machine, skinned);  break;
		case TYPE_BLEND_1D:  update_blend_tree(ifps, speed, state_machine, skinned); break;
		case TYPE_BLEND_2D:  update_blend_tree(ifps, speed, state_machine, skinned); break;
	}

	state_time += ifps;
}

void State::setFrame(float in_frame, const StateMachine &state_machine, ObjectMeshSkinnedPtr &skinned)
{
	if (animations_data.empty())
		return;

	frame = clamp(in_frame, 0.0f, itof(getNumFrames() - 1));

	switch (type)
	{
		case TYPE_ANIMATION:
		{
			skinned->setLayerAnimationResourceID(LAYER_RESULT, animations_data[current_anim_index].anim_id);
			skinned->setLayerFrame(LAYER_RESULT, frame);

			int prev_index = floorInt(frame);
			int next_index = ceilInt(frame);
			float k = frac(frame);

			left_foot_pos = lerp(animations_data[current_anim_index].animation->left_foot_positions[prev_index],
								 animations_data[current_anim_index].animation->left_foot_positions[next_index], k);

			right_foot_pos = lerp(animations_data[current_anim_index].animation->right_foot_positions[prev_index],
								  animations_data[current_anim_index].animation->right_foot_positions[next_index], k);

			if (state_machine.isUseRootMotion())
			{
				// root motion delta
				mat4 t = getLayerBoneTransformProj(skinned, LAYER_RESULT, state_machine.getRootBone(), axis_forward);
				mat4 delta = inverse(animations_data[current_anim_index].prev_root_t) * t;

				animations_data[current_anim_index].root_motion_delta = delta * animations_data[current_anim_index].last_delta;
				animations_data[current_anim_index].prev_root_t = t;
			}

			break;
		}
		case TYPE_BLEND_1D:
		case TYPE_BLEND_2D:
		{
			if (getType() == TYPE_BLEND_1D)
			{
				float x = state_machine.getStateVariable(blend_x_var_type, blend_x_var_id);
				if (compare(x, blend_point.x) == false)
				{
					blend_point.x = x;
					update_weights_1d();
				}
			} else
			{
				float x = state_machine.getStateVariable(blend_x_var_type, blend_x_var_id);
				float y = state_machine.getStateVariable(blend_y_var_type, blend_y_var_id);
				if (compare(x, blend_point.x) == false || compare(y, blend_point.y) == false)
				{
					blend_point.x = x;
					blend_point.y = y;
					update_weights_2d();
				}
			}

			const float normalized_frame = getNormalizedFrame();

			float total_weight = 0.0f;
			for (int i = 0; i < animations_data.size(); i++)
			{
				if (animations_data[i].weight < Consts::EPS)
					continue;

				skinned->setLayerAnimationResourceID(LAYER_AUXILIARY, animations_data[i].anim_id);

				float f = normalized_frame * (animations_data[i].animation->num_frames - 1);
				skinned->setLayerFrame(LAYER_AUXILIARY, f);

				total_weight += animations_data[i].weight;
				skinned->lerpLayer(LAYER_RESULT, LAYER_RESULT, LAYER_AUXILIARY, animations_data[i].weight / total_weight);

				int prev_index = floorInt(f);
				int next_index = ceilInt(f);
				float k = frac(frame);

				vec3 left_pos(lerp(animations_data[i].animation->left_foot_positions[prev_index],
									 animations_data[i].animation->left_foot_positions[next_index], k));

				vec3 right_pos(lerp(animations_data[i].animation->right_foot_positions[prev_index],
									  animations_data[i].animation->right_foot_positions[next_index], k));

				left_foot_pos = lerp(left_foot_pos, left_pos, animations_data[i].weight / total_weight);
				right_foot_pos = lerp(right_foot_pos, right_pos, animations_data[i].weight / total_weight);

				if (state_machine.isUseRootMotion())
				{
					mat4 t = getLayerBoneTransformProj(skinned, LAYER_AUXILIARY, state_machine.getRootBone(), axis_forward);
					mat4 delta = inverse(animations_data[i].prev_root_t) * t;

					animations_data[i].root_motion_delta = delta * animations_data[i].last_delta;
					animations_data[i].prev_root_t = t;
				}
			}

			break;
		}
	}
}

void State::setFootMatching(float begin, float end, bool is_override)
{
	foot_matching_begin = begin;
	foot_matching_end = end;
	foot_matching_override = is_override;
}

void State::addAnimation(Animation *animation, const ObjectMeshSkinnedPtr &skinned)
{
	if (getType() != TYPE_ANIMATION)
		return;

	AnimData &data = animations_data.append();
	data.animation = animation;
	data.anim_id = skinned->getAnimationResourceID(data.animation->path);
}

void State::addBlend1DAnimation(Animation *animation, float anchor, const ObjectMeshSkinnedPtr &skinned)
{
	if (getType() != TYPE_BLEND_1D)
		return;

	AnimData &data = animations_data.append();
	data.animation = animation;
	data.anim_id = skinned->getAnimationResourceID(data.animation->path);
	data.anchor.x = anchor;

	min_anchors_value.x = min(min_anchors_value.x, data.anchor.x);
	max_anchors_value.x = max(max_anchors_value.x, data.anchor.x);

	quickSort(animations_data.begin(), animations_data.end(),
			  [](const AnimData &a, const AnimData &b) { return a.anchor.x < b.anchor.x; });
}

void State::addBlend2DAnimation(Animation *animation, const vec2 &anchor, const ObjectMeshSkinnedPtr &skinned)
{
	if (getType() != TYPE_BLEND_2D)
		return;

	AnimData &data = animations_data.append();
	data.animation = animation;
	data.anim_id = skinned->getAnimationResourceID(data.animation->path);
	data.anchor = anchor;

	min_anchors_value = min(min_anchors_value, data.anchor);
	max_anchors_value = max(max_anchors_value, data.anchor);
}

void State::update_animation(float ifps, float speed, const StateMachine &state_machine, ObjectMeshSkinnedPtr &skinned)
{
	if (animations_data.empty())
		return;

	// check end of playback
	if (isEnd())
	{
		root_motion_delta = mat4_identity;
		return;
	}

	// next frame
	frame += ifps * speed;
	frame = clamp(frame, 0.0f, itof(getNumFrames() - 1));

	const int last_index = getNumFrames() - 1;
	if (ftoi(frame) == last_index)
	{
		if (state_machine.isUseRootMotion())
		{
			// get delta from current position to last frame
			setFrame(itof(last_index), state_machine, skinned);
			animations_data[current_anim_index].last_delta = animations_data[current_anim_index].root_motion_delta;
		}

		if (isLoop())
		{
			frame -= itof(last_index);
			resetForFrame(state_machine, skinned, 0.0f);
		} else
		{
			frame = itof(last_index);
		}
	} else
	{
		if (state_machine.isUseRootMotion())
			animations_data[current_anim_index].last_delta = mat4_identity;
	}

	setFrame(frame, state_machine, skinned);

	if (state_machine.isUseRootMotion())
		root_motion_delta = animations_data[current_anim_index].root_motion_delta;
}

void State::update_blend_tree(float ifps, float speed, const StateMachine &state_machine, ObjectMeshSkinnedPtr &skinned)
{
	if (animations_data.empty())
		return;

	if (animations_data.size() == 1)
	{
		update_animation(ifps, speed, state_machine, skinned);
		return;
	}

	// check end of playback
	if (isEnd())
	{
		root_motion_delta = mat4_identity;
		return;
	}

	// next frame
	frame += ifps * speed;
	frame = clamp(frame, 0.0f, itof(getNumFrames() - 1));

	const int last_index = getNumFrames() - 1;
	if (ftoi(frame) == last_index)
	{
		// get delta from current position to last frame
		setFrame(itof(last_index), state_machine, skinned);
		for (int i = 0; i < animations_data.size(); i++)
			animations_data[i].last_delta = animations_data[i].root_motion_delta;

		if (isLoop())
		{
			frame -= itof(last_index);
			resetForFrame(state_machine, skinned, 0.0f);
		} else
		{
			frame = itof(last_index);
		}
	} else
	{
		for (int i = 0; i < animations_data.size(); i++)
			animations_data[i].last_delta = mat4_identity;
	}

	// final result
	setFrame(frame, state_machine, skinned);

	if (state_machine.isUseRootMotion())
	{
		root_motion_delta = mat4_identity;

		float total_weight = 0.0f;
		for (int i = 0; i < animations_data.size(); i++)
		{
			if (animations_data[i].weight < Consts::EPS)
				continue;

			total_weight += animations_data[i].weight;
			root_motion_delta = lerp(root_motion_delta, animations_data[i].root_motion_delta, animations_data[i].weight / total_weight);
		}
	}
}

void State::update_weights_1d()
{
	for (int i = 0; i < animations_data.size(); i++)
		animations_data[i].weight = 0.0f;

	if (animations_data.size() != 0)
	{
		if (blend_point.x < animations_data.first().anchor.x)
		{
			animations_data.first().weight = 1.0f;
			return;
		}

		if (animations_data.last().anchor.x < blend_point.x)
		{
			animations_data.last().weight = 1.0f;
			return;
		}
	}

	for (int i = 0; i < animations_data.size() - 1; i++)
	{
		AnimData &a = animations_data[i];
		AnimData &b = animations_data[i + 1];

		if (a.anchor.x <= blend_point.x && blend_point.x <= b.anchor.x)
		{
			a.weight = (b.anchor.x - blend_point.x) / (b.anchor.x - a.anchor.x);
			b.weight = 1.0f - a.weight;
			break;
		}
	}
}

void State::update_weights_2d()
{
	blend_point = clamp(blend_point, min_anchors_value, max_anchors_value);

	// gradient band interpolation
	float total_weight = 0.0f;
	for (int i = 0; i < animations_data.size(); i++)
	{
		const vec2 projected_vector = blend_point - animations_data[i].anchor;

		float min_weight = Consts::INF;
		for (int j = 0; j < animations_data.size(); j++)
		{
			if (j == i)
				continue;

			vec2 projection_direction = animations_data[j].anchor - animations_data[i].anchor;
			float weight = 1.0f - dot(projected_vector, projection_direction) / projection_direction.length2();
			min_weight = min(min_weight, max(weight, 0.0f));
		}

		animations_data[i].weight = min_weight;
		total_weight += min_weight;
	}

	for (int i = 0; i < animations_data.size(); i++)
		animations_data[i].weight = animations_data[i].weight / total_weight;
}

///////////////////////////////////////////////////////////////////////////////////
// State Machine
///////////////////////////////////////////////////////////////////////////////////

Map<String, Animation *> StateMachine::animations;
int StateMachine::state_machines_count = 0;
Mutex StateMachine::anim_mutex;

StateMachine::StateMachine()
{
	ScopedLock lock(anim_mutex);
	state_machines_count++;
}

StateMachine::~StateMachine()
{
	ScopedLock lock(anim_mutex);
	state_machines_count--;

	if (state_machines_count == 0)
	{
		for (const auto &pair : animations)
			delete pair.data;
		animations.clear();
	}
}

void StateMachine::initFromProperty(ObjectMeshSkinnedPtr &object, const PropertyPtr &prop, AXIS in_axis_forward)
{
	connections.disconnectAll();

	axis_forward = in_axis_forward;

	skinned = object;
	skinned->stop();
	skinned->setInterpolationAccuracy(ObjectMeshSkinned::INTERPOLATION_ACCURACY_LOW);

	skinned->setNumLayers(NUM_LAYERS);

	skinned->getEventUpdate().connect(connections, this, &StateMachine::update);
	engine_update_frame = 0;

	PropertyParameterPtr root = prop->getParameterPtr();

	animations_frame_rate = root->getChild("animations_frame_rate")->getValueInt();
	playback_speed = root->getChild("playback_speed")->getValueFloat();

	// features
	use_root_motion = root->getChild("use_root_motion")->getValueToggle();
	use_smooth_transitions = root->getChild("use_smooth_transitions")->getValueToggle();
	use_foot_matching = root->getChild("use_foot_matching")->getValueToggle();

	// bones
	root_bone_name = root->getChild("root_bone_name")->getValueString();
	left_foot_bone_name = root->getChild("left_foot_bone_name")->getValueString();
	right_foot_bone_name = root->getChild("right_foot_bone_name")->getValueString();

	root_bone = skinned->findBone(root_bone_name);
	left_foot_bone = skinned->findBone(left_foot_bone_name);
	right_foot_bone = skinned->findBone(right_foot_bone_name);

	// state variables
	float_variables.clear();
	float_indices.clear();
	flag_variables.clear();
	flag_indices.clear();

	add_float_variable("state_time", 0.0f);

	int state_variables_index = root->findChild("state_variables");
	if (state_variables_index != -1)
	{
		PropertyParameterPtr variables_param = root->getChild(state_variables_index);
		int num = variables_param->getNumChildren();
		for (int i = 0; i < num; i++)
		{
			PropertyParameterPtr variable_param = variables_param->getChild(i);
			int type = variable_param->getChild("type")->getValueInt();
			const char *name = variable_param->getChild("name")->getValueString();
			float default_value = variable_param->getChild("default_value")->getValueFloat();

			if (type == 0)
				add_float_variable(name, default_value);
			else if (type == 1)
				add_flag_variable(name, ftoi(default_value));
		}
	}

	// states
	states.clear();

	int states_index = root->findChild("states");
	if (states_index != -1)
	{
		PropertyParameterPtr states_param = root->getChild(states_index);
		int num = states_param->getNumChildren();
		for (int i = 0; i < num; i++)
		{
			PropertyParameterPtr state_param = states_param->getChild(i);

			// general
			const char *name = state_param->getChild("name")->getValueString();
			int state_type = state_param->getChild("state_type")->getValueInt();
			float min_playback_time = state_param->getChild("min_playback_time")->getValueFloat();
			bool is_loop = state_param->getChild("is_loop")->getValueToggle();
			bool is_use_random_animation = state_param->getChild("use_random_animation")->getValueToggle();
			float foot_matching_begin = state_param->getChild("foot_matching_begin")->getValueFloat();
			float foot_matching_end = state_param->getChild("foot_matching_end")->getValueFloat();
			bool foot_matching_override = state_param->getChild("foot_matching_override")->getValueToggle();
			const char *x_blend_variable = state_param->getChild("x_blend_variable")->getValueString();
			const char *y_blend_variable = state_param->getChild("y_blend_variable")->getValueString();

			State &state = add_state(name, state_type);
			state.setMinPlaybackTime(min_playback_time);
			state.setLoop(is_loop);
			state.setUseRandomAnimation(is_use_random_animation);
			state.setFootMatching(foot_matching_begin, foot_matching_end, foot_matching_override);

			int var_type = getVariableType(x_blend_variable);
			int var_id = getVariableID(var_type, x_blend_variable);
			state.setBlendXVariable(var_type, var_id);

			var_type = getVariableType(y_blend_variable);
			var_id = getVariableID(var_type, y_blend_variable);
			state.setBlendYVariable(var_type, var_id);

			// animations
			PropertyParameterPtr animations_param = state_param->getChild("animations");
			int num_animations = animations_param->getNumChildren();
			for (int j = 0; j < num_animations; j++)
			{
				PropertyParameterPtr anim_param = animations_param->getChild(j);
				const char *anim_path = anim_param->getChild("path")->getValueFile();
				vec2 anim_anchor = anim_param->getChild("anchor")->getValueVec2();

				Animation *anim = load_animation(anim_path, root_bone, left_foot_bone, right_foot_bone);

				switch (state.getType())
				{
					case State::TYPE_ANIMATION: state.addAnimation(anim, skinned);                       break;
					case State::TYPE_BLEND_1D:  state.addBlend1DAnimation(anim, anim_anchor.x, skinned); break;
					case State::TYPE_BLEND_2D:  state.addBlend2DAnimation(anim, anim_anchor, skinned);   break;
				}
			}

			// transitions
			PropertyParameterPtr transitions_param = state_param->getChild("transitions");
			int num_transitions = transitions_param->getNumChildren();
			for (int j = 0; j < num_transitions; j++)
			{
				PropertyParameterPtr transition_param = transitions_param->getChild(j);
				const char *next_state = transition_param->getChild("next_state")->getValueString();
				const char *condition = transition_param->getChild("condition")->getValueString();
				float half_life = transition_param->getChild("half_life")->getValueFloat();
				state.addTransition(*this, next_state, condition, half_life);
			}
		}
	}

	// initial state
	current_state_name = "";
	current_state_hash = 0;

	int initial_state_index = root->findChild("init_state_name");
	if (initial_state_index != -1)
	{
		const char *state_name = root->getChild(initial_state_index)->getValueString();
		setCurrentStateName(state_name, true);
	}

	interpolator.reset(skinned);

	root_motion_speed = 0.0f;
}

void StateMachine::update(float ifps)
{
	engine_update_frame = Engine::get()->getFrame();

	if (is_update_enabled == false)
		return;

	if (skinned.isValid() == false)
		return;

	auto res = states.findFast(current_state_name);
	if (res == nullptr)
		return;

	if (isUseSmoothTransitions())
		interpolator.update(ifps);

	State &state = res->data;
	state.update(ifps, animations_frame_rate * playback_speed, *this, &interpolator, skinned);
	setFloatVariable(0, state.getStateTime());

	// apply state frame
	if (isUseSmoothTransitions() && res != nullptr && res->data.isEnd() == false)
		interpolator.applyCurrentOffsets(skinned);

	if (isUseRootMotion())
	{
		const mat4 bone_t = skinned->getLayerBoneTransform(LAYER_RESULT, getRootBone());
		const mat4 proj_bone_t = getTransformProj(bone_t, axis_forward);
		skinned->setLayerBoneTransform(LAYER_RESULT, getRootBone(), inverse(proj_bone_t) * bone_t);
	}

	float transition_duration = 0.0f;

	const char *next_state = state.checkTransition(*this, transition_duration);
	if (next_state != nullptr)
	{
		res = states.findFast(next_state);
		if (res != nullptr)
		{
			State &_next_state = res->data;
			init_transition(state, _next_state, transition_duration);
		}
	}

	root_motion_speed = getRootMotionDelta().getTranslate().length() / max(Consts::EPS, ifps);
}

void StateMachine::setCurrentStateName(const char *name, bool is_immediate_transition, float transition_duration /*= 0.2f*/)
{
	if (states.contains(name))
	{
		if (is_immediate_transition)
		{
			current_state_name = name;
			states[current_state_name].init(*this, skinned);
			current_state_hash = states.findFast(current_state_name)->hash;
			interpolator.clearOffsets();
		} else
		{
			State &state = states[current_state_name];
			State &next_state = states[name];
			init_transition(state, next_state, transition_duration);
		}

	} else
	{
		current_state_name = "";
		current_state_hash = 0;
	}
}

unsigned int StateMachine::getStateHash(const char *state_name) const
{
	auto res = states.findFast(state_name);
	if (res != nullptr)
		return res->hash;

	return 0;
}

int StateMachine::getCurrentStateNumFrames() const
{
	auto res = states.findFast(current_state_name);
	if (res != nullptr)
		return res->data.getNumFrames();

	return 0;
}

float StateMachine::getCurrentStateFrame() const
{
	auto res = states.findFast(current_state_name);
	if (res != nullptr)
		return res->data.getFrame();

	return 0.0f;
}

void StateMachine::setFloatVariable(const char *name, float value)
{
	auto res = float_indices.findFast(name);
	if (res != nullptr)
	{
		int index = res->data;
		float_variables[index] = value;
	}
}

float StateMachine::getFloatVariable(const char *name) const
{
	auto res = float_indices.findFast(name);
	if (res != nullptr)
	{
		int index = res->data;
		return float_variables[index];
	}

	return 0.0f;
}

int StateMachine::getFloatVariableID(const char *name) const
{
	auto res = float_indices.findFast(name);
	if (res != nullptr)
		return res->data;

	return -1;
}

void StateMachine::setFlagVariable(const char *name, int value)
{
	auto res = flag_indices.findFast(name);
	if (res != nullptr)
	{
		int index = res->data;
		flag_variables[index] = clamp(value, 0, 1);
	}
}

int StateMachine::getFlagVariable(const char *name) const
{
	auto res = flag_indices.findFast(name);
	if (res != nullptr)
	{
		int index = res->data;
		return flag_variables[index];
	}

	return 0;
}

int StateMachine::getFlagVariableID(const char *name) const
{
	auto res = flag_indices.findFast(name);
	if (res != nullptr)
		return res->data;

	return -1;
}

int StateMachine::getVariableType(const char *name) const
{
	if (float_indices.contains(name))
		return VAR_TYPE_FLOAT;

	if (flag_indices.contains(name))
		return VAR_TYPE_FLAG;

	return VAR_TYPE_NONE;
}

int StateMachine::getVariableID(int type, const char *name) const
{
	switch (type)
	{
		case VAR_TYPE_FLOAT:
			if (float_indices.contains(name))
				return float_indices[name];
			break;
		case VAR_TYPE_FLAG:
			if (flag_indices.contains(name))
				return flag_indices[name];
			break;
	}

	return -1;
}

float StateMachine::getStateVariable(int type, int id) const
{
	switch (type)
	{
		case VAR_TYPE_FLOAT: return float_variables[id];
		case VAR_TYPE_FLAG:  return itof(flag_variables[id]);
	}

	return 0.0f;
}

mat4 StateMachine::getRootMotionDelta() const
{
	const long long frame = Engine::get()->getFrame();
	if (frame != engine_update_frame && frame != (engine_update_frame + 1))
		return mat4_identity;

	if (states.contains(current_state_name))
	{
		const State &state = states[current_state_name];
		return state.getRootMotionDelta();
	}

	return mat4_identity;
}

void StateMachine::init_transition(State &current_state, State &next_state, float duration)
{
	current_state.clearTime();

	// src
	if (isUseSmoothTransitions())
		interpolator.initSrcValues(skinned);

	current_state_name = next_state.getName();
	current_state_hash = states.findFast(current_state_name)->hash;
	next_state.init(*this, skinned);

	if (isUseFootMatching())
	{
		int best_anim_index = 0;
		int best_frame = 0;
		const vec3 &src_left_foot_pos = current_state.getLeftFootPosition();
		const vec3 &src_right_foot_pos = current_state.getRightFootPosition();
		next_state.findBestFootAnimation(best_anim_index, best_frame, *this, src_left_foot_pos, src_right_foot_pos);
		next_state.resetForFrame(*this, skinned, itof(best_frame), best_anim_index);
	}

	// dst
	if (isUseSmoothTransitions())
	{
		interpolator.initDstValues(skinned);
		interpolator.calculateOffsets(duration);
	}

	next_state.clearTime();

	if (isUseSmoothTransitions())
		interpolator.applyCurrentOffsets(skinned);

	if (isUseRootMotion())
	{
		const mat4 bone_t = skinned->getLayerBoneTransform(LAYER_RESULT, getRootBone());
		const mat4 proj_bone_t = getTransformProj(bone_t, axis_forward);
		skinned->setLayerBoneTransform(LAYER_RESULT, getRootBone(), inverse(proj_bone_t) * bone_t);
	}
}

State &StateMachine::add_state(const char *name, int type)
{
	if (states.contains(name))
	{
		if (states[name].getType() != type)
		{
			states.remove(name);
			states.insert(name, State(name, type, axis_forward));
		}
	} else
	{
		states.insert(name, State(name, type, axis_forward));
	}

	states[name].init(*this, skinned);
	return states[name];
}

void StateMachine::add_float_variable(const char *name, float value)
{
	if (float_indices.contains(name))
	{
		int index = float_indices[name];
		float_variables[index] = value;
	} else
	{
		float_variables.append(value);
		float_indices.insert(name, float_variables.size() - 1);
	}
}

void StateMachine::add_flag_variable(const char *name, int value)
{
	value = clamp(value, 0, 1);

	if (flag_indices.contains(name))
	{
		int index = flag_indices[name];
		flag_variables[index] = value;
	} else
	{
		flag_variables.append(value);
		flag_indices.insert(name, flag_variables.size() - 1);
	}
}

Animation *StateMachine::load_animation(const char *path, int root_bone_index, int left_foot_bone_index, int right_foot_bone_index)
{
	ScopedLock lock(anim_mutex);

	if (animations.contains(path))
		return animations[path];

	Animation *anim = new Animation();
	anim->path = path;

	MeshAnimationPtr mesh = MeshAnimation::create();
	if (mesh->load(path) != 0)
	{
		anim->num_frames = mesh->getNumFrames();
		anim->left_foot_positions.resize(anim->num_frames);
		anim->right_foot_positions.resize(anim->num_frames);

		const int num_mesh_bones = mesh->getNumBones();

		Vector<short> anim_bones;
		mesh->getAnimationBones(anim_bones);

		auto get_bone_transform = [&mesh](int bone, const Vector<mat4> &bone_transforms)
		{
			mat4 t{bone_transforms[bone]};

			int parent = mesh->getBoneParent(bone);
			while (parent != -1)
			{
				t = bone_transforms[parent] * t;
				parent = mesh->getBoneParent(parent);
			}

			return t;
		};

		Vector<mat4> transforms;
		for (int i = 0; i < anim->num_frames; i++)
		{
			mesh->getFrame(i, transforms);

			Vector<mat4> mesh_bone_transforms;
			mesh_bone_transforms.resize(num_mesh_bones);
			for (int j = 0; j < num_mesh_bones; j++)
			{
				int anim_bone_index = anim_bones.findIndex(j);
				if (anim_bone_index == -1)
					mesh_bone_transforms[j] = mesh->getBoneTransform(j);
				else
					mesh_bone_transforms[j] = transforms[anim_bone_index];
			}

			mat4 root_it = inverse(get_bone_transform(root_bone_index, mesh_bone_transforms));
			mat4 left_foot_t = get_bone_transform(left_foot_bone_index, mesh_bone_transforms);
			mat4 right_foot_t = get_bone_transform(right_foot_bone_index, mesh_bone_transforms);

			anim->left_foot_positions[i] = (root_it * left_foot_t).getTranslate();
			anim->right_foot_positions[i] = (root_it * right_foot_t).getTranslate();
		}
	}

	animations.append(path, anim);
	return anim;
}





}

```

## StateSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineVisualizer.h>

#include "../../menu_ui/SampleDescriptionWindow.h"

using namespace Unigine;
using namespace Math;

class StateSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(StateSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_UPDATE(update);
	COMPONENT_SHUTDOWN(shutdown);

	PROP_PARAM(Node, node_param);

private:
	void init()
	{
		saved_state = Blob::create();
		save_state();

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
		gui.init(this);
	}

	void update()
	{
		Visualizer::renderBox(vec3(2.f), translate(Vec3(0, 3, 1.3)), vec4_white);
		Visualizer::renderSolidBox(vec3(.75f), last_transform, vec4(vec3(1), .25f));
	}

	void shutdown()
	{
		gui.shutdown();
		Visualizer::setEnabled(visualizer_enabled);
	}

	void save_state()
	{
		// you can save and restore any Node's state using two Stream-based methods: Node::saveState and Node::restoreState

		saved_state->clear();
		node_param->saveState(saved_state);
		last_transform = node_param->getWorldTransform();
	}

	void restore_state()
	{
		if (saved_state && saved_state->getSize())
		{
			saved_state->seekSet(0);
			node_param->restoreState(saved_state);
			saved_state->seekSet(0);
		}
	}

	// ========================================================================================

	struct SampleGui : public EventConnections
	{
		void init(StateSample *sample)
		{
			this->sample = sample;

			sample_description_window.createWindow();

			auto parameters = sample_description_window.getParameterGroupBox();
			auto vbox = WidgetVBox::create();
			parameters->addChild(vbox);

			{
				auto hbox = WidgetHBox::create();

				save_btn = WidgetButton::create("Save");
				save_btn->getEventClicked().connect(this, &SampleGui::on_save_state_btn_clicked);
				hbox->addChild(save_btn);

				restore_btn = WidgetButton::create("Restore");
				restore_btn->getEventClicked().connect(this, &SampleGui::on_restore_state_btn_clicked);
				hbox->addChild(restore_btn);

				vbox->addChild(hbox);
			}
		}

		void shutdown()
		{
			sample_description_window.shutdown();
		}

		void on_save_state_btn_clicked(const WidgetPtr &widget, int mouse)
		{
			sample->save_state();
		}

		void on_restore_state_btn_clicked(const WidgetPtr &widget, int mouse)
		{
			sample->restore_state();
		}

		WidgetButtonPtr save_btn;
		WidgetButtonPtr restore_btn;

		StateSample *sample = nullptr;
		SampleDescriptionWindow sample_description_window;
	};

	// ========================================================================================

	bool visualizer_enabled = false;
	Mat4 last_transform;
	BlobPtr saved_state;
	SampleGui gui;
};

REGISTER_COMPONENT(StateSample);

```

## StreamBaseSample.cpp

```cpp
#include "StreamBaseSample.h"

#include <UnigineConsole.h>

MyFile::MyFile(const char *path, const char *mode)
{
	const Unigine::String absolute_path = Unigine::FileSystem::getAbsolutePath(path);
	file = fopen(absolute_path, mode);
}

MyFile::~MyFile()
{
	fclose(file);
}

int MyFile::isOpened()
{
	return file != nullptr;
}

int MyFile::isAvailable()
{
	return feof(file) != 0;
}

size_t MyFile::read(void *ptr, size_t size, size_t nmemb)
{
	return fread(ptr, size, nmemb, file);
}

size_t MyFile::write(const void *ptr, size_t size, size_t nmemb)
{
	return fwrite(ptr, size, nmemb, file);
}

void StreamBaseSample::sample()
{
	Unigine::String file_str = filepath.get();
	if (file_str.size() <= 0)
	{
		Unigine::Log::error("StreamBaseSample::sample(): Filepath param is empty!");
		return;
	}

	Unigine::Console::setOnscreen(true);
	// create the file
	{
		MyFile file(file_str, "wb");

		// here you can get access to stream
		// and use all of its features
		Unigine::StreamPtr stream = file.getStream();
		stream->writeString("Some string");
		stream->writeInt(42);
		stream->writeFloat(3.14f);
	}

	// read from the file
	{
		MyFile file(file_str, "rb");
		Unigine::StreamPtr stream = file.getStream();
		Unigine::Log::message("%s\n", stream->readString().get());
		Unigine::Log::message("%d\n", stream->readInt());
		Unigine::Log::message("%f\n", stream->readFloat());
	}
}

void StreamBaseSample::shutdown()
{
	Unigine::Console::setOnscreen(false);
}

REGISTER_COMPONENT(StreamBaseSample)

```

## StructuredBufferSample.cpp

```cpp
#include "StructuredBufferSample.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(StructuredBufferSample)

void StructuredBufferSample::init()
{
	// Compute material
	MaterialPtr compute_material = Materials::findManualMaterial("gpu_dxt_compute");

	// Load source texture
	TexturePtr source_texture = Texture::create();
	source_texture->load(source_texture_param.get());

	Log::message("Source texture size %ix%i: %i kb\n", source_texture->getWidth(),
		source_texture->getHeight(),
		(source_texture->getWidth() * source_texture->getHeight() * 3) / 1024);

	// Output structure
	struct DXT1Block
	{
		unsigned int colors;
		unsigned int indices;
	};

	// Calculate DXT Size
	const int dxt_size_x = source_texture->getWidth() / 4;
	const int dxt_size_y = source_texture->getHeight() / 4;

	// Defined by shader
	const int threads_in_group_x = 8;
	const int threads_in_group_y = 8;

	// Create output structure buffer (gpu_read-readwrite)
	StructuredBufferPtr dxt_buffer = StructuredBuffer::create();
	dxt_buffer->create(StructuredBuffer::USAGE_RENDER, NULL, sizeof(DXT1Block),
		dxt_size_x * dxt_size_y);

	Unigine::Log::message("Structure buffer (compressed DXT) size in video memory: %s\n",
		Unigine::String::memory(sizeof(DXT1Block) * dxt_size_x * dxt_size_y).get());

	// Create compute render
	RenderTargetPtr render_target = RenderTarget::create();

	// Bind source texture
	RenderState::setTexture(RenderState::BIND_ALL, 0, source_texture);

	// Setup unordered access buffer (read-write)
	render_target->bindStructuredBuffer(0, dxt_buffer);
	render_target->enableCompute();

	// Calculate groups for dispatch compute shader
	int groups_x = (dxt_size_x) / threads_in_group_x;
	int groups_y = (dxt_size_y) / threads_in_group_y;

	if ((dxt_size_x) % threads_in_group_x > 0)
	{
		groups_x++;
	}

	if ((dxt_size_y) % threads_in_group_y > 0)
	{
		groups_y++;
	}

	long begin_time = clock();

	// Calculate warm-up time (shader compilation)
	compute_material->renderCompute(Render::PASS_POST, 1, 1);
	render_target->flush();

	float time_warmup = float(clock() - begin_time) / CLOCKS_PER_SEC * 1000;
	begin_time = clock();

	// Dispatch groups_x * groups_y groups threads, 256 thread each
	compute_material->renderCompute(Render::PASS_POST, groups_x, groups_y);
	render_target->flush();

	float time_execution = float(clock() - begin_time) / CLOCKS_PER_SEC * 1000;

	Unigine::Log::message("Shader setup and compilation time: %f ms\n", time_warmup);
	Unigine::Log::message(
		"Dispatched %ix%i group threads (%ix%i threads each), execution time: %f ms\n", groups_x,
		groups_y, threads_in_group_x, threads_in_group_y, time_execution);

	render_target->disable();
	render_target->unbindStructuredBuffers();

	// Create image
	ImagePtr dxt_image = Image::create();
	dxt_image->create2D(source_texture->getWidth(), source_texture->getHeight(), Image::FORMAT_DXT1,
		1, 0, 1);

	begin_time = clock();

	// Transfer data from GPU to Image CPU
	Render::asyncTransferStructuredBuffer(nullptr,
		MakeCallback([begin_time, dxt_image, dxt_buffer](void *data) {
			Unigine::Log::message("Transfer GPU -> CPU time: %f ms\n",
				float(clock() - begin_time) / CLOCKS_PER_SEC * 1000);
			memcpy(dxt_image->getPixels(), data, sizeof(DXT1Block) * dxt_buffer->getNumElements());

			// Save image
			String path = String::format("%s%s", Engine::get()->getSavePath(),
				"compressed_image.dds");
			dxt_image->save(path.get());
			Unigine::Log::message("Compressed texture saved: %s\n", path.get());
		}),
		dxt_buffer);

	dxt_buffer.clear();
}

```

## SunController.cpp

```cpp
#pragma once
#include "SunController.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(SunController);

void SunController::init()
{
	sun_init_tilt = node->getWorldRotation();
}

void SunController::update()
{
	if (is_continuous)
	{
		current_time += Game::getIFps() * timescale;
		if (current_time > max_time_sec)
		{
			current_time -= max_time_sec;//so we wont loose extra delta time 
		}
		refreshSunPosition();;
		time_changed_event.run(current_time);//displaying only integer part
	}
}

void SunController::setContinuousEnabled(bool value)
{
	is_continuous = value;
}

void SunController::setTimescale(float timescale)
{
	this->timescale = timescale;
}

void SunController::refreshSunPosition()
{
	//converting time to rotation
	float time = fmodf(current_time, max_time_sec);
	float k = Math::inverseLerp(0.0f, max_time_sec, time);
	float angle = Math::lerp(-180.0f, 180.0f, k);// +180 deg  so that 12:00 corresponds to noon
	node->setWorldRotation(sun_init_tilt * quat(angle, 0.0f, 0.0f), true);
}

void SunController::setTime(int t)
{
	current_time = t;
	refreshSunPosition();

	time_changed_event.run(current_time);
}

```

## TCPSocketsSample.cpp

```cpp
#include "TCPSocketsSample.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>

#include "../../utils/Utils.h"

using namespace Unigine;

REGISTER_COMPONENT(TCPSocketsSample);

namespace
{
	constexpr const char *DEFAULT_SERVER_HOSTNAME = "127.0.0.1";
	constexpr unsigned short DEFAULT_SERVER_PORT = 64'000;

	constexpr int SEND_BUFFER_SIZE = 4096;
	constexpr int RECV_BUFFER_SIZE = 4096;

	constexpr int MAX_CLIENT_CONNECTIONS = 8;

	constexpr int CLIENT_CONNECTION_TIMEOUT_MS = 10'000;
	constexpr int CLIENT_WRITE_TIMEOUT_US = 1'000;
	constexpr int CLIENT_READ_TIMEOUT_US = 1'000;
}

void TCPSocketsSample::init()
{
	gui.init(this);
}

void TCPSocketsSample::update()
{
	if (host)
		host->update();

	gui.update();
}

void TCPSocketsSample::shutdown()
{
	if (host)
	{
		delete host;
		host = nullptr;
	}

	gui.shutdown();
}

// =================================================================================

TCPSocketsSample::Client::Client(const Unigine::String &hostname, unsigned short port)
{
	// Create a generic socket and start the Client's network thread.

	// Note that the provided address is used as the target address in the subsequent `connect` call.
	// The socket's own address is set automatically!

	SocketPtr socket = Socket::create(Socket::SOCKET_TYPE_STREAM, hostname, port);

	if (!socket->isOpened())
	{
		Log::warning("Could not resolve specified hostname (%s)!\n", hostname.get());
		return;
	}

	// Set the sockets send and receive buffer sizes.
	socket->send(SEND_BUFFER_SIZE);
	socket->recv(RECV_BUFFER_SIZE);

	// Set the socket as non-blocking.
	socket->nonblock();

	thread.start(socket, true);

	if (PlayerPtr player = Game::getPlayer())
		player->setControlled(false);

	Console::addCommand(
		"send_msg",
		"[Network Sockets Sample] Send a text message to peer.",
		MakeCallback(this, &TCPSocketsSample::Client::on_message_send_cmd)
	);
}

TCPSocketsSample::Client::~Client()
{
	if (PlayerPtr player = Game::getPlayer())
		player->setControlled(true);

	Console::removeCommand("send_msg");
}

void TCPSocketsSample::Client::update()
{
	// Handle incoming messages from the Server.

	if (!thread.isRunning())
		return;

	Message *message = thread.receive();
	int processed = 0;

	while (message && processed < message_process_limit)
	{
		switch (message->getType())
		{
			case Message::TEXT:
			{
				TextMessage *text_msg = dynamic_cast<TextMessage *>(message);

				if (text_msg->text.get() && !text_msg->text.empty())
					Log::message("Received a text message from Server: %s\n", text_msg->text.get());

				break;
			}

			case Message::CAMERA:
			{
				CameraMessage *camera_msg = dynamic_cast<CameraMessage *>(message);

				if (camera_msg)
				{
					PlayerPtr player = Game::getPlayer();

					if (player)
					{
						player->setWorldPosition(camera_msg->position);
						player->setWorldRotation(camera_msg->rotation);
					}
				}

				break;
			}
		}

		delete message;
		message = thread.receive();
		processed += 1;
	}
}

void TCPSocketsSample::Client::NetworkThread::start(Unigine::SocketPtr socket, bool connect)
{
	reset();
	this->socket = socket;
	this->connect = connect;
	run();
}

void TCPSocketsSample::Client::NetworkThread::reset()
{
	shutdown();

	if (socket)
	{
		socket->close();
		socket.clear();
	}

	send_queue.clear();
	recv_queue.clear();
}

void TCPSocketsSample::Client::NetworkThread::send(Message *message)
{
	send_queue.push(message);
}

TCPSocketsSample::Message *TCPSocketsSample::Client::NetworkThread::receive()
{
	return recv_queue.pop();
}

void TCPSocketsSample::Client::NetworkThread::process()
{
	// Receive incoming and send outgoing messages.

	// Since TCP is a stream-oriented protocol, reading messages is a bit harder than on message-oriented UDP.
	// To keep track of where we are in the incoming data stream we distinguish three states:
	//   RECEIVE_HEADER - preparing to receive the message header containing data about its type and size
	//   RECEIVE_PAYLOAD - preparing to receive the message's actual payload
	//   UNPACK_MESSAGE - unpacking the message from the raw binary data

	enum { RECEIVE_HEADER, RECEIVE_PAYLOAD, UNPACK_MESSAGE } recv_state = RECEIVE_HEADER;

	int recv_size = 0;
	int send_size = 0;

	BlobPtr send_blob = Blob::create();
	BlobPtr recv_blob = Blob::create();

	// Perform the connection on the socket if asked to (only used by Client).
	if (connect)
	{
		if (socket->connect(CLIENT_CONNECTION_TIMEOUT_MS))
		{
			Log::message("[Client::NetworkThread] Successfully connected to the server (%s:%d).\n", socket->getHost(), socket->getPort());
		}
		else
		{
			Log::warning("[Client::NetworkThread] Could not connect to the server at the specified address (%s:%d)!\n", socket->getHost(), socket->getPort());
			return;
		}
	}

	while (isRunning())
	{
		// ==================== Send outgoing messages ====================

		{
			if (send_blob->getSize() == 0)
			{
				Message *send_message = send_queue.pop();
				if (send_message)
				{
					send_size = send_message->pack(send_blob);
					send_blob->seekSet(0);

					delete send_message;
					send_message = nullptr;
				}
			}

			if (send_blob->getSize())
			{
				if (socket->isReadyToWrite(CLIENT_WRITE_TIMEOUT_US))
				{
					int written = socket->writeStream(send_blob, send_size);

					if (written != send_size)
					{
						// Could not send the message in full. Something must've gone wrong with the connection.

						Log::message("[Client::NetworkThread] The remote connection was closed or an error has occured. Closing the socket.\n");

						socket->close();
						return;
					}

					send_blob->clear();
				}
			}
		}

		// ==================== Receive incoming messages ====================

		{
			switch (recv_state)
			{
				case RECEIVE_HEADER:
				{
					// Going to read the next message's header.

					recv_blob->resize(sizeof(Message::Header));
					recv_blob->seekSet(0);

					recv_size = sizeof(Message::Header);
					break;
				}

				case RECEIVE_PAYLOAD:
				{
					// Received the message header, now going to read the payload following it.
					// Here we unpack the header, check it for validity, and save the message payload size.

					Message::Header header;

					recv_blob->seekSet(0);
					recv_blob->read(&header, sizeof(Message::Header));

					// We don't reset the blob cursor back to start here after Blob::read
					// so that the next call to Socket::recvStream with this blob
					// does not overwrite the header.

					int type = header.type;
					int size = header.size;

					bool valid = (size >= 0 && size <= RECV_BUFFER_SIZE) && (type >= 0 && type < Message::TYPE::NUM_TYPES);

					if (valid)
					{
						recv_blob->resize(size);
						recv_size = Math::max(0, size - int(sizeof(Message::Header)));
					}
					else
					{
						// The message size or type are invalid.

						// This is probably because we somehow lost track of where messages start and end
						// in the incoming data stream. Our position in the stream is now undetermined,
						// and there isn't much we can do at this point. Close the connection.

						if (size > RECV_BUFFER_SIZE)
							Log::message("[Client::NetworkThread] The message payload size was too large (%d)!\n", size);

						if (type < 0 || type >= Message::TYPE::NUM_TYPES)
							Log::message("[Client::NetworkThread] The message type was invalid (%d)!\n", type);

						Log::message("[Client::NetworkThread] Closing the connection.\n");
						socket->close();
						return;
					}

					break;
				}

				case UNPACK_MESSAGE:
				{
					// Received the message in full. Unpack it and store in the queue.

					recv_blob->seekSet(0); // Reset the blob cursor the start so that we read the whole message, including the header.
					Message *message = extract_message(recv_blob);

					if (message)
						recv_queue.push(message);

					recv_state = RECEIVE_HEADER;
					recv_blob->clear();
					recv_size = 0;

					break;
				}
			}

			if (recv_size > 0)
			{
				// Read the next portion (header or payload) of the message from the socket.

				if (socket->isReadyToRead(CLIENT_READ_TIMEOUT_US))
				{
					int read = socket->readStream(recv_blob, recv_size);

					if (read == 0 || read != recv_size)
					{
						// Connection has been closed/reset/terminated or an error has occured.

						Log::message("[Client::NetworkThread] The remote connection was terminated or an error has occured. Closing the socket.\n");

						socket->close();
						return;
					}

					switch (recv_state)
					{
						case RECEIVE_HEADER: recv_state = RECEIVE_PAYLOAD; break;
						case RECEIVE_PAYLOAD: recv_state = UNPACK_MESSAGE; break;
						default: break;
					}
				}
			}
		}
	}
}

TCPSocketsSample::Message *TCPSocketsSample::Client::NetworkThread::extract_message(Unigine::BlobPtr blob)
{
	Message *message = nullptr;
	Message::Header header;

	blob->read(&header, sizeof(Message::Header));
	blob->seekSet(0);

	switch (header.type)
	{
		case Message::TEXT: message = new TextMessage(); break;
		case Message::CAMERA: message = new CameraMessage(); break;
		default: message = nullptr; break;
	}

	if (message)
		message->unpack(blob);

	return message;
}

void TCPSocketsSample::Client::on_message_send_cmd(int argc, char **argv)
{
	StringStack<> text;

	for (int i = 1; i < argc; i += 1)
	{
		text += argv[i];
		if (i != (argc - 1))
			text += " ";
	}

	thread.send(new TextMessage(text));
}

// =================================================================================

TCPSocketsSample::Server::Server(const Unigine::String &hostname, unsigned short port)
{
	// Initialize a listen socket on the given address (hostname:port), and start the Server's network thread.

	SocketPtr socket = Socket::create(Socket::SOCKET_TYPE_STREAM, hostname, port);

	if (!socket->isOpened())
	{
		Log::warning("Could not resolve specified hostname (%s)!\n", hostname.get());
		return;
	}

	// Set the socket as non-blocking.
	socket->nonblock();

	// Bind the socket to the provided address.
	if (!socket->bind())
	{
		Log::warning("Could not bind socket to the specified address (%s:%d)!\n", hostname.get(), int(port));
		return;
	}

	// Set the socket as a 'listen' socket, and specify the max number of client connections.
	socket->listen(MAX_CLIENT_CONNECTIONS);

	clients.reserve(MAX_CLIENT_CONNECTIONS);

	thread.start(socket);

	Console::addCommand(
		"send_msg",
		"[Network Sockets Sample] Send a text message to peer.",
		MakeCallback(this, &TCPSocketsSample::Server::on_message_send_cmd)
	);
}

TCPSocketsSample::Server::~Server()
{
	for (int i = 0; i < clients.size(); i += 1)
	{
		if (Client::NetworkThread *client = clients[i])
			delete client;
	}

	Console::removeCommand("send_msg");
}

void TCPSocketsSample::Server::update()
{
	// Go over the client network threads/connections and remove the ones which have terminated.
	for (int i = 0; i < clients.size(); i += 1)
	{
		Client::NetworkThread *client = clients[i];

		if (!client->isConnectionActive())
		{
			clients.removeFast(i--);
			delete client;
		}
	}

	// Take the new accepted connections from the network thread's queue.
	while (SocketPtr connection = thread.accept())
	{
		Client::NetworkThread *client = new Client::NetworkThread(connection, false);
		Log::message("[Server] Accepted a client connection (%s:%d).\n", client->getHostname(), client->getPort());
		clients.push_back(client);
	};

	// Handle incoming / outgoing messages from/to each client.
	for (int i = 0; i < clients.size(); i += 1)
	{
		Client::NetworkThread *client = clients[i];

		if (Message *message = client->receive())
		{
			TextMessage *text_msg = dynamic_cast<TextMessage *>(message);
			if (text_msg && text_msg->text.get() && !text_msg->text.empty())
				Log::message("Received a text message from Client [%d]: %s\n", i, text_msg->text.get());
		}

		if (PlayerPtr player = Game::getPlayer())
			client->send(new CameraMessage(player->getWorldPosition(), player->getWorldRotation()));
	}
}

void TCPSocketsSample::Server::NetworkThread::start(Unigine::SocketPtr socket)
{
	reset();

	this->socket = socket;

	run();
}

void TCPSocketsSample::Server::NetworkThread::reset()
{
	shutdown();

	if (socket)
	{
		socket->close();
		socket.clear();
	}
}

SocketPtr TCPSocketsSample::Server::NetworkThread::accept()
{
	ScopedLock lock(mutex);
	SocketPtr connection;

	if (connections.size())
		connection = connections.takeFirst();

	return connection;
}

void TCPSocketsSample::Server::NetworkThread::process()
{
	while (isRunning())
	{
		SocketPtr client = Socket::create(Socket::SOCKET_TYPE_STREAM);

		if (socket->accept(client))
		{
			ScopedLock lock(mutex);
			connections.push_back(client);
		}
	}
}

void TCPSocketsSample::Server::on_message_send_cmd(int argc, char **argv)
{
	StringStack<> text;

	for (int i = 1; i < argc; i += 1)
	{
		text += argv[i];
		if (i != (argc - 1))
			text += " ";
	}

	for (int i = 0; i < clients.size(); i += 1)
		clients[i]->send(new TextMessage(text));
}

// =================================================================================

size_t TCPSocketsSample::TextMessage::pack(Unigine::BlobPtr dst_blob)
{
	size_t cursor = dst_blob->tell();
	size_t packed = 0;

	packed += dst_blob->write(&header, sizeof(header));

	size_t text_size = text.size();
	packed += dst_blob->write(&text_size, sizeof(text_size));
	packed += dst_blob->write(text.get(), text_size);

	header.type = getType();
	header.size = packed;

	dst_blob->seekSet(cursor);
	dst_blob->write(&header, sizeof(header));

	dst_blob->seekSet(cursor + packed);

	return packed;
}

size_t TCPSocketsSample::TextMessage::unpack(Unigine::BlobPtr src_blob)
{
	size_t unpacked = 0;

	unpacked += src_blob->read(&header, sizeof(header));

	size_t text_size = 0;

	unpacked += src_blob->read(&text_size, sizeof(text_size));

	if (text_size)
	{
		text.resize(text_size);
		unpacked += src_blob->read(text.getRaw(), text_size);
	}

	return unpacked;
}

size_t TCPSocketsSample::CameraMessage::pack(Unigine::BlobPtr dst_blob)
{
	size_t cursor = dst_blob->tell();
	size_t packed = 0;

	packed += dst_blob->write(&header, sizeof(header));
	packed += dst_blob->write(&position, sizeof(position));
	packed += dst_blob->write(&rotation, sizeof(rotation));

	header.type = getType();
	header.size = packed;

	dst_blob->seekSet(cursor);
	dst_blob->write(&header, sizeof(header));

	dst_blob->seekSet(cursor + packed);

	return packed;
}

size_t TCPSocketsSample::CameraMessage::unpack(Unigine::BlobPtr src_blob)
{
	size_t unpacked = 0;

	unpacked += src_blob->read(&header, sizeof(header));
	unpacked += src_blob->read(&position, sizeof(position));
	unpacked += src_blob->read(&rotation, sizeof(rotation));

	return unpacked;
}

// =================================================================================

void TCPSocketsSample::SampleGui::init(TCPSocketsSample *sample)
{
	this->sample = sample;
	is_onscreen = Console::isOnscreen();
	Console::setOnscreen(true);

	sample_description_window.createWindow(Gui::ALIGN_RIGHT);

	auto const &group_box = sample_description_window.getParameterGroupBox();

	auto vbox = WidgetVBox::create();
	auto buttons_hbox = WidgetHBox::create();

	start_client_btn = WidgetButton::create("Client");
	start_client_btn->setToggleable(true);
	start_client_btn->setToggled(false);
	start_client_btn->setHeight(24);
	start_client_btn->getEventClicked().connect(this, &SampleGui::on_start_client_btn_clicked);
	buttons_hbox->addChild(start_client_btn);

	start_server_btn = WidgetButton::create("Server");
	start_server_btn->setToggleable(true);
	start_server_btn->setToggled(false);
	start_server_btn->setHeight(24);
	start_server_btn->getEventClicked().connect(this, &SampleGui::on_start_server_btn_clicked);
	buttons_hbox->addChild(start_server_btn);

	auto spacer = WidgetSpacer::create();
	spacer->setOrientation(0);
	buttons_hbox->addChild(spacer);

	server_hostname_el = WidgetEditLine::create(DEFAULT_SERVER_HOSTNAME);
	server_hostname_el->setWidth(100);
	server_hostname_el->setHeight(18);
	server_hostname_el->setFontVOffset(-2);
	buttons_hbox->addChild(server_hostname_el);

	buttons_hbox->addChild(WidgetLabel::create(":"));

	server_port_el = WidgetEditLine::create(String::itoa(DEFAULT_SERVER_PORT).get());
	server_port_el->setWidth(45);
	server_port_el->setHeight(18);
	server_port_el->setFontVOffset(-2);
	server_port_el->setValidator(Gui::VALIDATOR_UINT);
	buttons_hbox->addChild(server_port_el);

	vbox->addChild(buttons_hbox);
	vbox->addChild(WidgetVBox::create(0, 5));

	client_connections_gbox = WidgetGroupBox::create("", 0, 5);
	vbox->addChild(client_connections_gbox);

	group_box->addChild(vbox, Gui::ALIGN_TOP);
	group_box->arrange();

	for (int i = 0; i < Engine::get()->getNumArgs(); i++)
	{
		String str = Engine::get()->getArg(i);
		if (str == "-server")
			start_server_btn->setToggled(true);
		else if (str == "-client")
			start_client_btn->setToggled(true);
	}
}

void TCPSocketsSample::SampleGui::update()
{
	auto add_connection_gui = [this](const char *hostname, unsigned short port)
	{
		auto hbox = WidgetHBox::create();
		hbox->addChild(WidgetLabel::create(String::format("%s:%d", hostname, int(port)).get()));
		client_connections_gbox->addChild(hbox);
	};

	while (client_connections_gbox->getNumChildren())
	{
		auto child = client_connections_gbox->getChild(0);
		client_connections_gbox->removeChild(child);
	}

	if (auto client = dynamic_cast<TCPSocketsSample::Client *>(sample->host))
	{
		if (client->isConnectionActive())
			add_connection_gui(client->getHostname(), client->getPort());
	}

	else if (auto server = dynamic_cast<TCPSocketsSample::Server *>(sample->host))
	{
		auto const& clients = server->getClients();
		for (int i = 0; i < clients.size(); i += 1)
			add_connection_gui(clients[i]->getHostname(), clients[i]->getPort());
	}
}

void TCPSocketsSample::SampleGui::shutdown()
{
	sample_description_window.shutdown();
	Console::setOnscreen(is_onscreen);
	sample = nullptr;
}

void TCPSocketsSample::SampleGui::on_start_server_btn_clicked(const WidgetPtr &widget, int mouse)
{
	if (sample->host)
	{
		delete sample->host;
		sample->host = nullptr;
	}

	MUTE_EVENT(start_server_btn->getEventClicked());
	MUTE_EVENT(start_client_btn->getEventClicked());

	if (start_server_btn->isToggled())
	{
		StringStack<> hostname;
		unsigned short port = 0;

		hostname = server_hostname_el->getText();
		port = (unsigned short) String::atoi(server_port_el->getText());

		sample->host = new Server(hostname, port);

		server_hostname_el->setEnabled(false);
		server_port_el->setEnabled(false);

		start_client_btn->setToggled(false);
	}

	else
	{
		server_hostname_el->setEnabled(true);
		server_port_el->setEnabled(true);
	}
}

void TCPSocketsSample::SampleGui::on_start_client_btn_clicked(const WidgetPtr &widget, int mouse)
{
	if (sample->host)
	{
		delete sample->host;
		sample->host = nullptr;
	}

	MUTE_EVENT(start_server_btn->getEventClicked());
	MUTE_EVENT(start_client_btn->getEventClicked());

	if (start_client_btn->isToggled())
	{
		StringStack<> hostname;
		unsigned short port = 0;

		hostname = server_hostname_el->getText();
		port = (unsigned short) String::atoi(server_port_el->getText());

		sample->host = new Client(hostname, port);

		server_hostname_el->setEnabled(false);
		server_port_el->setEnabled(false);

		start_server_btn->setToggled(false);
	}

	else
	{
		server_hostname_el->setEnabled(true);
		server_port_el->setEnabled(true);
	}
}

```

## Target.cpp

```cpp
#include "Target.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(PathfindingTarget);

using namespace Unigine;
using namespace Unigine::Math;

void PathfindingTarget::init()
{
	take_new_position();
}

void PathfindingTarget::onReached()
{
	take_new_position();
}

void PathfindingTarget::take_new_position()
{
	if (!positions)
		return;
	
	int positions_cnt = positions->getNumChildren();
	
	if (positions_cnt != 0)
	{
		auto new_position = positions->getChild(Game::getRandomInt(0, positions_cnt))->getWorldPosition();
		node->setWorldPosition(new_position);
	}
}

```

## TargetGui.cpp

```cpp
#include "TargetGui.h"
#include <UnigineGame.h>


REGISTER_COMPONENT(TargetGui);

using namespace Unigine;
using namespace Math;

void TargetGui::update()
{
	float distance = (node->getWorldPosition() - Game::getPlayer()->getWorldPosition()).length();
	distance_label->setText("Distance to label : " + String::ftoa(distance, 2) + " units");
}

void TargetGui::init()
{
	object_gui = checked_ptr_cast<ObjectGui>(node);
	if (!object_gui)
	{
		Log::error("TargetGui::init cannot find ObjectGui for node!\n");
	}
	gui = object_gui->getGui();

	WidgetWindowPtr window = WidgetWindow::create();
	gui->addChild(window, Gui::ALIGN_CENTER);

	WidgetVBoxPtr vbox = WidgetVBox::create();
	vbox->setSpace(1, 3);
	window->addChild(vbox, Gui::ALIGN_CENTER);
	window->setWidth(gui->getWidth());
	window->setHeight(gui->getHeight());


	WidgetLabelPtr target_label = WidgetLabel::create(node->getName());
	target_label->setFontSize(50);
	vbox->addChild(target_label);

	float distance = (node->getWorldPosition() - Game::getPlayer()->getWorldPosition()).length();
	distance_label = WidgetLabel::create("Distance to label : " + String::ftoa(distance, 2) + " units");
	distance_label->setFontSize(50);
	vbox->addChild(distance_label);

	WidgetLabelPtr size_label = WidgetLabel::create("Size of label : " +
		String::ftoa(object_gui->getPhysicalWidth()) + "x" + String::ftoa(object_gui->getPhysicalHeight(), 2));
	size_label->setFontSize(50);
	vbox->addChild(size_label);
}

```

## TargetMarker.cpp

```cpp
#include "TargetMarker.h"

REGISTER_COMPONENT(TargetMarker);

using namespace Unigine;
using namespace Math;

void TargetMarker::init()
{
	if (!arrowSprite)
	{
		Log::error("TargetMarker::init(): Source file for the pointer sprite image is not found.");
		return;
	}
	arrow = WidgetSprite::create(arrowSprite.get());
	WindowManager::getMainWindow()->addChild(arrow, Gui::ALIGN_OVERLAP);

	if (!pointSprite)
	{
		Log::error("TargetMarker::init(): Source file for the marker sprite image is not found.");
		return;
	}

	point = WidgetSprite::create(pointSprite.get());
	WindowManager::getMainWindow()->addChild(point, Gui::ALIGN_OVERLAP);

	if (!targetNode)
	{
		Log::error("TargetMarker::init(): No target object specified.");
		return;
	}
	target = targetNode.get();

	camera = checked_ptr_cast<Player>(node);
	if (!camera)
	{
		Log::error("TargetMarker::init(): Camera is not valid.");
		return;
	}
}

void TargetMarker::update()
{
	if (!arrow || !point || !target || !camera)
		return;

	arrow_height = arrow->getLayerHeight(0);
	arrow_width = arrow->getLayerWidth(0);
	arrow_half_height = arrow_height / 2;
	arrow_half_width = arrow_width / 2;

	point_width = point->getLayerWidth(0);
	point_height = point->getLayerHeight(0);
	mat4 translation = mat4(translate(Vec3(-point_width * pointPivot.get().x, -point_height * pointPivot.get().y, 0.0f) * WindowManager::getMainWindow()->getDpiScale()));
	point->setTransform(translation);

	arrow->setHidden(true);
	point->setHidden(true);

	// window size
	int width = WindowManager::getMainWindow()->getClientSize().x;
	int height = WindowManager::getMainWindow()->getClientSize().y;
	int halfWidth = width / 2;
	int halfHeight = height / 2;

	// target point in screen space
	int x = 0;
	int y = 0;

	vec3 targetDirection(target->getWorldBoundBox().getCenter() - camera->getWorldPosition());

	bool behind = dot(camera->getWorldDirection(Unigine::Math::AXIS_NZ), targetDirection) < 0;

	// find target point projection to the screen-space plane and change the coordinate system to the center of the screen
	if (!behind)
	{
		camera->getScreenPosition(x, y, target->getWorldBoundBox().getCenter(), width, height);

		x -= halfWidth;
		y -= halfHeight;
		y *= -1;
	}
	// if the target is out of sight calculate the position in screen space relative to the reflected target position
	else
	{
		Vec3 inverseScreenPlaneNormal(camera->getViewDirection() * -1);
		Vec3 relativeToCameraTargetPosition = target->getWorldBoundBox().getCenter() - camera->getWorldPosition();

		// ortho projection of vector realtiveToCameraTargetPosition to vector inverseScreenPlaneNormal
		Vec3 orthoProjectionTarget = inverseScreenPlaneNormal * dot(relativeToCameraTargetPosition, inverseScreenPlaneNormal);
		Vec3 reflectedTargetPosition = (relativeToCameraTargetPosition - orthoProjectionTarget * 2) + camera->getWorldPosition();

		camera->getScreenPosition(x, y, reflectedTargetPosition, width, height);

		x -= halfWidth;
		y -= halfHeight;
		// when target is out of sight the arrow is always at the bottom part of the screen
		if (y > 0)
			y *= -1;
	}

	// if the target is inside the field of view we highlight it with the marker
	if (!behind && x >= -halfWidth && x <= halfWidth && y >= -halfHeight && y <= halfHeight)
	{
		point->setHidden(false);
		point->setPosition(x + halfWidth, -y + halfHeight);
	}
	// if the target is out of sight we show an arrow that points direction to the target
	else
	{
		// calculating the pivot point for the arrow
		int point_x = 0;
		int point_y = 0;
		getIntersectionWithRect(point_x, point_y, x, y, halfWidth, halfHeight);
		float angle = 0.0f;

		// setting porsition and rotation of the arrow sprite, all calculations are made taking into account the fact that the position of the sprite is calculated relative to its upper left corner
		// if the arrow is in the corner
		if (halfHeight - Math::abs(point_y) <= arrow_half_height && halfWidth - Math::abs(point_x) <= arrow_half_width)
		{
			float dx, dy;

			if (point_y > 0)
				dy = (float)(point_y - (halfHeight - arrow_half_width));
			else
				dy = (float)(point_y + (halfHeight - arrow_half_width));

			if (point_x > 0)
				dx = (float)(point_x - (halfWidth - arrow_half_width));
			else
				dx = (float)(point_x + (halfWidth - arrow_half_width));

			angle = -Math::atan2(dy, dx) * Consts::RAD2DEG;

			if (point_x > 0)
				point_x = halfWidth - arrow_width;
			else
				point_x = -halfWidth;

			if (point_y > 0)
				point_y = halfHeight;
			else
				point_y = -halfHeight + arrow_height;
		}
		// if the arrow points up
		else if (point_y == halfHeight)
		{
			point_x -= arrow_half_width;
			angle = -90;
		}
		// if the arrow points down
		else if (point_y == -halfHeight)
		{
			point_y += arrow_height;
			point_x -= arrow_half_width;
			angle = 90;
		}
		// if the arrow points to the left
		else if (point_x == -halfWidth)
		{
			point_y += arrow_half_height;
			angle = 180;
		}
		// if the arrow points to the right
		else if (point_x == halfWidth)
		{
			point_x -= arrow_width;
			point_y += arrow_half_height;
			angle = 0;
		}

		arrow->setHidden(false);
		arrow->setPosition(point_x + halfWidth, -point_y + halfHeight);

		mat4 rotation(
			mat4(translate(Vec3(arrow_half_width * 1.0f, arrow_half_height * 1.0f, 0.0f) * WindowManager::getMainWindow()->getDpiScale())) *
			rotate(quat(vec3_up, angle)) *
			mat4(translate(Vec3(-arrow_half_width * 1.0f, -arrow_half_height * 1.0f, 0.0f) * WindowManager::getMainWindow()->getDpiScale()))
		);

		arrow->setLayerTransform(0, rotation);
	}
}

void TargetMarker::shutdown()
{
	arrow.deleteLater();
	point.deleteLater();
}

void TargetMarker::getIntersectionWithRect(int& x, int& y, int vec_x, int vec_y, int half_width, int half_height)
{
	if (vec_y >= 0)
	{
		if (vec_y == 0)
		{
			if (vec_x > 0)
			{
				x = half_width;
				y = 0;
			}
			else
			{
				x = -half_width;
				y = 0;
			}

			return;
		}

		x = (int)(half_height * ((float)vec_x / (float)vec_y));
		y = half_height;

		if (x >= -half_width && x <= half_width)
			return;

		if (vec_x >= 0)
		{
			if (vec_x == 0)
			{
				x = 0;
				y = half_height;

				return;
			}

			x = half_width;
			y = (int)(half_width * ((float)vec_y / (float)vec_x));

			return;
		}
		else
		{
			x = -half_width;
			y = (int)(-half_width * ((float)vec_y / (float)vec_x));

			return;
		}
	}
	else
	{
		x = (int)(-half_height * ((float)vec_x / (float)vec_y));
		y = -half_height;

		if (x >= -half_width && x <= half_width)
			return;

		if (vec_x >= 0)
		{
			if (vec_x == 0)
			{
				x = 0;
				y = -half_height;

				return;
			}

			x = half_width;
			y = (int)(half_width * ((float)vec_y / (float)vec_x));

			return;
		}
		else
		{
			x = -half_width;
			y = (int)(-half_width * ((float)vec_y / (float)vec_x));

			return;
		}
	}
}

```

## TerrainMesh.cpp

```cpp
#include "TerrainMesh.h"

#include <UnigineVisualizer.h>
#include <UnigineMeshDynamic.h>
#include <UnigineMaterials.h>

REGISTER_COMPONENT(TerrainMesh);

using namespace Unigine;
using namespace Math;

void TerrainMesh::run()
{
	if (state != State::IDLE)
		return;

	Mat4 transform = node->getWorldTransform();
	Vec3 bottom_left = transform * Vec3(-0.5f, -0.5f, 0.0f);

	transform.setColumn3(3, Vec3(0.0f, 0.0f, 0.0f));
	Vec3 delta_x = transform * Vec3(1.0f / resolution.x, 0.0f, 0.0f);
	Vec3 delta_y = transform * Vec3(0.0f, 1.0f / resolution.y, 0.0f);


	fetch_positions.clear();
	for (int i = 0; i <= resolution.y; ++i)
	{
		for (int j = 0; j <= resolution.x; ++j)
		{
			Vec3 sample_point = bottom_left + delta_y * static_cast<Scalar>(i) + delta_x * static_cast<Scalar>(j);
			fetch_positions.push_back(sample_point.xy);
		}
	}

	fetch_data.resize(fetch_positions.size());

	while (fetchers.size() < min(max_fetchers, fetch_positions.size()))
	{
		Fetcher &f = fetchers.emplace_back();
		f.landscape_fetch = LandscapeFetch::create();
		f.landscape_fetch->setUsesHeight(true);
		f.landscape_fetch->setUsesAlbedo(true);
	}

	while (fetchers.size() > min(max_fetchers, fetch_positions.size()))
		fetchers.removeLast();


	next_fetch_index = 0;
	fishined_fetch_count = 0;
	for (int i = 0; i < fetchers.size(); ++i)
	{
		fetchers[i].landscape_fetch->fetchAsync(fetch_positions[next_fetch_index]);
		fetchers[i].out_data_index = next_fetch_index;



		next_fetch_index += 1;
	}

	state = State::FETCHING;
}

void TerrainMesh::update()
{
	if (draw_bounding_box)
		Visualizer::renderBox(vec3{1.0f, 1.0f, 800.0f}, node->getTransform(), vec4_white);

	if (draw_wireframe && mesh_dynamic)
	{
		Visualizer::renderObject(mesh_dynamic, vec4_white);
	}

	if (state == State::FETCHING)
	{
		for (int i = 0; i < fetchers.size(); ++i)
		{
			if (fetchers[i].landscape_fetch->isAsyncCompleted())
			{
				fishined_fetch_count += 1;

				fetch_data[fetchers[i].out_data_index].height = fetchers[i].landscape_fetch->getHeight();
				fetch_data[fetchers[i].out_data_index].albedo = fetchers[i].landscape_fetch->getAlbedo();

				if (next_fetch_index < fetch_positions.size())
				{
					fetchers[i].landscape_fetch->fetchAsync(fetch_positions[next_fetch_index]);
					fetchers[i].out_data_index = next_fetch_index;

					next_fetch_index += 1;
				}
			}
		}

		if (fishined_fetch_count == fetch_positions.size())
		{
			generate_mesh();
			state = State::IDLE;
		}
	}
}

void TerrainMesh::generate_mesh()
{
	if (!mesh_dynamic)
	{
		mesh_dynamic = ObjectMeshDynamic::create();
		mesh_dynamic->setMaterial(material_prop.get(), "*");
		mesh_dynamic->translate(Vec3(0.0f, 0.0f, 200.f));
	}

	mesh_dynamic->clearVertex();
	mesh_dynamic->clearIndices();
	mesh_dynamic->allocateVertex((resolution.x + 1) * (resolution.y + 1));
	mesh_dynamic->allocateIndices(resolution.x * resolution.y * 6);

	for (int i = 0; i <= resolution.y; ++i)
	{
		for (int j = 0; j <= resolution.x; ++j)
		{
			FetchData &data = fetch_data[(resolution.x + 1) * i + j];
			const auto &position = vec3(vec2(fetch_positions[(resolution.x + 1) * i + j]), data.height);

			mesh_dynamic->addVertex(position);
			mesh_dynamic->addColor(data.albedo);
		}
	}

	for (int i = 0; i < resolution.y; ++i)
	{
		auto pitch = resolution.x + 1;
		auto offset = pitch * i;

		for (int j = 0; j < resolution.x; ++j)
		{
			mesh_dynamic->addIndex(offset + j + 1);
			mesh_dynamic->addIndex(offset + pitch + j);
			mesh_dynamic->addIndex(offset + j);

			mesh_dynamic->addIndex(offset + j + 1);
			mesh_dynamic->addIndex(offset + pitch + j + 1);
			mesh_dynamic->addIndex(offset + pitch + j);
		}
	}

	mesh_dynamic->updateTangents();
	mesh_dynamic->updateBounds();
	mesh_dynamic->flushVertex();
	mesh_dynamic->flushIndices();

	mesh_dynamic->setTransform(mesh_dynamic->getTransform());
}

```

## TerrainMeshSample.cpp

```cpp
#include "TerrainMeshSample.h"

#include <UnigineVisualizer.h>

REGISTER_COMPONENT(TerrainMeshSample);


using namespace Unigine;
using namespace Math;

void TerrainMeshSample::init()
{
	Visualizer::setEnabled(true);
	terrain_mesh = getComponent<TerrainMesh>(terrain_mesh_prop.get());
	update_terrain_mesh_parameters();
	init_gui();
}

void TerrainMeshSample::update()
{
	status_label->setText(String::format("Status: %i/%i",
		terrain_mesh->getCompletedFetchPositions(), terrain_mesh->getTotalFetchPositions()));
}

void TerrainMeshSample::shutdown()
{
	Visualizer::setEnabled(false);
	shutdown_gui();
}

void TerrainMeshSample::update_terrain_mesh_parameters()
{
	Mat4 transform;
	composeTransform(transform, Vec3(position.x, position.y, 0), quat(0.0f, 0.0f, rotation),
		vec3(scale.x, scale.y, 1.0f));
	terrain_mesh->getNode()->setTransform(transform);

	terrain_mesh->setResolution(resolution);
	terrain_mesh->setMaxFetchers(concurrent_fetches);
}

void TerrainMeshSample::init_gui()
{
	sample_description_window.createWindow();
	window = sample_description_window.getWindow();

	auto group_box = sample_description_window.getParameterGroupBox();

	auto hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	auto label = WidgetLabel::create("Position");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("X");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	position_x_edit_line = WidgetEditLine::create(
		String::ftoa(static_cast<float>(terrain_mesh->getNode()->getPosition().x)));
	position_x_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	position_x_edit_line->getEventChanged().connect(this, &TerrainMeshSample::position_x_edit_line_callback);
	hbox->addChild(position_x_edit_line, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Y");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	position_y_edit_line = WidgetEditLine::create(
		String::ftoa(static_cast<float>(terrain_mesh->getNode()->getPosition().y)));
	position_y_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	position_y_edit_line->getEventChanged().connect(this, &TerrainMeshSample::position_y_edit_line_callback);
	hbox->addChild(position_y_edit_line, Gui::ALIGN_LEFT);


	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Size");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("X");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	size_x_edit_line = WidgetEditLine::create(String::ftoa(terrain_mesh->getNode()->getScale().x));
	size_x_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	size_x_edit_line->getEventChanged().connect(this, &TerrainMeshSample::size_x_edit_line_callback);
	hbox->addChild(size_x_edit_line, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Y");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	size_y_edit_line = WidgetEditLine::create(String::ftoa(terrain_mesh->getNode()->getScale().y));
	size_y_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	size_y_edit_line->getEventChanged().connect(this, &TerrainMeshSample::size_y_edit_line_callback);
	hbox->addChild(size_y_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Angle");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	rotation_edit_line = WidgetEditLine::create(
		String::ftoa(terrain_mesh->getNode()->getRotation().getAngle(vec3_up)));
	rotation_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	rotation_edit_line->getEventChanged().connect(this, &TerrainMeshSample::rotation_edit_line_callback);
	hbox->addChild(rotation_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Resolution");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("X");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	resolution_x_edit_line = WidgetEditLine::create(String::itoa(resolution.x));
	resolution_x_edit_line->setValidator(Gui::VALIDATOR_UINT);
	resolution_x_edit_line->getEventChanged().connect(this, &TerrainMeshSample::resolution_x_edit_line_callback);
	hbox->addChild(resolution_x_edit_line, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Y");
	hbox->addChild(label, Gui::ALIGN_LEFT);
	resolution_y_edit_line = WidgetEditLine::create(String::itoa(resolution.y));
	resolution_y_edit_line->setValidator(Gui::VALIDATOR_UINT);
	resolution_y_edit_line->getEventChanged().connect(this, &TerrainMeshSample::resolution_y_edit_line_callback);
	hbox->addChild(resolution_y_edit_line, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	label = WidgetLabel::create("Concurrent fetches");
	label->setWidth(100);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	concurrent_fetches_edit_line = WidgetEditLine::create(String::itoa(concurrent_fetches));
	concurrent_fetches_edit_line->setValidator(Gui::VALIDATOR_UINT);
	concurrent_fetches_edit_line->getEventChanged().connect(this, &TerrainMeshSample::concurrent_fetches_edit_line_callback);
	hbox->addChild(concurrent_fetches_edit_line, Gui::ALIGN_LEFT);


	draw_bounding_box_check_box = WidgetCheckBox::create("Draw Bounding Box");
	draw_bounding_box_check_box->setChecked(true);
	draw_bounding_box_check_box->getEventChanged().connect(this, &TerrainMeshSample::draw_bounding_box_check_box_callback);
	group_box->addChild(draw_bounding_box_check_box, Gui::ALIGN_LEFT);

	draw_wireframe_check_box = WidgetCheckBox::create("Draw Wireframe");
	draw_wireframe_check_box->getEventChanged().connect(this, &TerrainMeshSample::draw_wireframe_check_box_callback);
	group_box->addChild(draw_wireframe_check_box, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	auto button = WidgetButton::create("Generate");
	button->getEventClicked().connect(this, &TerrainMeshSample::generate_button_callback);
	hbox->addChild(button, Gui::ALIGN_LEFT);

	hbox = WidgetHBox::create(5);
	group_box->addChild(hbox, Gui::ALIGN_LEFT);
	status_label = WidgetLabel::create("Status: 0/0");
	hbox->addChild(status_label, Gui::ALIGN_LEFT);

	window->arrange();
}

void TerrainMeshSample::shutdown_gui()
{
	window.deleteLater();
}

void TerrainMeshSample::position_x_edit_line_callback()
{
	position.x = String::atof(position_x_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::position_y_edit_line_callback()
{
	position.y = String::atof(position_y_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::size_x_edit_line_callback()
{
	scale.x = String::atof(size_x_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::size_y_edit_line_callback()
{
	scale.y = String::atof(size_y_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::rotation_edit_line_callback()
{
	rotation = String::atof(rotation_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::resolution_x_edit_line_callback()
{
	resolution.x = String::atoi(resolution_x_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::resolution_y_edit_line_callback()
{
	resolution.y = String::atoi(resolution_y_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::concurrent_fetches_edit_line_callback()
{
	concurrent_fetches = String::atoi(concurrent_fetches_edit_line->getText());
	update_terrain_mesh_parameters();
}

void TerrainMeshSample::draw_bounding_box_check_box_callback()
{
	terrain_mesh->setDrawBoundingBox(draw_bounding_box_check_box->isChecked());
}

void TerrainMeshSample::draw_wireframe_check_box_callback()
{
	terrain_mesh->setDrawWireframe(draw_wireframe_check_box->isChecked());
}

void TerrainMeshSample::generate_button_callback()
{
	terrain_mesh->run();
}

```

## TexturesSample.cpp

```cpp
#include "TexturesSample.h"

#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(TexturesSample)

void TexturesSample::init()
{
	UNIGINE_ASSERT(meshes_param.size() == 4);

	for (int i = 0; i < 4; ++i)
	{
		ObjectPtr object = checked_ptr_cast<Object>(meshes_param[i].get());
		if (object)
		{
			meshes.push_back(object);
		}
		else
		{
			Log::warning("TexturesSample::init(): object is null");
		}
	}

	colors.push_back(ivec4(255, 255, 0, 255));
	colors.push_back(ivec4(0, 255, 255, 255));
	colors.push_back(ivec4(255, 0, 255, 255));
	colors.push_back(ivec4(255, 255, 255, 255));

	images.resize(4);
}

void TexturesSample::update()
{
	float time = Game::getTime();

	for (int i = 0; i < 4; ++i)
	{
		int offset = static_cast<int>(Math::sin(time * (0.9f + i * 0.1f)) * 127.0f + 127.0f);

		ImagePtr &image = images[i];
		if (!image)
		{
			image = Image::create();
			image->create2D(128, 128, Image::FORMAT_RGBA8);
		}

		// update image
		ivec4 color = colors[i];
		for (int y = 0; y < image->getHeight(); y++)
		{
			for (int x = 0; x < image->getWidth(); x++)
			{
				ivec4 c = color * ((x ^ y) * offset % 63) >> 6;
				image->set2D(x, y, Image::Pixel(c.x, c.y, c.z, c.w));
			}
		}

		ObjectPtr &mesh = meshes[i];
		MaterialPtr material = mesh->getMaterialInherit(0);
		int num = material->findTexture("albedo");
		if (num != -1)
		{
			material->setTextureImage(num, image);
		}
	}
}

```

## ThreadSample.cpp

```cpp
#include "ThreadSample.h"

#include <UnigineConsole.h>

#include <memory>

using namespace Unigine;
using namespace Unigine::Math;

ThreadSample::InfiniteThread::InfiniteThread() {}

ThreadSample::InfiniteThread::~InfiniteThread() {}

void ThreadSample::InfiniteThread::process()
{
	while (isRunning())
	{
		Log::message("Hello from infinite thread\n");

		sleep(1000);
	}
	Log::message("Infinite thread finished\n");
}

ThreadSample::CountedThread::CountedThread(uint32_t iterations)
	: iterations(iterations)
{}

ThreadSample::CountedThread::~CountedThread() {}

void ThreadSample::CountedThread::process()
{
	for (uint32_t i = 0; i < iterations; ++i)
	{
		Log::message("Hello from counted thread: %u\n", i);

		if (!isRunning())
			break;

		sleep(1000);
	}

	Log::message("Counted thread finished\n");
}

//-----------------Sample-----------------

REGISTER_COMPONENT(ThreadSample)

void ThreadSample::init()
{
	Console::setOnscreen(true);

	infinite_thread = std::make_unique<InfiniteThread>();
	infinite_thread->run();

	counted_thread = std::make_unique<CountedThread>(10);
	counted_thread->run();
}

void ThreadSample::update()
{
	if (!counted_thread->isRunning())
		counted_thread->stop();
}

void ThreadSample::shutdown()
{
	Console::setOnscreen(false);
	if (infinite_thread->isRunning())
		infinite_thread->stop();
	if (counted_thread->isRunning())
		counted_thread->stop();
}

```

## TopDownController.cpp

```cpp
#include "TopDownController.h"
#include "Selection.h"
#include <UnigineConsole.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(TopDownController);

using namespace Unigine;
using namespace Math;

// instantly places the camera to the specified position
void TopDownController::setPosition(const Unigine::Math::Vec3& pos)
{
	camera_pivot_position = pos;
	camera_pivot_position.z = 2.0f;
	current_camera_pivot_position = camera_pivot_position;
}

// sets the target position to which the camera approaches smoothly
void TopDownController::setTargetPosition(const Unigine::Math::Vec3& pos)
{
	camera_pivot_position = pos;
	camera_pivot_position.z = 2.0f;
}

// instantly sets the distance value for the camera
void TopDownController::setDistance(float dist)
{
	distance = dist;

	distance = clamp(distance, min_distance, max_distance);
	theta = clamp(min_theta + (distance - min_distance) * degrees_per_unit, min_theta, max_theta);

	current_distance = distance;
	current_theta = theta;
}

// sets the target distance to which the camera rolls or out smoothly
void TopDownController::setTargetDistance(float dist)
{
	distance = dist;

	distance = clamp(distance, min_distance, max_distance);
	theta = clamp(min_theta + (distance - min_distance) * degrees_per_unit, min_theta, max_theta);
}

// initialization
void TopDownController::init()
{
	// setting default values
	phi = phiProp.get();
	current_phi = phi;
	theta = thetaProp.get();
	current_theta = theta;
	min_theta = thetaMinMax.get().x;
	max_theta = thetaMinMax.get().y;

	distance = Distance.get();
	current_distance = distance;
	min_distance = distanceMinMax.get().x;
	max_distance = distanceMinMax.get().y;

	interpolation_factor = zoomSpeed.get();

	if (max_distance != min_distance)
		degrees_per_unit = (max_theta - min_theta) / (max_distance - min_distance);
	else
		degrees_per_unit = 0.0f;

	// setting up camera
	camera = checked_ptr_cast<Player>(node);
	if (!camera)
	{
		Log::error("TopDownController::init(): camera is not valid\n");
		return;
	}

	camera_pivot_position = node->getPosition();
	camera_pivot_position.z = 2.0f;
	current_camera_pivot_position = camera_pivot_position;

	// setting up input handle, mouse will not be grabbed
	Input::setMouseHandle(Input::MOUSE_HANDLE_USER);

	// setting camera to the start position
	vec3 cameraViewDirection = quat(vec3_up, current_phi) * vec3_forward;
	cameraViewDirection = quat(cross(vec3_up, cameraViewDirection), -current_theta) * cameraViewDirection * -1;
	cameraViewDirection.normalize();

	camera->setViewDirection(cameraViewDirection);
	camera->setWorldPosition(current_camera_pivot_position - Vec3(cameraViewDirection) * current_distance);

	// creating a logic node and assigning a component to it
	NodeDummyPtr logic = NodeDummy::create();
	selection = ComponentSystem::get()->addComponent<Selection>(logic);
}

void TopDownController::update()
{
	if (!camera)
		return;

	// input processing only when the Console is inactive
	if (!Console::isActive())
	{
		// when the middle mouse button is pressed, save initial vector for mouse_to_intersection_point_vector
		if (Input::isMouseButtonDown(Input::MOUSE_BUTTON::MOUSE_BUTTON_MIDDLE))
		{
			auto object = World::getIntersection(camera->getWorldPosition(), camera->getWorldPosition() + Vec3(camera->getDirectionFromMainWindow(Input::getMousePosition().x, Input::getMousePosition().y) * 10000), ~0, intersection);
			if (object)
			{
				is_previous_hooked = true;
				previous_mouse_to_intersection_point_vector = intersection->getPoint() - camera->getWorldPosition();
			}
			else
			{
				is_previous_hooked = false;
			}
		}

		// process input for zoom
		int mouseAxis = Input::getMouseWheel();
		if (mouseAxis != 0)
		{
			distance = clamp(distance - mouseAxis, min_distance, max_distance);
			theta = clamp(theta - mouseAxis * degrees_per_unit, min_theta, max_theta);
		}

		// process input for rotation around the Z axis
		if (Input::isKeyPressed(Input::KEY_Q))
			phi -= 50.0f * Game::getIFps();
		if (Input::isKeyPressed(Input::KEY_E))
			phi += 50.0f * Game::getIFps();

		// when key F is pressed and an object is selected, focus the camera selection
		if (Input::isKeyPressed(Input::KEY_F) && selection->hasSelection())
		{
			distance = selection->getBoundRadius();
			camera_pivot_position = selection->getCenter();
			camera_pivot_position.z = 2.0f;

			distance = clamp(distance, min_distance, max_distance);
			theta = clamp(min_theta + (distance - min_distance) * degrees_per_unit, min_theta, max_theta);
		}

		// if middle button is held down, update mouse_to_intersection_point_vector to move the camera
		if (Input::isMouseButtonPressed(Input::MOUSE_BUTTON::MOUSE_BUTTON_MIDDLE) && is_previous_hooked)
		{
			current_mouse_to_intersection_point_vector = Vec3(camera->getDirectionFromMainWindow(Input::getMousePosition().x, Input::getMousePosition().y));
			current_mouse_to_intersection_point_vector *= previous_mouse_to_intersection_point_vector.z / current_mouse_to_intersection_point_vector.z;

			Vec3 displacement = current_mouse_to_intersection_point_vector - previous_mouse_to_intersection_point_vector;

			camera_pivot_position -= displacement;
			current_camera_pivot_position -= displacement;
			previous_mouse_to_intersection_point_vector = current_mouse_to_intersection_point_vector;
		}
		// only when middle button is up, the player can control the camera by moving cursor to the edges of window
		else
		{
			Vec3 forward = quat(vec3_up, phi) * Vec3_forward * -1;
			forward.normalize();
			Vec3 right = quat(vec3_up, phi) * Vec3_right * -1;
			right.normalize();
			ivec2 mousePosition = Input::getMousePosition();
			auto windowPos = WindowManager::getMainWindow()->getPosition();
			auto windowSize = WindowManager::getMainWindow()->getRenderSize();

			if (mousePosition.x < windowPos.x + 10)
				camera_pivot_position -= right * 10.0f * Game::getIFps();

			if (mousePosition.y < windowPos.y + 10)
				camera_pivot_position += forward * 10.0f * Game::getIFps();

			if (mousePosition.x > windowPos.x + windowSize.x - 10)
				camera_pivot_position += right * 10.0f * Game::getIFps();

			if (mousePosition.y > windowPos.y + windowSize.y - 10)
				camera_pivot_position -= forward * 10.0f * Game::getIFps();
		}
	}

	// smooth movement and rotation of the camera to the required coordinates and angles
	current_phi = lerp(current_phi, phi, interpolation_factor * Game::getIFps());
	current_theta = lerp(current_theta, theta, interpolation_factor * Game::getIFps());
	current_distance = lerp(current_distance, distance, interpolation_factor * Game::getIFps());
	current_camera_pivot_position = lerp(current_camera_pivot_position, camera_pivot_position, interpolation_factor * Game::getIFps());
}

void TopDownController::postUpdate()
{
	// after all calculations we can move camera to the right position
	vec3 cameraViewDirection = quat(vec3_up, current_phi) * vec3_forward;
	cameraViewDirection = quat(cross(vec3_up, cameraViewDirection), -current_theta) * cameraViewDirection * -1;
	cameraViewDirection.normalize();

	camera->setViewDirection(cameraViewDirection);
	camera->setPosition(current_camera_pivot_position - Vec3(cameraViewDirection) * current_distance);
}

void TopDownController::shutdown()
{
	// letting the mouse to be grabbed
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	Visualizer::setEnabled(false);
}

```

## TouchInput.cpp

```cpp
#include "TouchInput.h"
#include "../../utils/SimpleInformationBox.h"
#include <UnigineWindowManager.h>
#include <UnigineInput.h>
#include <UnigineGame.h>

REGISTER_COMPONENT(TouchInput);

using namespace Unigine;
using namespace Math;

void TouchInput::init()
{
	info = getComponent<SimpleInformationBox>(node);

	info->setWindowTitle("Touch Input Sample");
	info->setColumnsCount(1);
	info->setWidth(300);
	info->pushBackAboutInfo("This sample demostrates the simple usage of Touch input.");

	canvas = new CanvasWithCircles();

	Game::getPlayer()->setControlled(false);
}

void TouchInput::update()
{
	canvas->clear();

	info->clearParametersInfo(0);

	int cnt = 0;
	for (int i = 0; i < Input::NUM_TOUCHES; i++)
	{
		if (Input::isTouchPressed(i))
		{
			ivec2 positionOfTouch = Input::getTouchPosition(i) - WindowManager::getMainWindow()->getPosition();

			canvas->addCircle(positionOfTouch.x, positionOfTouch.y, 32, i, "Touch " + String::itoa(i));

			info->pushBackParametersInfo(0, "Touch " + String::itoa(i), SimpleInformationBox::INFO_ALIGN::CENTER);
			info->pushBackParametersInfo(0, "X", String::itoa(positionOfTouch.x));
			info->pushBackParametersInfo(0, "Y", String::itoa(positionOfTouch.y));
			cnt++;
		}
	}

	if (cnt == 0)
		info->pushBackParametersInfo(0, "Here will be displayed information about the positions of the touches", SimpleInformationBox::INFO_ALIGN::CENTER);
}

void TouchInput::shutdown()
{
	if (canvas)
		delete canvas;

	Game::getPlayer()->setControlled(true);
}

TouchInput::CanvasWithCircles::CanvasWithCircles()
{
	canvas = WidgetCanvas::create();
	WindowManager::getMainWindow()->addChild(canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);
	radius = 50;
}

TouchInput::CanvasWithCircles::~CanvasWithCircles()
{
	canvas.deleteLater();
}

void TouchInput::CanvasWithCircles::addCircle(int x, int y, int num, int color_num, String str)
{
	int polygon = canvas->addPolygon();
	canvas->setPolygonColor(polygon, colors[color_num % number_of_colors]);
	for (int i = 0; i < num; i++)
	{
		float s = Math::sin(Consts::PI2 * i / num) * radius + x;
		float c = Math::cos(Consts::PI2 * i / num) * radius + y;
		canvas->addPolygonPoint(polygon, vec3(s, c, 0.0f));
	}

	int text = canvas->addText();
	canvas->setTextText(text, str);
	canvas->setTextSize(text, 16);
	canvas->setTextColor(text, colors[color_num % number_of_colors]);
	canvas->setTextPosition(text, vec2(x - str.size()*4.0f, y - radius*1.5f));
}

```

## TrackPlayback.cpp

```cpp
#include "TrackPlayback.h"
#include <UnigineFileSystem.h>
#include <UnigineEngine.h>
#include <UnigineGame.h>
#include "Tracker.h"

REGISTER_COMPONENT(TrackPlayback);

using namespace Unigine;
using namespace Math;

void TrackPlayback::init()
{
	if (!Tracker::isTrackerInitialized())
		return;

	// get position track id that was added to tracker in editor
	if (Tracker::containsTrack("position_track"))
	{
		position_track_id = Tracker::getTrackID("position_track");
		position_track_time = Tracker::getMinTime(position_track_id);
	}

	// get rotation track time using track name
	if (Tracker::containsTrack("rotation_track"))
		rotation_track_time = Tracker::getMinTime("rotation_track");

	// add new track to tracker
	scale_track_id = Tracker::addTrack(scale_track_path);
	if (scale_track_id != -1)
		scale_track_time = Tracker::getMinTime(scale_track_id);
}

void TrackPlayback::update()
{
	if (!Tracker::isTrackerInitialized())
		return;

	// set position track time using id
	if (position_track_id != -1)
	{
		float min_time = Tracker::getMinTime(position_track_id);
		float max_time = Tracker::getMaxTime(position_track_id);
		float unit_time = Tracker::getUnitTime(position_track_id);

		position_track_time += Game::getIFps() / unit_time;
		if (position_track_time >= max_time)
			position_track_time = min_time;

		Tracker::setTime(position_track_id, position_track_time);
	}

	// set rotation track time using track name
	if (Tracker::containsTrack("rotation_track"))
	{
		float min_time = Tracker::getMinTime("rotation_track");
		float max_time = Tracker::getMaxTime("rotation_track");
		float unit_time = Tracker::getUnitTime("rotation_track");

		rotation_track_time += Game::getIFps() / unit_time;
		if (rotation_track_time >= max_time)
			rotation_track_time = min_time;

		Tracker::setTime("rotation_track", rotation_track_time);
	}

	// update scale track time
	if (scale_track_id != -1)
	{
		float min_time = Tracker::getMinTime(scale_track_id);
		float max_time = Tracker::getMaxTime(scale_track_id);
		float unit_time = Tracker::getUnitTime(scale_track_id);

		scale_track_time += Game::getIFps() / unit_time;
		if (scale_track_time >= max_time)
			scale_track_time = min_time;

		Tracker::setTime(scale_track_id, scale_track_time);
	}
}

```

## TrackSpawner.cpp

```cpp
#include "TrackSpawner.h"

#include <UnigineWorld.h>

REGISTER_COMPONENT(TrackSpawner);

using namespace Unigine;
using namespace Math;


void TrackSpawner::setMaxNumberOfTracks(int max_number)
{
	for (const auto &track : active_tracks)
		track.deleteLater();
	active_tracks.clear();
	max_number_of_tracks = max_number;
	next_active_track_to_reuse = 0;
}

void TrackSpawner::init()
{
	setMinDistanceBetweenTracks(min_distance_between_tracks_param.get());
	setMaxNumberOfTracks(max_number_of_tracks_param.get());
}

void TrackSpawner::update()
{
	if (max_number_of_tracks == 0)
		return;

	auto world_position = node->getWorldPosition();
	auto distance2 = (last_track_position - world_position).length2();

	if (distance2 < min_distance_between_tracks * min_distance_between_tracks)
		return;

	last_track_position = world_position;

	NodePtr current_track;
	if (active_tracks.size() < max_number_of_tracks)
	{
		current_track = World::loadNode(track_node.get());
		active_tracks.push_back(current_track);
	}
	else
	{
		current_track = active_tracks[next_active_track_to_reuse];
		next_active_track_to_reuse = (next_active_track_to_reuse + 1) % active_tracks.size();
	}

	current_track->setTransform(node->getWorldTransform());
}

```

## TrackedVehicleNonPhysical.cpp

```cpp
#include "TrackedVehicleNonPhysical.h"

#include <UnigineGame.h>
#include <UnigineConsole.h>

#include "../../utils/InputManager.h"
#include "NonPhysicalTracks.h"

REGISTER_COMPONENT(TrackedVehicleNonPhysical);

using namespace Unigine;
using namespace Math;

const float MaxWheelAngularDamping = 380.f;
const float MinWheelAngularDamping = 1.f;
const float WheelAngularDampingIncreaseSpeed = 80.f;
const float WheelAngularDampingDecreaseSpeed = 320.f;
const float MaxWheelTorque = 4;


void TrackedVehicleNonPhysical::init()
{
	if (input_manager_node.nullCheck())
		Log::error("TrackedVehicleNonPhysical::init(): Input Manager Node is not set\n");

	input = ComponentSystem::get()->getComponentInChildren<InputManager>(input_manager_node);
	if (!input)
		Log::error("TrackedVehicleNonPhysical::init(): Input Manager Node does not contain InputManager component\n");

	// disable collision/intersection flags
	std::function<void(const NodePtr &)> disable_intersections = [&, this](const NodePtr &n) {
		if (!n)
			return;

		if (n->isObject())
		{
			ObjectPtr obj = static_ptr_cast<Object>(n);
			for (int i = 0; i < obj->getNumSurfaces(); i++)
			{
				obj->setIntersection(false, i);
				obj->setCollision(false, i);
				obj->setPhysicsIntersection(false, i);
			}
		}

		if (n->getType() == Node::NODE_REFERENCE)
			disable_intersections(static_ptr_cast<NodeReference>(n)->getReference());

		for (int i = 0; i < n->getNumChildren(); i++)
			disable_intersections(n->getChild(i));
	};
	disable_intersections(node);

	// convert values
	acceleration = acceleration * Consts::PI;
	deceleration = deceleration * Consts::PI;
	wheel_max_angular_speed = (max_speed / 3.6f) * Consts::PI;
	wheel_max_back_angular_speed = (max_back_speed / 3.6f) * Consts::PI;

	// set up physics
	body = node->getObjectBodyRigid();
	body->setFrozenLinearVelocity(0.3f);
	body->setAngularDamping(angular_damping);
	body->setLinearDamping(1.f);

	wheels_left_pos.resize(wheels_left.size());
	for (int i = 0; i < wheels_left.size(); i++)
	{
		configure_wheel(wheels_left[i], wheels_left_physics, wheels_left_joint);
		wheels_left_pos[i] = wheels_left[i]->getPosition();
	}
	wheels_right_pos.resize(wheels_right.size());
	for (int i = 0; i < wheels_right.size(); i++)
	{
		configure_wheel(wheels_right[i], wheels_right_physics, wheels_right_joint);
		wheels_right_pos[i] = wheels_right[i]->getPosition();
	}

	// find all tracks
	getComponentsInChildren<NonPhysicalTracks>(node, tracks);
	last_pos = node->getWorldPosition();
}

void TrackedVehicleNonPhysical::update()
{
	if (!input)
		return;

	float ifps = Game::getIFps();
	
	throttle = 0;
	turn = 0;

	if (!Console::isActive())
	{
		throttle = input->getThrottle();
		turn = input->getTurn();
	}

	// speed calculations
	wheel_angular_speed += throttle * ifps * acceleration;
	if (throttle == 0 || Math::sign(throttle) != Math::sign(wheel_angular_speed))
	{
		wheel_angular_speed = -wheel_angular_speed <= ifps * deceleration ? 0
			: wheel_angular_speed - Math::sign(wheel_angular_speed) * ifps * deceleration;
		if (turn == 0)
			current_wheels_angular_damping += ifps * WheelAngularDampingIncreaseSpeed;
		else
			current_wheels_angular_damping = MinWheelAngularDamping;
	}
	else
		current_wheels_angular_damping -= ifps * WheelAngularDampingDecreaseSpeed;

	wheel_angular_speed = clamp(wheel_angular_speed, -wheel_max_back_angular_speed, wheel_max_angular_speed);
	turn_smooth = lerp(turn_smooth, turn * Math::sign(wheel_angular_speed), turn_smooth_factor * ifps);
	current_wheels_angular_damping = clamp(current_wheels_angular_damping, MinWheelAngularDamping, MaxWheelAngularDamping);

	// update wheels
	Vec3 new_pos = node->getWorldPosition();
	Vec3 offset = node->getIWorldTransform() * last_pos;
	float offset_left = static_cast<float>(offset.y - turn_smooth * ifps * 2.0f);
	float offset_right = static_cast<float>(offset.y + turn_smooth * ifps * 2.0f);

	for (int i = 0; i < wheels_left.size(); i++)
	{
		wheels_left[i]->setRotation(wheels_left[i]->getRotation()
			* quat(0, -360.0f * offset_left / (2.0f * Consts::PI * wheels_left_joint[i]->getWheelRadius()), 0));
		wheels_left_pos[i].z = wheels_left_physics[i]->getPosition().z;
		wheels_left[i]->setPosition(wheels_left_pos[i]);
	}

	for (int i = 0; i < wheels_right.size(); i++)
	{
		wheels_right[i]->setRotation(wheels_right[i]->getRotation()
			* quat(0, -360.0f * offset_right / (2.0f * Consts::PI * wheels_right_joint[i]->getWheelRadius()), 0));
		wheels_right_pos[i].z = wheels_right_physics[i]->getPosition().z;
		wheels_right[i]->setPosition(wheels_right_pos[i]);
	}
	
	last_pos = new_pos;

	// update tracks
	for (int i = 0; i < tracks.size(); i++)
		tracks[i]->setOffset(tracks[i]->side.get() == 0 /*left*/ ? -offset_left : -offset_right);
}

void TrackedVehicleNonPhysical::updatePhysics()
{
	float torque = clamp(float(fabs(wheel_angular_speed)) * 0.3f, 0.f, MaxWheelTorque);

	// move forward/backward
	for (int i = 0; i < wheels_left_joint.size(); i++)
	{
		wheels_left_joint[i]->setAngularDamping(current_wheels_angular_damping);
		wheels_left_joint[i]->setAngularVelocity(wheel_angular_speed);
		wheels_left_joint[i]->setAngularTorque(torque);
	}

	for (int i = 0; i < wheels_right_joint.size(); i++)
	{
		wheels_right_joint[i]->setAngularDamping(current_wheels_angular_damping);
		wheels_right_joint[i]->setAngularVelocity(wheel_angular_speed);
		wheels_right_joint[i]->setAngularTorque(torque);
	}

	// turn left/right
	vec3 ang_vel = body->getAngularVelocity();
	body->setAngularVelocity(vec3(ang_vel.x, ang_vel.y, -turn_speed * turn_smooth * Physics::getIFps()));
}

void TrackedVehicleNonPhysical::shutdown()
{
	for (int i = 0; i < wheels_left_joint.size(); i++)
	{
		wheels_left_joint[i].deleteLater();
		wheels_left_physics[i].deleteLater();
	}
	wheels_left_joint.clear();
	wheels_left_physics.clear();

	for (int i = 0; i < wheels_right_joint.size(); i++)
	{
		wheels_right_joint[i].deleteLater();
		wheels_right_physics[i].deleteLater();
	}
	wheels_right_joint.clear();
	wheels_right_physics.clear();
}

void TrackedVehicleNonPhysical::configure_wheel(const NodePtr &wheel_node,
	Vector<NodePtr> &physics_vector, Vector<JointWheelPtr> &joints_vector)
{
	float radius = (wheel_node->getBoundBox().maximum - wheel_node->getBoundBox().minimum).z / 2.0f;

	ObjectDummyPtr dummy = ObjectDummy::create();
	dummy->setParent(wheel_node->getParent());
	dummy->setWorldTransform(wheel_node->getWorldTransform());
	
	JointWheelPtr joint = JointWheel::create(body, BodyRigid::create(dummy));
	joint->setWorldAxis1(wheel_node->getWorldDirection(Math::AXIS_NY));

	joint->setWheelMass(wheel_mass);
	joint->setLinearSpring(wheel_linear_spring);
	joint->setLinearDamping(wheel_linear_damping);
	joint->setWheelRadius(radius + track_height);
	joint->setTangentFriction(wheel_tangent_friction);
	joint->setTangentAngle(wheel_tangent_angle);
	joint->setBinormalFriction(wheel_binormal_friction);
	joint->setBinormalAngle(wheel_binormal_angle);
	joint->setNumIterations(wheel_num_iterations);

	joint->setAngularTorque(MaxWheelTorque);
	joint->setAngularVelocity(0);

	joint->setLinearRestitution(0.4f);
	joint->setAngularRestitution(0.1f);

	joint->setLinearLimitFrom(wheel_linear_limit_from);
	joint->setLinearLimitTo(wheel_linear_limit_to);
	joint->setLinearDistance(wheel_linear_distance);

	physics_vector.append(dummy);
	joints_vector.append(joint);
}

```

## TrackedVehiclePhysical.cpp

```cpp
#include "TrackedVehiclePhysical.h"

#include <UnigineGame.h>
#include <UnigineConsole.h>

#include "../../utils/InputManager.h"

REGISTER_COMPONENT(TrackedVehiclePhysical);

using namespace Unigine;
using namespace Math;

const float MaxWheelAngularDamping = 380.f;
const float MinWheelAngularDamping = 1.f;
const float WheelAngularDampingIncreaseSpeed = 80.f;
const float WheelAngularDampingDecreaseSpeed = 320.f;
const float MaxWheelTorque = 5;


void TrackedVehiclePhysical::init()
{
	if (input_manager_node.nullCheck())
		Log::error("TrackedVehiclePhysical::init(): Input Manager Node is not set\n");

	input = ComponentSystem::get()->getComponentInChildren<InputManager>(input_manager_node);
	if (!input)
		Log::error("TrackedVehiclePhysical::init(): Input Manager Node does not contain InputManager\n");

	// disable collision/intersection flags
	std::function<void(const NodePtr &)> disable_intersections = [&, this](const NodePtr &n) {
		if (!n)
			return;
		
		if (n->isObject())
		{
			ObjectPtr obj = static_ptr_cast<Object>(n);
			for (int i = 0; i < obj->getNumSurfaces(); i++)
			{
				obj->setIntersection(false, i);
				obj->setCollision(false, i);
				obj->setPhysicsIntersection(false, i);
			}
		}
		
		if (n->getType() == Node::NODE_REFERENCE)
			disable_intersections(static_ptr_cast<NodeReference>(n)->getReference());
		
		for (int i = 0; i < n->getNumChildren(); i++)
			disable_intersections(n->getChild(i));
	};
	disable_intersections(node);

	// convert values
	acceleration = acceleration * Consts::PI;
	deceleration = deceleration * Consts::PI;
	wheel_max_angular_speed = (max_speed / 3.6f) * Consts::PI;
	wheel_max_back_angular_speed = (max_back_speed / 3.6f) * Consts::PI;

	// set up physics
	body = node->getObjectBodyRigid();
	body->setFrozenLinearVelocity(0.3f);
	body->setAngularDamping(angular_damping);
	body->setLinearDamping(1.f);

	for (int i = 0; i < wheels_left.size(); i++)
		configure_wheel(wheels_left[i], wheels_left_joint);

	for (int i = 0; i < wheels_right.size(); i++)
		configure_wheel(wheels_right[i], wheels_right_joint);
}

void TrackedVehiclePhysical::update()
{
	if (!input)
		return;

	float ifps = Game::getIFps();
	
	throttle = 0;
	turn = 0;

	if (!Console::isActive())
	{
		throttle = input->getThrottle();
		turn = input->getTurn();
	}

	// speed calculations
	wheel_angular_speed += throttle * ifps * acceleration;

	if (throttle == 0 || Math::sign(throttle) != Math::sign(wheel_angular_speed))
	{
		wheel_angular_speed = -wheel_angular_speed <= ifps * deceleration ? 0
			: wheel_angular_speed - Math::sign(wheel_angular_speed) * ifps * deceleration;
		if (turn == 0)
			current_wheels_angular_damping += ifps * WheelAngularDampingIncreaseSpeed;
		else
			current_wheels_angular_damping = MinWheelAngularDamping;
	}
	else
		current_wheels_angular_damping -= ifps * WheelAngularDampingDecreaseSpeed;

	wheel_angular_speed = clamp(wheel_angular_speed, -wheel_max_back_angular_speed, wheel_max_angular_speed);
	turn_smooth = lerp(turn_smooth, turn * Math::sign(wheel_angular_speed), turn_smooth_factor * ifps);
	current_wheels_angular_damping = clamp(current_wheels_angular_damping, MinWheelAngularDamping, MaxWheelAngularDamping);
}

void TrackedVehiclePhysical::updatePhysics()
{
	float torque = clamp(float(fabs(wheel_angular_speed)) * 0.3f, 0.f, MaxWheelTorque);

	// move forward/backward
	for (int i = 0; i < wheels_left_joint.size(); i++)
	{
		wheels_left_joint[i]->setAngularDamping(current_wheels_angular_damping);
		wheels_left_joint[i]->setAngularVelocity(wheel_angular_speed);
		wheels_left_joint[i]->setAngularTorque(torque);
	}

	for (int i = 0; i < wheels_right_joint.size(); i++)
	{
		wheels_right_joint[i]->setAngularDamping(current_wheels_angular_damping);
		wheels_right_joint[i]->setAngularVelocity(wheel_angular_speed);
		wheels_right_joint[i]->setAngularTorque(torque);
	}

	// turn left/right
	vec3 ang_vel = body->getAngularVelocity();
	body->setAngularVelocity(vec3(ang_vel.x, ang_vel.y, -turn_speed * turn_smooth * Physics::getIFps()));
}

void TrackedVehiclePhysical::shutdown()
{
	for (int i = 0; i < wheels_left_joint.size(); i++)
		wheels_left_joint[i].deleteLater();
	wheels_left_joint.clear();

	for (int i = 0; i < wheels_right_joint.size(); i++)
		wheels_right_joint[i].deleteLater();
	wheels_right_joint.clear();
}

void TrackedVehiclePhysical::configure_wheel(const NodePtr &wheel_node, Vector<JointHingePtr> &joints_vector)
{
	JointHingePtr joint = checked_ptr_cast<JointHinge>(wheel_node->getObjectBodyRigid()->getJoint(0));

	joint->setNumIterations(wheel_num_iterations);
	joint->setAngularTorque(MaxWheelTorque);
	joint->setAngularVelocity(0);
	joint->setAngularSpring(wheel_spring);

	joint->setLinearRestitution(0.4f);
	joint->setAngularRestitution(0.1f);

	joints_vector.append(joint);
}

```

## Tracker.cpp

```cpp
#include "Tracker.h"
#include <UnigineFileSystem.h>
#include <UnigineEngine.h>

REGISTER_COMPONENT(Tracker);

using namespace Unigine;
using namespace Math;

bool Tracker::is_wrapper_loaded = false;

const Variable Tracker::init_func = Variable("TrackerWrapper::init");
const Variable Tracker::shutdown_func = Variable("TrackerWrapper::shutdown");
const Variable Tracker::add_track_func = Variable("TrackerWrapper::addTrack");
const Variable Tracker::remove_track_func = Variable("TrackerWrapper::removeTrack");
const Variable Tracker::get_min_time_func = Variable("TrackerWrapper::getMinTime");
const Variable Tracker::get_max_time_func = Variable("TrackerWrapper::getMaxTime");
const Variable Tracker::get_unit_time_func = Variable("TrackerWrapper::getUnitTime");
const Variable Tracker::set_func = Variable("TrackerWrapper::set");

Map<String, int> Tracker::track_ids;

Variable Tracker::track_file_var = Variable("");
Variable Tracker::track_id_var = Variable(0);
Variable Tracker::time_var = Variable(0.0f);

bool Tracker::is_initialized = false;

int Tracker::addTrack(const char *track_file)
{
	if (isTrackerInitialized() && FileSystem::isFileExist(track_file) &&
		!String::compare(FileSystem::getExtension(track_file), "track"))
	{
		auto track_name = String::split(track_file, ".")[0];
		auto parts = String::split(track_name, "/");
		track_name = parts[parts.size() - 1];

		if (!track_ids.contains(track_name))
		{
			track_file_var.setString(track_file);
			int track_id = Engine::get()->runWorldFunction(add_track_func, track_file_var).getInt();
			track_ids.insert(track_name, track_id);

			return track_id;
		}
		else
		{
			Log::warning("Tracker::addTrack: %s already added\n", track_file);
			return track_ids[track_name];
		}
	}

	return -1;
}

void Tracker::removeTrack(int track_id)
{
	if (isTrackerInitialized())
	{
		auto it = track_ids.findData(track_id);
		if (it != track_ids.end())
		{
			track_id_var.setInt(track_id);
			Engine::get()->runWorldFunction(remove_track_func, track_id_var);

			track_ids.remove(it);
		}
	}
}

void Tracker::removeTrack(const char* track_name)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		removeTrack(track_ids[track_name]);
}

bool Tracker::containsTrack(const char* track_name)
{
	if (isTrackerInitialized())
		return track_ids.contains(track_name);

	return false;
}

int Tracker::getTrackID(const char* track_name)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		return track_ids[track_name];

	return -1;
}

float Tracker::getMinTime(int track_id)
{
	if (isTrackerInitialized())
	{
		track_id_var.setInt(track_id);
		return Engine::get()->runWorldFunction(get_min_time_func, track_id_var).getFloat();
	}

	return 0.0f;
}

float Tracker::getMinTime(const char* track_name)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		return getMinTime(track_ids[track_name]);

	return 0.0f;
}

float Tracker::getMaxTime(int track_id)
{
	if (isTrackerInitialized())
	{
		track_id_var.setInt(track_id);
		return Engine::get()->runWorldFunction(get_max_time_func, track_id_var).getFloat();
	}

	return 0.0f;
}

float Tracker::getMaxTime(const char* track_name)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		return getMaxTime(track_ids[track_name]);

	return 0.0f;
}

float Tracker::getUnitTime(int track_id)
{
	if (isTrackerInitialized())
	{
		track_id_var.setInt(track_id);
		return Engine::get()->runWorldFunction(get_unit_time_func, track_id_var).getFloat();
	}

	return 0.0f;
}

float Tracker::getUnitTime(const char* track_name)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		return getUnitTime(track_ids[track_name]);

	return 0.0f;
}

void Tracker::setTime(int track_id, float time)
{
	if (isTrackerInitialized())
	{
		time_var.setFloat(time);
		track_id_var.setInt(track_id);
		Engine::get()->runWorldFunction(set_func, track_id_var, time_var);
	}
}

void Tracker::setTime(const char* track_name, float time)
{
	if (isTrackerInitialized() && track_ids.contains(track_name))
		setTime(track_ids[track_name], time);
}

void Tracker::init()
{
	// check tracker wrapper
	String tracker_wrapper_guid = FileSystem::guidToPath(FileSystem::getGUID(tracker_wrapper_usc));
	is_wrapper_loaded = (String::compare(World::getScriptName(), tracker_wrapper_guid) == 0);

	// add tracker_wrapper to world logic if not set in editor
	if (!is_wrapper_loaded)
	{
		World::setScriptName(tracker_wrapper_guid);
		World::setScriptExecute(true);
		World::saveWorld();
		World::reloadWorld();
		return;
	}

	// init tracker in wrapper
	Engine::get()->runWorldFunction(init_func);
	is_initialized = true;

	if (!track_files.nullCheck())
	{
		for (int i = 0; i < track_files.size(); i++)
			addTrack(track_files[i].get());
	}
}

void Tracker::shutdown()
{
	if (isTrackerInitialized())
	{
		Engine::get()->runWorldFunction(shutdown_func);

		track_ids.clear();
		is_wrapper_loaded = false;
		is_initialized = false;
	}
}

```

## TracksSample.cpp

```cpp
#include "TracksSample.h"

REGISTER_COMPONENT(TracksSample);

using namespace Unigine;
using namespace Math;

void TracksSample::init()
{
	getComponentsInChildren<TrackSpawner>(getNode(), track_spawners);

	init_gui();
}

void TracksSample::shutdown()
{
	shutdown_gui();
}

void TracksSample::init_gui()
{
	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();

	auto hbox = WidgetHBox::create(4);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);

	auto label = WidgetLabel::create("Min distance between track maps");
	label->setWidth(200);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	min_distance_edit_line = WidgetEditLine::create("0.1");
	min_distance_edit_line->setValidator(Gui::VALIDATOR_FLOAT);
	min_distance_edit_line->getEventChanged().connect(this, &TracksSample::min_distance_edit_line_callback);
	hbox->addChild(min_distance_edit_line, Gui::ALIGN_LEFT);


	hbox = WidgetHBox::create(4);
	parameters->addChild(hbox, Gui::ALIGN_LEFT);

	label = WidgetLabel::create("Max number of track maps");
	label->setWidth(200);
	hbox->addChild(label, Gui::ALIGN_LEFT);
	max_number_edit_line = WidgetEditLine::create("100");
	max_number_edit_line->setValidator(Gui::VALIDATOR_UINT);
	max_number_edit_line->getEventChanged().connect(this, &TracksSample::max_number_edit_line_callback);
	hbox->addChild(max_number_edit_line, Gui::ALIGN_LEFT);

}

void TracksSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void TracksSample::min_distance_edit_line_callback()
{
	float value = String::atof(min_distance_edit_line->getText());
	for (auto track_spawner : track_spawners)
	{
		track_spawner->setMinDistanceBetweenTracks(value);
	}
}

void TracksSample::max_number_edit_line_callback()
{
	int value = String::atoi(max_number_edit_line->getText());
	for (auto track_spawner : track_spawners)
	{
		track_spawner->setMaxNumberOfTracks(value);
	}
}

```

## TrajectoryLogic.cpp

```cpp
#include "TrajectoryLogic.h"

#include "TrajectoryMovement.h"
#include "UnigineVisualizer.h"
#include "UnigineGame.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(TrajectoryLogic);

void TrajectoryLogic::init()
{
	Game::getMainPlayers(main_players);

	UNIGINE_ASSERT(main_players.size() >= (TOTAL_PLAYERS - 1));
	Game::setPlayer(main_players[current_player]);

	init_gui();
	Visualizer::setEnabled(true);
}

void TrajectoryLogic::update() {}

void TrajectoryLogic::shutdown()
{
	sample_description_window.shutdown();
	Visualizer::setEnabled(false);
}

void TrajectoryLogic::init_gui()
{

	sample_description_window.createWindow();

	sample_description_window.addFloatParameter("Velocity", "Velicity", 5.f, 1.f, 50.f, [this](float v) {
		getComponent<SimpleTrajectoryMovement>(airplane_1)->velocity = v;
		getComponent<SplineTrajectoryMovement>(airplane_2)->velocity = v;
		getComponent<SavedPathTrajectory>(airplane_3)->velocity = v;
	});

	auto parameters = sample_description_window.getParameterGroupBox();

	auto change_camera_button = WidgetButton::create();
	parameters->addChild(change_camera_button, Gui::ALIGN_LEFT);
	change_camera_button->setText("Switch Camera");
	change_camera_button->getEventClicked().connect(this, &TrajectoryLogic::switch_trajectory_callback);

	auto gridbox = WidgetGridBox::create();
	parameters->addChild(gridbox, Gui::ALIGN_LEFT);
	enable_visualize_path = WidgetCheckBox::create();
	enable_visualize_path->setChecked(false);
	enable_visualize_path->getEventClicked().connect(this,  &TrajectoryLogic::enable_visualize_callback);
	auto visualize_label = WidgetLabel::create("Visualize Path");
	gridbox->addChild(visualize_label);
	gridbox->addChild(enable_visualize_path);
}

void TrajectoryLogic::update_velocity_callback()
{
	int new_velocity = velocity_widget->getValue();

	velocity_value_label->setText(String::itoa(new_velocity));

	getComponent<SimpleTrajectoryMovement>(airplane_1)->velocity = (float)new_velocity;
	getComponent<SplineTrajectoryMovement>(airplane_2)->velocity = (float)new_velocity;
	getComponent<SavedPathTrajectory>(airplane_3)->velocity = (float)new_velocity;
}

void TrajectoryLogic::switch_trajectory_callback()
{
	current_player = Players((int(current_player) + 1) % TOTAL_PLAYERS);
	Game::setPlayer(main_players[current_player]);
}

void TrajectoryLogic::enable_visualize_callback()
{
	bool enabled = enable_visualize_path->isChecked();
	getComponent<SimpleTrajectoryMovement>(airplane_1)->debug = enabled;
	getComponent<SplineTrajectoryMovement>(airplane_2)->debug = enabled;
	getComponent<SavedPathTrajectory>(airplane_3)->debug = enabled;
}

```

## TrajectoryMovement.cpp

```cpp
#include "TrajectoryMovement.h"

#include "../../utils/Math.h"
#include "UnigineGame.h"
#include "UnigineVisualizer.h"

#include <UniginePrimitives.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(SimpleTrajectoryMovement);
REGISTER_COMPONENT(SplineTrajectoryMovement);
REGISTER_COMPONENT(PathTrajectorySaver);
REGISTER_COMPONENT(SavedPathTrajectory);

void SimpleTrajectoryMovement::init()
{
	UNIGINE_ASSERT(!path_node.nullCheck());

	// save positions and rotations
	int num_childs = path_node->getNumChildren();
	for (int i = 0; i < num_childs; i++)
	{
		NodePtr nc = path_node->getChild(i);
		points_pos.emplace_back(nc->getWorldPosition());
		points_rot.emplace_back(nc->getWorldRotation());
	}
	prev_point = node->getWorldPosition();
}

void SimpleTrajectoryMovement::update()
{
	// update time
	update_time();

	// set position and rotation
	node->setWorldPosition(lerp(prev_point, points_pos[points_index], time));
	node->setWorldRotation(slerp(prev_rot, points_rot[points_index], time));

	// visualize path if enabled
	if (debug.get())
		visualize_path();
}

void SimpleTrajectoryMovement::visualize_path()
{
	for (int i = 0; i < points_pos.size(); i++)
	{
		int next = (i + 1) % points_pos.size();
		Visualizer::renderLine3D(points_pos[i], points_pos[next], vec4_white);
	}
}

void SimpleTrajectoryMovement::update_time()
{
	float len = (float)length(points_pos[points_index] - prev_point);

	// update time with stable velocity
	time += velocity / len * Game::getIFps();
	if (time >= 1.0f)
	{
		prev_point = points_pos[points_index];
		prev_rot = points_rot[points_index];

		// next point
		points_index = (points_index + ftoi(time)) % points_pos.size();
		time = Math::frac(time);
	}
}

void SplineTrajectoryMovement::init()
{
	UNIGINE_ASSERT(!pathNode.nullCheck());

	// save positions and rotations
	int num_childs = pathNode->getNumChildren();
	for (int i = 0; i < num_childs; i++)
	{
		NodePtr nc = pathNode->getChild(i);
		points_pos.emplace_back(nc->getWorldPosition());
		points_rot.emplace_back(nc->getWorldRotation());
	}

	// save the length of the spline segments to calculate the stable speed
	lengths.clear();
	int points_count = points_pos.size();
	for (int j = 0; j < points_count; j++)
	{
		int j_prev = (j - 1 < 0) ? (points_count - 1) : j - 1;
		int j_cur = j;
		int j_next = (j + 1) % points_count;
		int j_next_next = (j + 2) % points_count;

		const Vec3& p0 = points_pos[j_prev];
		const Vec3& p1 = points_pos[j_cur];
		const Vec3& p2 = points_pos[j_next];
		const Vec3& p3 = points_pos[j_next_next];

		lengths.append(Utils::getLengthCatmullRomCentripetal(p0, p1, p2, p3, quality));
	}
}

void SplineTrajectoryMovement::update()
{
	// update time
	float speed = velocity / (lengths[points_index][int(time * (quality - 1))] * quality);
	update_time(speed);

	// get current control points
	VectorStack<Vec3, 4> p = get_current_points();
	VectorStack<quat, 4> q = get_current_quats();

	// spline calculations
	Vec3 pos = Utils::catmullRomCentripetal(p[0], p[1], p[2], p[3], time);
	quat rot = Utils::squad(q[0], q[1], q[2], q[3], time);

	// change node pos
	node->setWorldPosition(pos);
	node->setWorldRotation(rot, true);

	if (debug.get())
		visualize_path();
}

void SplineTrajectoryMovement::visualize_path()
{
	int points_count = points_pos.size();
	for (int j = 0; j < points_count; j++)
	{
		int j_prev = (j - 1 < 0) ? (points_count - 1) : j - 1;
		int j_cur = j;
		int j_next = (j + 1) % points_count;
		int j_next_next = (j + 2) % points_count;

		const Vec3& p0 = points_pos[j_prev];
		const Vec3& p1 = points_pos[j_cur];
		const Vec3& p2 = points_pos[j_next];
		const Vec3& p3 = points_pos[j_next_next];

		// draw curve
		Vec3 start = Utils::catmullRomCentripetal(p0, p1, p2, p3, 0);
		int quality = 10;
		for (int i = 1; i < quality; i++)
		{
			Vec3 end = Utils::catmullRomCentripetal(p0, p1, p2, p3, float(i) / (quality - 1));
			Visualizer::renderLine3D(start, end, vec4_white);
			start = end;
		}
	}
}

void SplineTrajectoryMovement::update_time(float speed)
{
	time += speed * Game::getIFps();
	if (time >= 1.0f)
	{
		points_index = (points_index + ftoi(time)) % points_pos.size(); // loop
		time = Math::frac(time);
	}
}

VectorStack<Vec3, 4> SplineTrajectoryMovement::get_current_points() const
{
	int points_count = points_pos.size();
	int i_prev = (points_index - 1 < 0) ? (points_count - 1) : points_index - 1;
	int i_cur = points_index;
	int i_next = (points_index + 1) % points_count;
	int i_next_next = (points_index + 2) % points_count;

	VectorStack<Vec3, 4> result;
	result.append(points_pos[i_prev]);
	result.append(points_pos[i_cur]);
	result.append(points_pos[i_next]);
	result.append(points_pos[i_next_next]);
	return result;
}

VectorStack<quat, 4> SplineTrajectoryMovement::get_current_quats() const
{
	int points_count = points_pos.size();
	int i_prev = (points_index - 1 < 0) ? (points_count - 1) : points_index - 1;
	int i_cur = points_index;
	int i_next = (points_index + 1) % points_count;
	int i_next_next = (points_index + 2) % points_count;

	VectorStack<quat, 4> result;
	result.append(points_rot[i_prev]);
	result.append(points_rot[i_cur]);
	result.append(points_rot[i_next]);
	result.append(points_rot[i_next_next]);
	return result;
}


void PathTrajectorySaver::init()
{
	UNIGINE_ASSERT(!path_file.nullCheck());
	UNIGINE_ASSERT(!path_node.nullCheck());

	// calculate and save spline in .path file
	if (autosave.get())
		save();
}

void PathTrajectorySaver::save()
{
	PathPtr path = Path::create();
	path->clear();

	int points_count = path_node->getNumChildren();
	double frame_time = 0;
	for (int j = 0; j < points_count; j++)
	{
		int j_prev = (j - 1 < 0) ? (points_count - 1) : j - 1;
		int j_cur = j;
		int j_next = (j + 1) % points_count;
		int j_next_next = (j + 2) % points_count;

		// get current control position and rotation
		const Vec3 p0 = path_node->getChild(j_prev)->getWorldPosition();
		const Vec3 p1 = path_node->getChild(j_cur)->getWorldPosition();
		const Vec3 p2 = path_node->getChild(j_next)->getWorldPosition();
		const Vec3 p3 = path_node->getChild(j_next_next)->getWorldPosition();

		const quat q0 = path_node->getChild(j_prev)->getWorldRotation();
		const quat q1 = path_node->getChild(j_cur)->getWorldRotation();
		const quat q2 = path_node->getChild(j_next)->getWorldRotation();
		const quat q3 = path_node->getChild(j_next_next)->getWorldRotation();

		// calculate curve
		Vec3 start = Utils::catmullRomCentripetal(p0, p1, p2, p3, 0);
		for (int i = 1; i < quality; i++)
		{
			path->addFrame();

			float time = float(i) / (quality - 1);

			// calculate segment position and rotation
			Vec3 end = Utils::catmullRomCentripetal(p0, p1, p2, p3, time);
			quat rot = Utils::squad(q0, q1, q2, q3, time);

			// calculate current frame time
			double len = length(start - end);
			frame_time += len;

			path->setFramePosition(path->getNumFrames() - 1, end);
			path->setFrameRotation(path->getNumFrames() - 1, rot);
			path->setFrameTime(path->getNumFrames() - 1, static_cast<float>(frame_time));

			start = end;
		}
	}

	// save to file
	path->save(path_file.get());
}

void SavedPathTrajectory::init()
{
	node->setWorldPosition(Vec3(0, 0, 0));

	transform_path = WorldTransformPath::create(trajectory_file_path);
	transform_path->setLoop(1);
	transform_path->setTime(0.0f);
	transform_path->setSpeed(velocity);
	transform_path->play();
	transform_path->addChild(node);
}

void SavedPathTrajectory::update()
{
	transform_path->setSpeed(velocity);

	if (debug.get())
		visualize_path();
}

void SavedPathTrajectory::visualize_path()
{
	PathPtr path = transform_path->getPath();
	int num_frames = path->getNumFrames();
	for (int i = 0; i < num_frames; i++)
	{
		Vec3 curr_point = path->getFramePosition(i);
		Vec3 next_point = path->getFramePosition((i + 1) % num_frames);

		Visualizer::renderLine3D(curr_point, next_point, vec4_white);
	}
}

```

## TreeBox.cpp

```cpp
#include "TreeBox.h"
#include <UnigineConsole.h>

REGISTER_COMPONENT(TreeBox);

using namespace Unigine;
using namespace Math;

void TreeBox::init()
{
	gui = WindowManager::getMainWindow()->getGui();

	widget_treebox = WidgetTreeBox::create(gui);

	gui->addChild(widget_treebox, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	widget_treebox->setPosition(position.get().x, position.get().y);
	widget_treebox->setFontSize(font_size.get());
	widget_treebox->setFontOutline(1);

	// add first parent and children
	widget_treebox->addItem("parent 0");
	widget_treebox->addItem("child 0");
	widget_treebox->addItem("child 1");
	widget_treebox->addItem("child 2");
	widget_treebox->addItemChild(0, 1);
	widget_treebox->addItemChild(0, 2);
	widget_treebox->addItemChild(0, 3);

	// add second parent and children
	widget_treebox->addItem("parent 1");
	widget_treebox->addItem("child 0");
	widget_treebox->addItem("child 1");
	widget_treebox->addItem("child 2");
	widget_treebox->addItemChild(4, 5);
	widget_treebox->addItemChild(4, 6);
	widget_treebox->addItemChild(4, 7);

	widget_treebox->getEventChanged().connect(*this, [this]() {
		String msg = String("TreeBox: ") + widget_treebox->getCurrentItemText();
		Console::onscreenMessageLine(msg.get());
		});

	Console::setOnscreen(true);
}

void TreeBox::shutdown()
{
	if (gui)
	{
		gui->removeChild(widget_treebox);

		widget_treebox.deleteLater();
	}

	Console::setOnscreen(false);
}

```

## TriggerSample.cpp

```cpp
#include "TriggerSample.h"

#include "MathTriggerComponent.h"

#include <UnigineConsole.h>
#include <UnigineVisualizer.h>
#include <UnigineGame.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(TriggerSample);


// find intersections only with material ball
namespace
{
constexpr int MATERIAL_BALL_INTERSECTION_MASK = 0x7;
} // anonymous namespace

void TriggerSample::init()
{
	Visualizer::setEnabled(true);
	visualizer_mode = Visualizer::getMode();
	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);

	physical_trigger_sphere = checked_ptr_cast<PhysicalTrigger>(trigger_physics_sphere_node.get());
	physical_trigger_capsule = checked_ptr_cast<PhysicalTrigger>(trigger_physics_capsule_node.get());
	physical_trigger_cylinder = checked_ptr_cast<PhysicalTrigger>(trigger_physics_cylinder_node.get());
	physical_trigger_box = checked_ptr_cast<PhysicalTrigger>(trigger_physics_box_node.get());

	WorldMathTrigger *math_trigger_box = getComponent<WorldMathTrigger>(
		trigger_math_box_node.get());
	WorldMathTrigger *math_trigger_sphere = getComponent<WorldMathTrigger>(
		trigger_math_sphere_node.get());
	world_trigger = checked_ptr_cast<WorldTrigger>(trigger_world_node.get());
	WorldIntersectionTrigger *world_intersections_trigger_sphere
		= getComponent<WorldIntersectionTrigger>(trigger_intersection_node_sphere.get());
	WorldIntersectionTrigger *world_intersectons_trigger_box
		= getComponent<WorldIntersectionTrigger>(trigger_intersection_node_box.get());
	math_trigger_box->addObject(target_to_check);
	math_trigger_sphere->addObject(target_to_check);

	NodeTriggerPtr node_trigger = checked_ptr_cast<NodeTrigger>(trigger_node_node.get());

	// Setting callbacks

	physical_trigger_sphere->getEventEnter().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_sphere.get());
			obj->setMaterial(postament_mat_triggered, 0);
		});

	physical_trigger_sphere->getEventLeave().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_sphere.get());
			obj->setMaterial(postament_mat, 0);
		});

	physical_trigger_capsule->getEventEnter().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_capsule.get());
			obj->setMaterial(postament_mat_triggered, 0);
		});

	physical_trigger_capsule->getEventLeave().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_capsule.get());
			obj->setMaterial(postament_mat, 0);
		});

	physical_trigger_cylinder->getEventEnter().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_cylinder.get());
			obj->setMaterial(postament_mat_triggered, 0);
		});

	physical_trigger_cylinder->getEventLeave().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_cylinder.get());
			obj->setMaterial(postament_mat, 0);
		});

	physical_trigger_box->getEventEnter().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_box.get());
			obj->setMaterial(postament_mat_triggered, 0);
		});

	physical_trigger_box->getEventLeave().connect(*this, [this](const BodyPtr &body_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_physics_box.get());
			obj->setMaterial(postament_mat, 0);
		});

	world_trigger->getEventEnter().connect(*this, [this](const NodePtr &node_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_world.get());
			obj->setMaterial(postament_mat_triggered, 0);
		});

	world_trigger->getEventLeave().connect(*this, [this](const NodePtr &node_trigger)
		{
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_world.get());
			obj->setMaterial(postament_mat, 0);
		});


	math_trigger_sphere->addCallback(WorldMathTrigger::CALLBACK_TRIGGER_ENTER,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(
				postament_math_sphere.get());
			obj->setMaterial(postament_mat_triggered, 0);
		}));

	math_trigger_sphere->addCallback(WorldMathTrigger::CALLBACK_TRIGGER_LEAVE,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(
				postament_math_sphere.get());
			obj->setMaterial(postament_mat, 0);
		}));


	world_intersections_trigger_sphere->addCallback(
		WorldIntersectionTrigger::CALLBACK_TRIGGER_ENTER,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectPtr obj = checked_ptr_cast<Object>(node_trigger);
			if (obj && (obj->getIntersectionMask(0) == MATERIAL_BALL_INTERSECTION_MASK))
			{
				ObjectMeshStaticPtr postament = checked_ptr_cast<ObjectMeshStatic>(
					postament_intersection_sphere.get());
				postament->setMaterial(postament_mat_triggered, 0);
			}
		}));

	world_intersections_trigger_sphere->addCallback(
		WorldIntersectionTrigger::CALLBACK_TRIGGER_LEAVE,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectPtr obj = checked_ptr_cast<Object>(node_trigger);
			if (obj && (obj->getIntersectionMask(0) == MATERIAL_BALL_INTERSECTION_MASK))
			{
				ObjectMeshStaticPtr postament = checked_ptr_cast<ObjectMeshStatic>(
					postament_intersection_sphere.get());
				postament->setMaterial(postament_mat, 0);
			}
		}));


	math_trigger_box->addCallback(WorldMathTrigger::CALLBACK_TRIGGER_ENTER,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_math_box.get());
			obj->setMaterial(postament_mat_triggered, 0);
		}));

	math_trigger_box->addCallback(WorldMathTrigger::CALLBACK_TRIGGER_LEAVE,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectMeshStaticPtr obj = checked_ptr_cast<ObjectMeshStatic>(postament_math_box.get());
			obj->setMaterial(postament_mat, 0);
		}));


	world_intersectons_trigger_box->addCallback(WorldIntersectionTrigger::CALLBACK_TRIGGER_ENTER,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectPtr obj = checked_ptr_cast<Object>(node_trigger);
			if (obj && (obj->getIntersectionMask(0) == MATERIAL_BALL_INTERSECTION_MASK))
			{
				ObjectMeshStaticPtr postament = checked_ptr_cast<ObjectMeshStatic>(
					postament_intersection_box.get());
				postament->setMaterial(postament_mat_triggered, 0);
			}
		}));

	world_intersectons_trigger_box->addCallback(WorldIntersectionTrigger::CALLBACK_TRIGGER_LEAVE,
		MakeCallback([this](const NodePtr &node_trigger) {
			ObjectPtr obj = checked_ptr_cast<Object>(node_trigger);
			if (obj && obj->getIntersectionMask(0) == MATERIAL_BALL_INTERSECTION_MASK)
			{
				ObjectMeshStaticPtr postament = checked_ptr_cast<ObjectMeshStatic>(
					postament_intersection_box.get());
				postament->setMaterial(postament_mat, 0);
			}
		}));

	node_trigger->getEventEnabled().connect(*this, [this](const NodeTriggerPtr &trigger)
		{
			auto object_text = checked_ptr_cast<ObjectText>(trigger_node_text.get());
			if(trigger->isEnabled())
				object_text->setTextColor(vec4_white);
			else
				object_text->setTextColor(vec4_red);
		});

	node_trigger->getEventPosition().connect(*this, [](const NodeTriggerPtr &trigger)
		{
			ObjectPtr parent = checked_ptr_cast<Object>(trigger->getParent());
			MaterialPtr material = parent->getMaterialInherit(0);
			vec4 color = material->getParameterFloat4("albedo_color");
			color.z += Game::getIFps();
			if (color.z > 1.0f)
				color.z = 0.0f;
			material->setParameterFloat4("albedo_color", color);
		});

	sample_description_window.createWindow();
	WidgetGroupBoxPtr parameters = sample_description_window.getParameterGroupBox();
	auto node_trigger_checkbox = WidgetCheckBox::create("Cube Active");
	parameters->addChild(node_trigger_checkbox, Gui::ALIGN_LEFT);
	node_trigger_checkbox->getEventChanged().connect(*this, [this, node_trigger_checkbox]()
		{
			trigger_node_parent_node.get()->setEnabled(node_trigger_checkbox->isChecked());
		});
	node_trigger_checkbox->setChecked(true);
}

void TriggerSample::update()
{
	Visualizer::renderBoundBox(world_trigger->getBoundBox(),
		trigger_world_node.get()->getWorldTransform(), vec4_red);

	physical_trigger_sphere->renderVisualizer();
	physical_trigger_capsule->renderVisualizer();
	physical_trigger_cylinder->renderVisualizer();
	physical_trigger_box->renderVisualizer();
}

void TriggerSample::shutdown()
{
	Visualizer::setMode(visualizer_mode);
	Visualizer::setEnabled(false);

	sample_description_window.shutdown();
}

```

## TwoPointPerspectiveSample.cpp

```cpp
#include "TwoPointPerspectiveSample.h"

#include "CameraShiftController.h"

#include <UnigineWidgets.h>

REGISTER_COMPONENT(TwoPointPerspectiveSample);

using namespace Unigine;
using namespace Math;

void TwoPointPerspectiveSample::init()
{
	camera_controller = getComponent<CameraShiftController>(controlledPlayer.get());
	if (!camera_controller)
		Log::error(
			"TwoPointPerspectiveSample::init(): cannot find CameraShiftController component!\n");
	init_gui();
}

void TwoPointPerspectiveSample::shutdown()
{
	shutdown_gui();
}

void TwoPointPerspectiveSample::init_gui()
{
	sample_description_window.createWindow();

	checkbox = WidgetCheckBox::create();
	auto parameters = sample_description_window.getParameterGroupBox();
	auto hbox = WidgetHBox::create();
	auto label = WidgetLabel::create("Two-Point perspective: ");

	checkbox->getEventChanged().connect(this, &TwoPointPerspectiveSample::on_checkbox_changed);
	checkbox->setChecked(false);

	hbox->addChild(label, Gui::ALIGN_LEFT);
	hbox->addChild(checkbox, Gui::ALIGN_LEFT);

	parameters->addChild(hbox, Gui::ALIGN_LEFT);
}

void TwoPointPerspectiveSample::shutdown_gui()
{
	sample_description_window.shutdown();
}

void TwoPointPerspectiveSample::on_checkbox_changed()
{
	camera_controller->setModeShiftModeEnabled(checkbox->isChecked());
}

```

## UDPSocketsSample.cpp

```cpp
#include "UDPSocketsSample.h"

#include <UnigineConsole.h>
#include <UnigineGame.h>

using namespace Unigine;

REGISTER_COMPONENT(UDPSocketsSample);

namespace
{
	constexpr const char *DEFAULT_RECEIVER_HOSTNAME = "127.0.0.1";
	constexpr unsigned short DEFAULT_RECEIVER_PORT = 64'000;

	constexpr int SEND_BUFFER_SIZE = 4096;
	constexpr int RECV_BUFFER_SIZE = 4096;
}

void UDPSocketsSample::init()
{
	gui.init(this);
}

void UDPSocketsSample::update()
{
	if (peer)
		peer->update();
}

void UDPSocketsSample::shutdown()
{
	if (peer)
	{
		delete peer;
		peer = nullptr;
	}

	gui.shutdown();
}

// ================================================================

UDPSocketsSample::Sender::Sender(const Unigine::String &hostname, unsigned short port)
{
	thread.start(hostname, port);

	Console::addCommand(
		"send_msg",
		"[Network Sockets Sample] Send a text message to peer.",
		MakeCallback(this, &UDPSocketsSample::Sender::on_message_send_cmd)
	);
}

UDPSocketsSample::Sender::~Sender()
{
	Console::removeCommand("send_msg");
}

void UDPSocketsSample::Sender::update()
{
	if (!thread.isRunning())
		return;

	PlayerPtr player = Game::getPlayer();
	if (player)
	{
		thread.send(new CameraMessage(
			player->getWorldPosition(),
			player->getWorldRotation())
		);
	}
}

void UDPSocketsSample::Sender::on_message_send_cmd(int argc, char **argv)
{
	BlobPtr message = Blob::create();
	StringStack<> text;

	for (int i = 1; i < argc; i += 1)
	{
		text += argv[i];
		if (i != (argc - 1))
			text += " ";
	}

	thread.send(new TextMessage(text));
}

// ================================================================

bool UDPSocketsSample::Sender::NetworkThread::start(const String &hostname, unsigned short port)
{
	// Create a simple UDP socket.

	// Note that the given address (hostname:port) is used as the source address in subsequent
	// 'send' calls (Socket::write*). The socket's own address is set automatically.

	socket = Socket::create(Socket::SOCKET_TYPE_DGRAM, hostname, port);

	if (!socket->isOpened())
	{
		Log::warning("Could not resolve specified hostname (%s)!\n", hostname.get());
		return false;
	}

	// Set the socket's send buffer size.
	socket->send(SEND_BUFFER_SIZE);

	run();
	return true;
}

void UDPSocketsSample::Sender::NetworkThread::send(Message *message)
{
	queue.push(message);
}

void UDPSocketsSample::Sender::NetworkThread::reset()
{
	shutdown();

	if (socket)
	{
		socket->close();
		socket = {};
	}

	queue.clear();
}

void UDPSocketsSample::Sender::NetworkThread::process()
{
	// Takes messages from the outgoing messages queue and sends them to the peer.

	BlobPtr blob = Blob::create();

	while (isRunning())
	{
		Message *message = queue.pop();

		if (message)
		{
			message->pack(blob);
			blob->seekSet(0);
			delete message;
		}

		if (blob->getSize())
		{
			socket->writeStream(blob, blob->getSize());
			blob->clear();
		}
	}
}

// ================================================================

UDPSocketsSample::Receiver::Receiver(const Unigine::String &hostname, unsigned short port)
{
	thread.start(hostname, port);

	PlayerPtr player = Game::getPlayer();
	if (player)
		player->setControlled(false);
}

UDPSocketsSample::Receiver::~Receiver()
{
	PlayerPtr player = Game::getPlayer();
	if (player)
		player->setControlled(true);
}

void UDPSocketsSample::Receiver::update()
{
	// Handle incoming messages from the peer.

	if (!thread.isRunning())
		return;

	Message *message = thread.receive();
	int processed = 0;

	while (message && processed < message_process_limit)
	{
		switch (message->getType())
		{
			case Message::TEXT:
			{
				TextMessage *text_msg = dynamic_cast<TextMessage *>(message);

				if (text_msg)
					Log::message("Received a text message from peer: \"%s\".\n", text_msg->text.get());

			} break;

			case Message::CAMERA:
			{
				CameraMessage *camera_msg = dynamic_cast<CameraMessage *>(message);

				if (camera_msg)
				{
					PlayerPtr player = Game::getPlayer();

					if (player)
					{
						player->setWorldPosition(camera_msg->position);
						player->setWorldRotation(camera_msg->rotation);
					}
				}

			} break;

			default: break;
		}

		delete message;
		message = thread.receive();
		processed += 1;
	}
}

// ================================================================

bool UDPSocketsSample::Receiver::NetworkThread::start(const String &hostname, unsigned short port)
{
	// Create a UDP socket and bind to the given address.

	socket = Socket::create(Socket::SOCKET_TYPE_DGRAM, hostname, port);

	if (!socket->isOpened())
	{
		Log::warning("Could not resolve specified hostname (%s)!\n", hostname.get());
		return false;
	}

	// Set the socket's receive buffer size.
	socket->recv(RECV_BUFFER_SIZE);

	// Set the socket as non-blocking.
	socket->nonblock();

	// Bind the socket to the address provided the in the `Socket::create` call above.
	if (!socket->bind())
	{
		Log::warning("Could not bind socket to the specified address (%s:%d)!\n", hostname.get(), port);
		return false;
	}

	run();
	return true;
}

void UDPSocketsSample::Receiver::NetworkThread::reset()
{
	shutdown();

	if (socket)
	{
		socket->close();
		socket = nullptr;
	}

	queue.clear();
}

UDPSocketsSample::Message *UDPSocketsSample::Receiver::NetworkThread::receive()
{
	return queue.pop();
}

void UDPSocketsSample::Receiver::NetworkThread::process()
{
	// Receive incoming messages from the peer, parse and push them to the outgoing messages queue.

	BlobPtr blob = Blob::create();

	while (isRunning())
	{
		socket->readStream(blob, RECV_BUFFER_SIZE);
		blob->seekSet(0);

		if (blob->getSize())
		{
			Message *message = extract_message(blob);

			if (message)
				queue.push(message);
		}

		blob->clear();
	}
}

UDPSocketsSample::Message *UDPSocketsSample::Receiver::NetworkThread::extract_message(Unigine::BlobPtr blob)
{
	Message::Header header = {};
	Message *message = nullptr;

	blob->read(&header, sizeof(header));
	blob->seekSet(0);

	switch (header.type)
	{
		case Message::TEXT: message = new TextMessage(); break;
		case Message::CAMERA: message = new CameraMessage(); break;
		default: break;
	}

	if (message)
		message->unpack(blob);

	return message;
}

// ================================================================

size_t UDPSocketsSample::TextMessage::pack(Unigine::BlobPtr dst_blob)
{
	size_t cursor = dst_blob->tell();
	size_t packed = 0;

	packed += dst_blob->write(&header, sizeof(header));

	size_t text_size = text.size();
	packed += dst_blob->write(&text_size, sizeof(text_size));
	packed += dst_blob->write(text.get(), text_size);

	header.type = getType();
	header.size = packed;

	dst_blob->seekSet(cursor);
	dst_blob->write(&header, sizeof(header));

	dst_blob->seekSet(cursor + packed);

	return packed;
}

size_t UDPSocketsSample::TextMessage::unpack(Unigine::BlobPtr src_blob)
{
	size_t unpacked = 0;

	unpacked += src_blob->read(&header, sizeof(header));

	size_t text_size = 0;

	unpacked += src_blob->read(&text_size, sizeof(text_size));

	if (text_size)
	{
		text.resize(text_size);
		unpacked += src_blob->read(text.getRaw(), text_size);
	}

	return unpacked;
}

size_t UDPSocketsSample::CameraMessage::pack(Unigine::BlobPtr dst_blob)
{
	size_t cursor = dst_blob->tell();
	size_t packed = 0;

	packed += dst_blob->write(&header, sizeof(header));
	packed += dst_blob->write(&position, sizeof(position));
	packed += dst_blob->write(&rotation, sizeof(rotation));

	header.type = getType();
	header.size = packed;

	dst_blob->seekSet(cursor);
	dst_blob->write(&header, sizeof(header));

	dst_blob->seekSet(cursor + packed);

	return packed;
}

size_t UDPSocketsSample::CameraMessage::unpack(Unigine::BlobPtr src_blob)
{
	size_t unpacked = 0;

	unpacked += src_blob->read(&header, sizeof(header));
	unpacked += src_blob->read(&position, sizeof(position));
	unpacked += src_blob->read(&rotation, sizeof(rotation));

	return unpacked;
}

// ================================================================

void UDPSocketsSample::SampleGui::on_start_sender_btn_clicked(const WidgetPtr &widget, int mouse)
{
	if (sample->peer)
	{
		delete sample->peer;
		sample->peer = nullptr;
	}

	start_recver_btn->getEventClicked().setEnabled(false);
	start_sender_btn->getEventClicked().setEnabled(false);

	if (start_sender_btn->isToggled())
	{
		StringStack<> hostname;
		unsigned short port = 0;

		hostname = recv_host_el->getText();
		port = (unsigned short) String::atoi(recv_port_el->getText());

		sample->peer = new Sender(hostname, port);

		recv_host_el->setEnabled(false);
		recv_port_el->setEnabled(false);

		start_recver_btn->setToggled(false);
	}

	else
	{
		recv_host_el->setEnabled(true);
		recv_port_el->setEnabled(true);
	}

	start_recver_btn->getEventClicked().setEnabled(true);
	start_sender_btn->getEventClicked().setEnabled(true);
}

void UDPSocketsSample::SampleGui::on_start_recver_btn_clicked(const WidgetPtr &widget, int mouse)
{
	if (sample->peer)
	{
		delete sample->peer;
		sample->peer = nullptr;
	}

	start_recver_btn->getEventClicked().setEnabled(false);
	start_sender_btn->getEventClicked().setEnabled(false);

	if (start_recver_btn->isToggled())
	{
		StringStack<> hostname;
		unsigned short port = 0;

		hostname = recv_host_el->getText();
		port = (unsigned short) String::atoi(recv_port_el->getText());

		sample->peer = new Receiver(hostname, port);

		recv_host_el->setEnabled(false);
		recv_port_el->setEnabled(false);

		start_sender_btn->setToggled(false);
	}

	else
	{
		recv_host_el->setEnabled(true);
		recv_port_el->setEnabled(true);
	}

	start_recver_btn->getEventClicked().setEnabled(true);
	start_sender_btn->getEventClicked().setEnabled(true);
}

void UDPSocketsSample::SampleGui::init(UDPSocketsSample *sample)
{
	this->sample = sample;
	is_onscreen = Console::isOnscreen();
	Console::setOnscreen(true);

	sample_description_window.createWindow(Gui::ALIGN_RIGHT);

	auto const &group_box = sample_description_window.getParameterGroupBox();

	auto hbox = WidgetHBox::create();
	group_box->addChild(hbox, Gui::ALIGN_TOP);

	start_sender_btn = WidgetButton::create("Sender");
	start_sender_btn->setToggleable(true);
	start_sender_btn->setToggled(false);
	start_sender_btn->setHeight(24);
	start_sender_btn->getEventClicked().connect(this, &SampleGui::on_start_sender_btn_clicked);
	hbox->addChild(start_sender_btn);

	start_recver_btn = WidgetButton::create("Receiver");
	start_recver_btn->setToggleable(true);
	start_recver_btn->setToggled(false);
	start_recver_btn->setHeight(24);
	start_recver_btn->getEventClicked().connect(this, &SampleGui::on_start_recver_btn_clicked);
	hbox->addChild(start_recver_btn);

	auto spacer = WidgetSpacer::create();
	spacer->setOrientation(0);
	hbox->addChild(spacer);

	recv_host_el = WidgetEditLine::create(DEFAULT_RECEIVER_HOSTNAME);
	recv_host_el->setWidth(100);
	recv_host_el->setHeight(18);
	recv_host_el->setFontVOffset(-2);
	hbox->addChild(recv_host_el);

	hbox->addChild(WidgetLabel::create(":"));

	recv_port_el = WidgetEditLine::create(String::itoa(DEFAULT_RECEIVER_PORT).get());
	recv_port_el->setWidth(45);
	recv_port_el->setHeight(18);
	recv_port_el->setFontVOffset(-2);
	recv_port_el->setValidator(Gui::VALIDATOR_UINT);
	hbox->addChild(recv_port_el);

	for (int i = 0; i < Engine::get()->getNumArgs(); i++)
	{
		String str = Engine::get()->getArg(i);
		if (str == "-server")
			start_recver_btn->setToggled(true);
		else if (str == "-client")
			start_sender_btn->setToggled(true);
	}
}

void UDPSocketsSample::SampleGui::shutdown()
{
	sample_description_window.shutdown();
	Console::setOnscreen(is_onscreen);
	sample = nullptr;
}

```

## UnigineScriptsInterpreter.cpp

```cpp
#include "UnigineScriptsInterpreter.h"

InterpreterRegistrator *InterpreterRegistrator::get()
{
	static InterpreterRegistrator instanse;
	return &instanse;
}

void InterpreterRegistrator::initialize()
{
	Unigine::Log::message("InterpreterRegistrator::initialize()\n");
	invoker.run();
}

```

## Unit.cpp

```cpp
#include "Unit.h"

#include "Flock.h"

#include <UnigineGame.h>
#include <UnigineProfiler.h>
#include <UnigineVisualizer.h>

using namespace Unigine;
using namespace Math;

Unit::Unit(const NodePtr &node)
{
	UNIGINE_ASSERT(node);
	unit_node = node;
}

void Unit::debug_visualize() const
{
	Visualizer::setEnabled(true);
	auto velocity_color = vec4_red;
	auto acceleration_color = vec4_blue;
	Visualizer::renderVector(getNode()->getWorldPosition(),
		getNode()->getWorldPosition() + velocity, velocity_color);
	Visualizer::renderVector(getNode()->getWorldPosition(),
		getNode()->getWorldPosition() + acceleration, acceleration_color);
}

void Unit::limit_rotation()
{
	const auto speed = velocity.length();
	velocity.normalizeValid();

	auto direction = rotateTowards(vec3(velocity), vec3(normalizeValid(velocity + acceleration)),
		rotation_speed * Game::getIFps());
	direction.normalizeValid();
	auto new_speed = (speed + max_force);
	new_speed = clamp(new_speed, static_cast<Scalar>(0.01f), max_speed);
	velocity = Vec3(direction) * new_speed;
}

void Unit::apply_movement()
{
	const auto new_position = unit_node->getWorldPosition() + velocity * Game::getIFps();
	auto direction = vec3(normalizeValid(velocity));
	auto new_transform = setTo(new_position, new_position + Vec3(direction), vec3_up, AXIS_Y);
	unit_node->setWorldTransform(new_transform);
	acceleration = Vec3_zero;
}

void Unit::update(Flock *flock)
{
	UNIGINE_ASSERT(flock);
	UNIGINE_ASSERT(unit_node);
	flocking(flock);
	if (is_limit_by_height)
		limit_by_height();
	limit_rotation();
	apply_movement();
}

void Unit::separation_loop(Data &separation_data, Unit &unit) const
{
	Vec3 separation_direction{};
	auto d2 = distance2(unit.getNode()->getWorldPosition(), getNode()->getWorldPosition());
	if (d2 > desired_separation_range * desired_separation_range)
		return;

	separation_direction = getNode()->getWorldPosition() - unit.getNode()->getWorldPosition();
	if (separation_direction.length2() == 0)
		return;

	separation_direction = separation_direction.normalizeValid();
	const auto proximity_factor = d2 / (desired_separation_range * desired_separation_range);
	if (proximity_factor > 0)
		separation_data.sum += separation_direction / proximity_factor;
	else
		separation_data.sum += separation_direction;
	separation_data.count++;
}

void Unit::align_loop(Unit::Data &align_data, Unit &unit)
{
	constexpr float align_range = 50.f;
	const Scalar distance = distance2(getNode()->getWorldPosition(),
		unit.getNode()->getWorldPosition());
	if (distance >= 0 && distance < align_range * align_range)
	{
		align_data.sum += unit.getCurrentVelocity();
		align_data.count++;
	}
}

void Unit::group_up_loop(Unit::Data &group_data, Unit &unit)
{
	const Scalar distance = distance2(unit_node->getWorldPosition(),
		unit.getNode()->getWorldPosition());
	if (distance >= 0 && distance < spot_radius * spot_radius)
	{
		group_data.sum += unit.getNode()->getWorldPosition();
		group_data.count++;
	}
}

void Unit::separation_total(Flock *flock, Unit::Data &separation_data)
{
	if (separation_data.count > 0)
	{
		separation_data.sum /= static_cast<Scalar>(separation_data.count);
		separation_data.sum.normalizeValid();
		separation_data.sum -= normalizeValid(velocity);
		separation_data.sum *= flock->getSeparationCoefficient();
	}
}

void Unit::align_total(Flock *flock, Unit::Data &align_data)
{
	if (align_data.count > 0)
	{
		align_data.sum /= static_cast<Scalar>(align_data.count);
		align_data.sum.normalizeValid();
		align_data.sum -= normalizeValid(velocity);
		align_data.sum *= flock->getAlignmentCoefficient();
	}
}

void Unit::group_up_total(Flock *flock, Unit::Data &group_data)
{
	if (group_data.count > 0)
	{
		Vec3 steer{};
		group_data.sum /= static_cast<Scalar>(group_data.count);
		steer = group_data.sum - getNode()->getWorldPosition();
		steer = steer.normalizeValid();
		const auto factor = flock->getCohesionCoefficient()
			* (1.f
				- distance2(group_data.sum, getNode()->getWorldPosition())
					/ (getSpotRadius() * getSpotRadius()));
		steer *= factor;
		group_data.sum = steer;
	}
}

void Unit::flocking(Flock *flock)
{
	UNIGINE_ASSERT(flock && "flock nullptr");

	Data align_data{};
	Data group_data{};
	Data separation_data{};

	for (auto &unit : flock->getUnits())
	{
		separation_loop(separation_data, unit);
		align_loop(align_data, unit);
		group_up_loop(group_data, unit);
	}

	separation_total(flock, separation_data);
	align_total(flock, align_data);
	group_up_total(flock, group_data);

	Vec3 tar = chase_target(flock);
	acceleration += tar;

	Vec3 sep = separation_data.sum;
	Vec3 ali = align_data.sum;
	Vec3 coh = group_data.sum;

	acceleration += sep;
	acceleration += ali;
	acceleration += coh;
}

void Unit::limit_by_height()
{
	const Vec3 current_position = getNode()->getWorldPosition();

	bool under_max = false;
	bool above_min = false;

	if (current_position.z > min_height)
		above_min = true;

	if (current_position.z < max_height)
		under_max = true;

	constexpr Scalar max_escape_force = 100.f;
	if (under_max && above_min)
	{
		// check padding
		if (current_position.z > max_height - height_padding)
		{
			const auto pad_height = max_height - height_padding;
			const auto force = max_escape_force / (1. - Math::pow(max_height / pad_height, 2))
				* (1. - Math::pow(current_position.z, 2) / Math::pow(pad_height, 2));
			acceleration += Vec3(0, 0, -force);
		}

		if (current_position.z < min_height + height_padding)
		{
			const auto pad_height = min_height + height_padding;
			const auto force = max_escape_force / (1. - Math::pow(max_height / pad_height, 2))
				* (1. - Math::pow(current_position.z, 2) / Math::pow(pad_height, 2));
			acceleration += Vec3(0, 0, -force);
		}

		return;
	}

	if (!above_min)
	{
		acceleration += Vec3_up * max_escape_force;
		return;
	}
	if (!under_max)
	{
		acceleration += Vec3_down * max_escape_force;
		return;
	}
}

Vec3 Unit::chase_target(const Flock *flock) const
{
	return (flock->getTarget()->getWorldPosition() - getNode()->getWorldPosition())
		* flock->getTargetChaseValue();
}
```

## UnitSelectionCircle.cpp

```cpp
#include "UnitSelectionCircle.h"
#include <UniginePrimitives.h>
REGISTER_COMPONENT(UnitSelectionCircle);

using namespace Unigine;
using namespace Math;

void UnitSelectionCircle::setSelected(bool value)
{
	if (!selection_circle)
		return;

	selected = value;
	selection_circle->setEnabled(selected);
}

void UnitSelectionCircle::init()
{
	selection_circle = World::loadNode(selectionCircle.get());
	if (!selection_circle)
	{
		Log::error("UnitSelectionCircle::init(): cannot load node '%s'\n", selectionCircle.get());
		return;
	}

	selection_circle->setParent(node);
	selection_circle->setPosition(Vec3(offset.get()));
	selection_circle->setEnabled(false);
}

```

## UpdatePhysicsUsageController.cpp

```cpp
#pragma once
#include "UpdatePhysicsUsageController.h"

#include <Unigine.h>
#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(UpdatePhysicsUsageController);

void UpdatePhysicsUsageController::init()
{
	rigid_body = node->getObjectBodyRigid();

	if (!rigid_body)
	{
		Log::error("PhysicsIFpsController::init can't find rigid body on the node!\n");
	}
	current_force = linear_force;

	visualizer_enabled = Visualizer::isEnabled();
	Visualizer::setEnabled(true);
}

void UpdatePhysicsUsageController::update()
{
	//visualizing current linear velocity
	Visualizer::renderVector(rigid_body->getPosition(), rigid_body->getPosition() + Vec3(rigid_body->getLinearVelocity()), vec4_red,0.5f);

	//NOTICE that methods: update and udpate_physics registered in different component Macros and code is the same for both usage examples
	// using update() to move node with physics
	if (use_update) 
	{
		movement();
	}
}

void UpdatePhysicsUsageController::movement()
{
	rigid_body->addForce(vec3_right * current_force);

	if (node->getWorldPosition().x > 5)
		current_force = -linear_force;
	if (node->getWorldPosition().x < -5)
		current_force = linear_force;
}

void UpdatePhysicsUsageController::shutdown()
{
	Visualizer::setEnabled(visualizer_enabled);
}

void UpdatePhysicsUsageController::update_physics()
{
	//NOTICE that methods: update and udpate_physics registered in different component Macros and code is the same for both usage examples
	// using update() to move node with physics
	if (!use_update)
	{
		movement();
	}
}

```

## UpdatePhysicsUsageSample.cpp

```cpp
#include "UpdatePhysicsUsageSample.h"

REGISTER_COMPONENT(UpdatePhysicsUsageSample);

using namespace Unigine;
using namespace Math;


void UpdatePhysicsUsageSample::init()
{
	window_sample.createWindow();

	WidgetSliderPtr fpsSlider = window_sample.addIntParameter("Max fps", "Max fps", 60, 15, 150, [this](int v) {
		Render::setMaxFPS(v);
		});
	Render::setMaxFPS(60);

}

void UpdatePhysicsUsageSample::shutdown()
{
	window_sample.shutdown();
}

```

## UserInterface.cpp

```cpp
#include "UserInterface.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(UserInterface);

void UserInterface::init()
{
	if (Unigine::String::isEmpty(ui_file.get()))
	{
		Unigine::Log::warning("UserInterface::init(): ui_file is not assigned.\n");
		return;
	}

	Unigine::GuiPtr gui = Unigine::WindowManager::getMainWindow()->getGui();

	user_interface = Unigine::UserInterface::create(gui, ui_file.get());
	if (user_interface == nullptr)
	{
		Unigine::Log::warning("UserInterface::init(): can't created UserInterface.\n");
	}

	Unigine::WidgetPtr edittext = user_interface->getWidgetByName("edittext");
	if (edittext != nullptr)
	{
		edittext->getEventChanged().connect(this, &UserInterface::edittext_changed);
	}

	Unigine::WidgetPtr menubox_0 = user_interface->getWidgetByName("menubox_0");
	if (menubox_0 != nullptr)
	{
		menubox_0->getEventClicked().connect(this, &UserInterface::menubox_0_clicked);
	}

	int index = user_interface->findWidget("window");
	if (index != -1)
	{
		window = user_interface->getWidget(index);
		window->arrange();
		Unigine::WindowManager::getMainWindow()->addChild(window, Unigine::Gui::ALIGN_OVERLAP | Unigine::Gui::ALIGN_CENTER);
	}

	Unigine::Console::setOnscreen(true);
}

void UserInterface::shutdown()
{	
	if (window)
		window.deleteLater();

	if(user_interface)
		user_interface.deleteLater();

	Unigine::Console::setOnscreen(false);
}

void UserInterface::edittext_changed(const Unigine::WidgetPtr &widget)
{
	Unigine::WidgetEditTextPtr edittext = Unigine::checked_ptr_cast<Unigine::WidgetEditText>(widget);
	Unigine::Log::message("EditText changed: %s\n", edittext->getText());
}

void UserInterface::menubox_0_clicked(const Unigine::WidgetPtr &widget)
{
	Unigine::WidgetMenuBoxPtr menubox = Unigine::checked_ptr_cast<Unigine::WidgetMenuBox>(widget);
	Unigine::Log::message("MenuBox clicked: %s\n", menubox->getCurrentItemText());
	if (menubox->getCurrentItem() == 2)
		Unigine::Console::run("quit");
}

```

## ViewportCube.cpp

```cpp
#include "ViewportCube.h"

#include <UnigineGame.h>
#include <UniginePlayers.h>
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

namespace
{
	const float VIEWCUBE_WIDTH = 120.0f;
	const float VIEWCUBE_HEIGHT = 120.0f;
	const float VIEWCUBE_PROJECTION_ICON_SIZE = 32.f;
	const float VIEWCUBE_SCALE = 55.0f;

	const float CAMERA_ANIMATION_PERIOD = 0.25f;
}

ViewportCube::ViewportCube(const PlayerPtr &player, float ortho_width, float ortho_height)
	: player(player), ortho_width(ortho_width), ortho_height(ortho_height)
{
	auto gui = Gui::getCurrent();

	// we need to change the up vector for strict Z-view for PlayerSpectator
	// just use PlayerDummy and make your own player logic
	if (player->getType() != Node::NODE_DUMMY)
		player->setUp(normalize(vec3(0, 0.00000001, 1)));


	auto prop = Properties::findProperty("ViewCubeSettings");
	if (!prop)
	{
		Log::error("The ViewCubeSettings component is not found!");
	}
	String viewcube_projection_icon_path = prop->getParameterPtr("VIEWCUBE_PROJECTION_ICON")->getValueString();
	String viewcube_mesh_path = prop->getParameterPtr("VIEWCUBE_MESH")->getValueString();
	String viewcube_arrows_mesh_path = prop->getParameterPtr("VIEWCUBE_ARROWS_MESH")->getValueString();
	viewcube_texture_touch_path = prop->getParameterPtr("VIEWCUBE_TEXTURE_TOUCH")->getValueString();
	viewcube_texture_untouch_path = prop->getParameterPtr("VIEWCUBE_TEXTURE_UNTOUCH")->getValueString();

	main_widget = WidgetHBox::create(gui);
	main_widget->setWidth((int)VIEWCUBE_WIDTH);
	main_widget->setHeight((int)VIEWCUBE_HEIGHT);

	ortho_hbox = WidgetHBox::create(gui);
	main_widget->addChild(ortho_hbox, Gui::ALIGN_EXPAND);

	ortho_icon = WidgetIcon::create(gui, viewcube_projection_icon_path,
									 (int)VIEWCUBE_PROJECTION_ICON_SIZE,
									 (int)VIEWCUBE_PROJECTION_ICON_SIZE);
	ortho_icon->setToolTip("Switch between the orthographic and perspective projections");
	ortho_icon->setToggleable(true);
	ortho_icon->getEventChanged().connect(icon_connection, this, &ViewportCube::ortho_toggled);
	ortho_hbox->addChild(ortho_icon, Gui::ALIGN_RIGHT | Gui::ALIGN_TOP);

	MeshPtr mesh = Mesh::create(viewcube_mesh_path);
	cube_canvas = WidgetCanvas::create(gui);

	for (int surface = 0; surface < mesh->getNumSurfaces(); ++surface)
	{
		const char *name = mesh->getSurfaceName(surface);
		vec3 pos = get_polygon_pos(name);
		quat rot = get_polygon_rot(pos);
		positions.push_back(pos);
		rotations.push_back(rot);

		mesh->remapCVertex(surface);
		int polygon = cube_canvas->addPolygon();
		cube_canvas->setPolygonTwoSided(polygon, 0);

		for (int i = 0; i < mesh->getNumVertex(surface); ++i)
		{
			vec3 point = mesh->getVertex(i, surface);
			cube_canvas->addPolygonPoint(polygon, point);

			vec2 uv = mesh->getTexCoord0(i, surface);
			cube_canvas->setPolygonTexCoord(polygon, uv);
		}

		for (int i = 0; i < mesh->getNumCIndices(surface); ++i)
		{
			int index = mesh->getCIndex(i, surface);
			cube_canvas->addPolygonIndex(polygon, index);
		}
	}

	mesh = Mesh::create(viewcube_arrows_mesh_path);
	arrows_canvas = WidgetCanvas::create(gui);

	for (int surface = 0, num = mesh->getNumSurfaces(); surface < num; ++surface)
	{
		const char *name = mesh->getSurfaceName(surface);
		vec3 pos = get_polygon_pos(name);
		quat rot = get_polygon_rot(pos);
		rotations.push_back(rot);

		mesh->remapCVertex(surface);
		int polygon = arrows_canvas->addPolygon();

		for (int i = 0; i < mesh->getNumVertex(surface); ++i)
		{
			vec3 point = mesh->getVertex(i, surface);
			arrows_canvas->addPolygonPoint(polygon, point);

			vec2 uv = mesh->getTexCoord0(i, surface);
			arrows_canvas->setPolygonTexCoord(polygon, uv);
		}

		for (int i = 0; i < mesh->getNumCIndices(surface); ++i)
		{
			int index = mesh->getCIndex(i, surface);
			arrows_canvas->addPolygonIndex(polygon, index);
		}
	}

	ortho_transform = translate(VIEWCUBE_WIDTH / 2, VIEWCUBE_HEIGHT / 2, 0.0f)
		* scale(VIEWCUBE_SCALE, -VIEWCUBE_SCALE, VIEWCUBE_SCALE);

	perspective_transform = ortho_transform * perspective(40.0f, 1.0f, 0.0f, 100.0f)
		* translate(0, 0, -3.3f);

	for (int i = 0, num = cube_canvas->getNumPolygons(); i < num; ++i)
	{
		cube_canvas->setPolygonTexture(i, viewcube_texture_untouch_path);
	}

	for (int i = 0, num = arrows_canvas->getNumPolygons(); i < num; ++i)
	{
		arrows_canvas->setPolygonTexture(i, viewcube_texture_untouch_path);
	}

	arrows_canvas->setHidden(true);

	main_widget->addChild(arrows_canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);
	main_widget->addChild(cube_canvas, Gui::ALIGN_OVERLAP | Gui::ALIGN_BACKGROUND);

	gui->addChild(main_widget, Gui::ALIGN_OVERLAP | Gui::ALIGN_FIXED);

	cube_canvas->setTransform(perspective_transform);
	arrows_canvas->setTransform(ortho_transform);
}

ViewportCube::~ViewportCube()
{
	main_widget.deleteLater();
}

void ViewportCube::setViewcubePosition(const ivec2 &pos)
{
	main_widget->setPosition(pos.x, pos.y);
}

ivec2 ViewportCube::getViewcubePosition() const
{
	return {main_widget->getPositionX(), main_widget->getPositionY()};
}

void ViewportCube::setChangeProjectionEnabled(bool enabled)
{
	ortho_icon->setEnabled(enabled);
	ortho_icon->setHidden(!enabled);
}

bool ViewportCube::getChangeProjectionEnabled() const
{
	return ortho_icon->isEnabled();
}

vec3 ViewportCube::get_polygon_pos(const char *name)
{
	const StringStack<> n = name;
	vec3 pos = vec3_zero;

	if (n.contains("px"))
		pos.x = 1.0f;
	if (n.contains("py"))
		pos.y = 1.0f;
	if (n.contains("pz"))
		pos.z = 1.0f;
	if (n.contains("nx"))
		pos.x = -1.0f;
	if (n.contains("ny"))
		pos.y = -1.0f;
	if (n.contains("nz"))
		pos.z = -1.0f;

	return pos;
}

quat ViewportCube::get_polygon_rot(const vec3 &pos)
{
	const vec3 dir = normalize(-pos);
	vec3 up = vec3_up;
	if (dir == vec3_up || dir == vec3_down)
		up = vec3_forward;
	return quat(setTo(vec3_zero, dir, up));
}

void ViewportCube::ortho_toggled()
{
	mat4 projection = player->getProjection();

	const float fov = player->getFov();
	const float znear = player->getZNear();
	const float zfar = player->getZFar();
	const float h = ortho_height;
	const float w = ortho_width;

	ortho_enabled = ortho_icon->isToggled();

	if (ortho_enabled)
	{
		projection = ortho(-w / 2.0f, w / 2.0f, -h / 2.0f, h / 2.0f, znear, zfar);
	}
	else
	{
		projection = perspective(fov, 1.0f, znear, zfar);
	}

	player->setProjection(projection);
}

void ViewportCube::animate_rotation(const quat &rot)
{
	old_rotation = player->getWorldRotation();
	new_rotation = rot;

	old_position = player->getWorldPosition();
	Scalar distance = (old_position - centering_position).length();
	distance = max(min_distance, distance);
	new_position = centering_position + Vec3(rot.getNormal() * (float)distance);

	timer_rotation = 1.0f;
}

void ViewportCube::update_rotation()
{
	if (timer_rotation <= 0)
		return;

	timer_rotation -= Game::getIFps() / CAMERA_ANIMATION_PERIOD;

	quat camera_rotation;
	Vec3 camera_position;

	if (timer_rotation > 0)
	{
		camera_rotation = slerp(new_rotation, old_rotation, timer_rotation);
		camera_position = lerp(new_position, old_position, timer_rotation);
	}
	else
	{
		camera_position = new_position;
		camera_rotation = new_rotation;
	}

	player->setWorldTransform(translate(camera_position) * Mat4(camera_rotation));
}

void ViewportCube::update()
{
	if (main_widget->isHidden())
		return;

	update_rotation();

	const quat rotation = conjugate(player->getWorldRotation());
	const mat4 projection = player->getProjection();

	const bool is_ortho = (projection.m33 == 1.0f);

	if (!is_hovered && is_ortho != ortho_icon->isToggled())
	{
		MUTE_EVENT(ortho_icon->getEventChanged());
		ortho_icon->setToggled(is_ortho);
	}

	if (is_ortho)
	{
		cube_canvas->setTransform(ortho_transform * mat4(rotation));
	}
	else
	{
		cube_canvas->setTransform(perspective_transform * mat4(rotation));
	}

	arrows_canvas->setTransform(ortho_transform * mat4(rotation));

	const vec2 mouse_pos((float)cube_canvas->getMouseX(), (float)cube_canvas->getMouseY());
	const vec2 half_size{VIEWCUBE_WIDTH / 2, VIEWCUBE_HEIGHT / 2};
	const float mouse_distance = distance(mouse_pos, half_size);

	is_hovered = checkRange(mouse_pos.x, 0.0f, VIEWCUBE_WIDTH)
		&& checkRange(mouse_pos.y, 0.0f, VIEWCUBE_HEIGHT);

	vec4 color = vec4_one;
	color.w = 1.0f - saturate(mouse_distance / VIEWCUBE_WIDTH / 4.0f - 0.1f);

	if (ortho_hbox->getColor() != color)
	{
		ortho_hbox->setColor(color);

		for (int i = 0, num = arrows_canvas->getNumPolygons(); i < num; ++i)
		{
			arrows_canvas->setPolygonColor(i, color);
		}
	}

	// cube
	int cube_polygon = -1;
	const int cube_num_poly = cube_canvas->getNumPolygons();

	if (is_hovered)
	{
		for (int i = 0; i < cube_num_poly; ++i)
		{
			const vec3 pos = rotation * positions[i];
			const int order = (1 + (int)pos.z) * 100;
			cube_canvas->setPolygonOrder(i, order);
			cube_canvas->setPolygonTexture(i, viewcube_texture_untouch_path);
		}

		cube_polygon = cube_canvas->getPolygonIntersection((int)mouse_pos.x, (int)mouse_pos.y);

		if (cube_polygon != -1 && cube_canvas->getPolygonTexture(cube_polygon) != String(viewcube_texture_touch_path))
		{
			cube_canvas->setPolygonTexture(cube_polygon, viewcube_texture_touch_path);
		}
	}

	// arrows
	if (color.w <= 0.0f && arrows_canvas->isHidden())
	{
		return;
	}

	int arrows_hidden = 1;

	vec3 dir = normalize(conjugate(rotation) * vec3_up);
	dir.x = Math::abs(dir.x);
	dir.y = Math::abs(dir.y);
	dir.z = Math::abs(dir.z);

	if (length2(dir - vec3_right) < 0.1f)
	{
		arrows_hidden = 0;
	}
	else if (length2(dir - vec3_forward) < 0.1f)
	{
		arrows_hidden = 0;
	}
	else if (length2(dir - vec3_up) < 0.1f)
	{
		arrows_hidden = 0;
	}

	arrows_canvas->setHidden(arrows_hidden != 0);

	int arrow_polygon = -1;

	if (!arrows_hidden && is_hovered)
	{
		for (int i = 0; i < arrows_canvas->getNumPolygons(); ++i)
		{
			arrows_canvas->setPolygonTexture(i, viewcube_texture_untouch_path);
		}

		arrow_polygon = arrows_canvas->getPolygonIntersection((int)mouse_pos.x, (int)mouse_pos.y);

		if (arrow_polygon != -1
			&& arrows_canvas->getPolygonTexture(arrow_polygon) != String(viewcube_texture_touch_path))
		{
			arrows_canvas->setPolygonTexture(arrow_polygon, viewcube_texture_touch_path);
		}
	}

	// mouse click
	if (!is_hovered)
	{
		return;
	}

	if (Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT))
	{
		if (cube_polygon != -1)
		{
			animate_rotation(rotations[cube_polygon]);
		}

		if (arrow_polygon != -1)
		{
			animate_rotation(rotations[cube_num_poly + arrow_polygon]);
		}

		Gui::getCurrent()->removeFocus();
	}
}

```

## VisualizerSample.cpp

```cpp
#include "VisualizerSample.h"
#include <UnigineVisualizer.h>

using namespace Unigine;

REGISTER_COMPONENT(VisualizerSample)

void VisualizerSample::init()
{
	visualizer_usage = getComponent<VisualizerUsage>(visualizer_usage_node);
	if (!visualizer_usage)
	{
		Log::error("VisualizerSample::init() can't find VisualizerUsage on visualizer usage node: \n");
	}

	window.createWindow();

	WidgetGroupBoxPtr params = window.getParameterGroupBox();
	WidgetPtr grid = params->getChild(0);

	//========== Enable visualizer checkbox =========//
	WidgetCheckBoxPtr visualizer_check_box = WidgetCheckBox::create("Enable visualizer");
	params->addChild(visualizer_check_box, Gui::ALIGN_LEFT);
	visualizer_check_box->getEventChanged().connect(*this, [this, visualizer_check_box]() {
		Visualizer::setEnabled(visualizer_check_box->isChecked());
		});
	visualizer_check_box->setChecked(true);

	//========== Enable visualizer checkbox =========//
	WidgetCheckBoxPtr depth_test_check_box = WidgetCheckBox::create("Enable depth test");
	params->addChild(depth_test_check_box, Gui::ALIGN_LEFT);
	depth_test_check_box->getEventChanged().connect(*this, [this, depth_test_check_box]() {
		if (depth_test_check_box->isChecked())
		{
			Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_ENABLED);
		}
		else {
			Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
		}
		});
	depth_test_check_box->setChecked(true);

	//========== Enable point2D checkbox =========//
	WidgetCheckBoxPtr point2D_check_box = WidgetCheckBox::create("Point2D");
	params->addChild(point2D_check_box, Gui::ALIGN_LEFT);
	point2D_check_box->getEventChanged().connect(*this, [this, point2D_check_box]() {
		visualizer_usage->renderPoint2D = point2D_check_box->isChecked();
		});
	point2D_check_box->setChecked(visualizer_usage->renderPoint2D);

	//========== Enable line2D checkbox =========//
	WidgetCheckBoxPtr line2D_check_box = WidgetCheckBox::create("Line2D");
	params->addChild(line2D_check_box, Gui::ALIGN_LEFT);
	line2D_check_box->getEventChanged().connect(*this, [this, line2D_check_box]() {
		visualizer_usage->renderLine2D = line2D_check_box->isChecked();
		});
	line2D_check_box->setChecked(visualizer_usage->renderPoint2D);

	//========== Enable triangle2D checkbox =========//
	WidgetCheckBoxPtr triangle2D_check_box = WidgetCheckBox::create("Triangle2D");
	params->addChild(triangle2D_check_box, Gui::ALIGN_LEFT);
	triangle2D_check_box->getEventChanged().connect(*this, [this, triangle2D_check_box]() {
		visualizer_usage->renderTriangle2D = triangle2D_check_box->isChecked();
		});
	triangle2D_check_box->setChecked(visualizer_usage->renderTriangle2D);

	//========== Enable quad2D checkbox =========//
	WidgetCheckBoxPtr quad2D_check_box = WidgetCheckBox::create("Quad2D");
	params->addChild(quad2D_check_box, Gui::ALIGN_LEFT);
	quad2D_check_box->getEventChanged().connect(*this, [this, quad2D_check_box]() {
		visualizer_usage->renderQuad2D = quad2D_check_box->isChecked();
		});
	quad2D_check_box->setChecked(visualizer_usage->renderQuad2D);

	//========== Enable rectangle checkbox =========//
	WidgetCheckBoxPtr rectangle_check_box = WidgetCheckBox::create("Rectangle");
	params->addChild(rectangle_check_box, Gui::ALIGN_LEFT);
	rectangle_check_box->getEventChanged().connect(*this, [this, rectangle_check_box]() {
		visualizer_usage->renderRectangle = rectangle_check_box->isChecked();
		});
	rectangle_check_box->setChecked(visualizer_usage->renderRectangle);

	//========== Enable message2D checkbox =========//
	WidgetCheckBoxPtr message2D_check_box = WidgetCheckBox::create("Message2D");
	params->addChild(message2D_check_box, Gui::ALIGN_LEFT);
	message2D_check_box->getEventChanged().connect(*this, [this, message2D_check_box]() {
		visualizer_usage->renderMessage2D = message2D_check_box->isChecked();
		});
	message2D_check_box->setChecked(visualizer_usage->renderMessage2D);
}

void VisualizerSample::shutdown()
{
	Visualizer::setEnabled(false);
	window.shutdown();
}

```

## VisualizerUsage.cpp

```cpp
#include "VisualizerUsage.h"
#include <UnigineVisualizer.h>


using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(VisualizerUsage);

void VisualizerUsage::init()
{
	if (!node_boundBox_example || !node_boundSphere_example)
	{
		Log::error("VisualizerUsage::init() example nodes are not assigned: \n");
	}
	object_example = checked_ptr_cast<Object>(node_object_example.get());
	object_solid_example = checked_ptr_cast<Object>(node_object_solid_example.get());

	surface_example = checked_ptr_cast<Object>(node_surface_example.get());
	surface_solid_example = checked_ptr_cast<Object>(node_surface_solid_example.get());

	object_surface_boundBox_example = checked_ptr_cast<Object>(node_object_surface_boundBox_example.get());
	object_surface_boundSphere_example = checked_ptr_cast<Object>(node_object_surface_boundSphere_example.get());

	if (!object_example || !object_solid_example || !surface_example || !surface_solid_example
		|| !object_surface_boundBox_example || !object_surface_boundSphere_example)
	{
		Log::error("VisualizerUsage::init() example objects are not assigned: \n");
	}
	for (int i = 0; i < postament_nodes.size(); i++)
	{
		if (postament_nodes.get(i).get() == nullptr)
		{
			Log::error("VisualizerUsage::init() postament node with index: %i is not assigned\n", i);
		}
	}

	Visualizer::setMode(Visualizer::MODE_ENABLED_DEPTH_TEST_DISABLED);
}

void VisualizerUsage::update3D()
{
	int i = 0;
	//1-10
	Vec3 current_point = getPostamentPoint(i);
	Visualizer::renderLine3D(current_point, current_point + Vec3_up, current_point + Vec3_up + Vec3_right / 2, current_point + Vec3_up * 2, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderPoint3D(current_point, 0.5, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderTriangle3D(current_point, current_point + Vec3_down / 2 + Vec3_left / 2, current_point + Vec3_down / 2 + Vec3_right / 2, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderQuad3D(current_point + Vec3_left / 2, current_point + Vec3_left / 2 + Vec3_up, current_point + Vec3_up + Vec3_right / 2, current_point + Vec3_right / 2, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderBillboard3D(current_point, 0.5f, vec4_zero, true);// try use setTextureName
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderVector(current_point + Vec3_down / 2 + Vec3_left / 2, current_point + Vec3_up / 2 + Vec3_right / 2, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderDirection(current_point + Vec3_down / 2 + Vec3_left / 2, vec3(1, 0, 1), vec4_red, 0.25f, false);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderBox(vec3_one, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidBox(vec3_one, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	mat4 proj = perspective(60, 16 / 9, 0.1f, 1);
	Unigine::Math::Mat4 modelview = Unigine::Math::lookAt(current_point + Vec3_left / 2, current_point, Unigine::Math::vec3_up);
	//transformation matrix equals inversed modelview
	Visualizer::renderFrustum(proj, Math::inverse(modelview), vec4_red);
	i++;


	//10-20
	current_point = getPostamentPoint(i);
	Visualizer::renderCircle(0.5, Mat4(quat_identity * quat(90, 0, 0), current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSector(0.5, 60, Mat4(quat_identity * quat(90, 0, 0), current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderCone(0.5, 30, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSphere(0.5, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidSphere(0.5, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderCapsule(0.5, 0.5, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidCapsule(0.5, 0.5, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderCylinder(1, 1, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidCylinder(1, 1, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	vec3 center = vec3(0, 0, 0);// check out documentation for center format information
	Visualizer::renderMessage3D(current_point, center, "renderMessage3D exapmle", vec4_red);
	i++;

	//20-30
	current_point = getPostamentPoint(i);
	Visualizer::renderEllipse(vec3(0.5, 1, 1.5), Mat4((quat_identity), current_point + Vec3_up), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidEllipse(vec3(0.5, 1, 1.5), Mat4((quat_identity), current_point + Vec3_up), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	BoundBox bb = BoundBox(vec3(-0.5f, -0.5f, -0.5f), vec3(0.5f, 0.5f, 0.5f));
	Visualizer::renderBoundBox(bb, Mat4(quat_identity * quat(90, 0, 0), current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	BoundSphere bs = BoundSphere(vec3_zero, 0.5f);
	Visualizer::renderBoundSphere(bs, Mat4(quat_identity, current_point), vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderNodeBoundBox(node_boundBox_example, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderNodeBoundSphere(node_boundSphere_example, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderObject(object_example, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidObject(object_solid_example, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderObjectSurface(surface_example, 0, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderSolidObjectSurface(surface_solid_example, 0, vec4_red);
	i++;


	//30-32
	current_point = getPostamentPoint(i);
	Visualizer::renderObjectSurfaceBoundBox(object_surface_boundBox_example, 0, vec4_red);
	i++;

	current_point = getPostamentPoint(i);
	Visualizer::renderObjectSurfaceBoundSphere(object_surface_boundSphere_example, 0, vec4_red);
	i++;
}
void VisualizerUsage::update2D()
{
	if (renderPoint2D) Visualizer::renderPoint2D(vec2(0.1f, 0.5), 0.01, vec4_red);
	if (renderLine2D) Visualizer::renderLine2D(vec2(0.1, 0.55), vec2(0.15, 0.55), vec2(0.15, 0.60), vec2(0.20, 0.60), vec4_red);
	if (renderTriangle2D) Visualizer::renderTriangle2D(vec2(0.2, 0.65), vec2(0.1, 0.62), vec2(0.1, 0.68), vec4_red);
	if (renderQuad2D) Visualizer::renderQuad2D(vec2(0.1, 0.8), vec2(0.08, 0.75), vec2(0.1, 0.70), vec2(0.12, 0.75), vec4_red);
	if (renderRectangle) Visualizer::renderRectangle(vec4(0.1f,0.1f , 0.15f, 0.15f), vec4_red);
	if (renderMessage2D) Visualizer::renderMessage2D(vec3(0.1, 0.95, 0), vec3(0, 0, 0), "renderMessage2D example", vec4_red);
}
void VisualizerUsage::update()
{
	update3D();
	update2D();
}

Unigine::Math::Vec3 VisualizerUsage::getPostamentPoint(int index)
{
	Vec3 result = Vec3_one;
	if (index < postament_nodes.size())
	{
		NodePtr node = postament_nodes.get(index).get();
		if (node)
		{
			result = node->getWorldPosition();
		}
		else {
			Log::message("VisualizerUsage::getNextPostamentPoint postament_nodes: Node with index:%i is nullptr\n", index);
		}
	}
	else {
		Log::message("Visualizer usage doesn't have enough pedestal's display nodes to draw all visualizer examples\n");
	}
	return result;
}
```

## WakeWaveTrail.cpp

```cpp
#include "WakeWaveTrail.h"

#include <UnigineVisualizer.h>
#include <UnigineGame.h>
#include <UnigineProfiler.h>
#include <UnigineEditor.h>


REGISTER_COMPONENT(WakeWaveTrail);

void WakeWaveTrail::clearButton()
{
	path_points.clear();
	clear_button = false;
	need_remove_last = false;
}

void WakeWaveTrail::saveMesh()
{
	if (mesh)
	{
		String name = String::format("mesh_%f.mesh", Game::getTime());
		mesh->save(name);
		Log::warning("saved to %s\n", name.get());
	}
	save_mesh = false;
}

void WakeWaveTrail::init()
{
	if (!mesh_decal_node.isEmpty())
	{
		decal = checked_ptr_cast<DecalMesh>(mesh_decal_node.get());
		if (!decal)
		{
			Log::error("WakeWaveTrail should be on decal mesh!!!\n");
			return;
		}
		itransform = decal->getIWorldTransform();
	}
	if (!mesh)
		mesh = Mesh::create();
}

void WakeWaveTrail::update()
{
	if (clear_button)
		clearButton();
	if (save_mesh)
		saveMesh();

	init();
	if (!decal)
		return;

	addPoint(decal->getIWorldTransform() * node->getWorldPosition());
	hide();
	build_mesh();

	draw_debug();

	if (path_points.size() > 1)
	{
		const auto &first = path_points.first();
		const auto &last = path_points.last();

		start_distance = first.distance;
		start_time = first.time;

		end_distance = last.distance;
		end_time = last.time;

		num_quad = path_points.size();

		auto mat = Editor::isLoaded() ? decal->getMaterial() : decal->getMaterialInherit();
		if (mat)
		{
			mat->setParameterInt(num_quad_material_param_name.get(), num_quad);
			mat->setParameterFloat(start_time_material_param_name.get(), start_time);
			mat->setParameterFloat(end_time_material_param_name.get(), end_time);
			mat->setParameterFloat(start_distance_material_param_name.get(), start_distance);
			mat->setParameterFloat(end_distance_material_param_name.get(), end_distance);
			mat->setParameterFloat(speed_material_param_name.get(), speed);
			mat->setParameterFloat(max_distance_material_param_name.get(), max_distance_hide);
			mat->setParameterFloat(width_material_param_name.get(), width);
		}
	}
}

void WakeWaveTrail::shutdown()
{
}

void WakeWaveTrail::addPoint(const Vec3 &point)
{
	if (prev_pos == point)
		return;

	float distance_between_frame = toFloat((prev_pos - point).length());
	speed = distance_between_frame / Game::getIFps();

	if (distance_between_frame < distance_eps)
		return;

	if (path_points.size() == 0)
	{
		add_point_internal(point);
		prev_frame_dir = vec3_zero;
		return;
	} else
	{
		if (need_remove_last)
		{
			path_points.removeLast();
			need_remove_last = false;
		}
		add_point_internal(point);
		calculate_last_tangents();

		vec3 frame_dir = vec3(normalize(point - prev_pos));
		if (!compare(prev_frame_dir, frame_dir, direction_eps))
		{
			prev_frame_dir = frame_dir;
		} else
		{
			need_remove_last = true;
		}
	}
	prev_pos = point;
}

void WakeWaveTrail::calculate_last_tangents()
{
	auto &p0 = path_points[path_points.size() - 1];
	auto &p1 = path_points[path_points.size() - 2];

	Vec3 distance = p0.point - p1.point;
	p0.distance = p1.distance + toFloat(distance.length());

	vec3 direction = vec3(normalize(distance));
	p1.forward = direction;
	p0.forward = direction; // it will be override next step

	if (path_points.size() > 2)
	{
		const auto &p2 = path_points[path_points.size() - 3]; // predposlednyaya
		vec3 right_1 = normalize(cross(p2.forward, vec3_up));
		vec3 right_2 = normalize(cross(p1.forward, vec3_up));
		p1.right = normalize((right_1 + right_2) * 0.5);
		p0.right = p1.right; // it will be override next step
	}
}

void WakeWaveTrail::draw_debug()
{
	if (debug)
	{
		for (int i = 1; i < path_points.size(); i++)
		{
			const auto &p0 = path_points[i - 1];
			const auto &p1 = path_points[i];
			Visualizer::renderLine3D(p0.point + Vec3(p0.right * width), p1.point + Vec3(p1.right * width), vec4_green);
			Visualizer::renderLine3D(p0.point - Vec3(p0.right * width), p1.point - Vec3(p1.right * width), vec4_red);
			Visualizer::renderLine3D(p1.point + Vec3(p1.right * width), p1.point - Vec3(p1.right * width), vec4_blue);
			Visualizer::renderLine3D(p0.point, p1.point, vec4_white);
			Visualizer::renderMessage3D(p0.point, vec3_up, String::ftoa(p0.time), vec4_white);
		}
		Log::message("before %d after %d\n", path_points.size(), path_points.size());
	}
}

void WakeWaveTrail::build_mesh()
{
	if (path_points.size() < 1)
		return;

	mesh->clear();
	mesh->addSurface("");

	auto add_point_func = [this](const vec3 &pos, const vec3 &forward, const vec3 &right, float w, int number, float time, float distance, float speed) {
		mesh->addVertex(pos - right * w, 0);
		mesh->addVertex(pos, 0);
		mesh->addVertex(pos + right * w, 0);
		mesh->addTexCoord0(vec2(1, distance), 0);
		mesh->addTexCoord0(vec2(0.5, distance), 0);
		mesh->addTexCoord0(vec2(0, distance), 0);
		mesh->addTexCoord1(vec2(1, time), 0);
		mesh->addTexCoord1(vec2(0.5, time), 0);
		mesh->addTexCoord1(vec2(0, time), 0);
		mesh->addNormal(vec3_up, 0);
		mesh->addNormal(vec3_up, 0);
		mesh->addNormal(vec3_up, 0);
		mesh->addTangent(quat(-right, -forward, vec3_up), 0);
		mesh->addTangent(quat(right, forward, vec3_up), 0);
		mesh->addTangent(quat(right, forward, vec3_up), 0);
		//		mesh->addColor(vec4(time, number, speed, 0), 0);
		//		mesh->addColor(vec4(time, number, speed, 0), 0);
	};

	auto link_indices = [this](int m_num_quad) {
		//		m_num_quad *= 2;
		//		mesh->addCIndex(0 + m_num_quad, 0);
		//		mesh->addCIndex(1 + m_num_quad, 0);
		//		mesh->addCIndex(2 + m_num_quad, 0);
		//		mesh->addCIndex(1 + m_num_quad, 0);
		//		mesh->addCIndex(3 + m_num_quad, 0);
		//		mesh->addCIndex(2 + m_num_quad, 0);

		//		mesh->addTIndex(0 + m_num_quad, 0);
		//		mesh->addTIndex(1 + m_num_quad, 0);
		//		mesh->addTIndex(2 + m_num_quad, 0);
		//		mesh->addTIndex(1 + m_num_quad, 0);
		//		mesh->addTIndex(3 + m_num_quad, 0);
		//		mesh->addTIndex(2 + m_num_quad, 0);
		m_num_quad *= 3;

		mesh->addCIndex(0 + m_num_quad, 0);
		mesh->addCIndex(1 + m_num_quad, 0);
		mesh->addCIndex(3 + m_num_quad, 0);

		mesh->addCIndex(1 + m_num_quad, 0);
		mesh->addCIndex(4 + m_num_quad, 0);
		mesh->addCIndex(3 + m_num_quad, 0);

		mesh->addCIndex(1 + m_num_quad, 0);
		mesh->addCIndex(2 + m_num_quad, 0);
		mesh->addCIndex(4 + m_num_quad, 0);

		mesh->addCIndex(2 + m_num_quad, 0);
		mesh->addCIndex(5 + m_num_quad, 0);
		mesh->addCIndex(4 + m_num_quad, 0);

		mesh->addTIndex(0 + m_num_quad, 0);
		mesh->addTIndex(1 + m_num_quad, 0);
		mesh->addTIndex(3 + m_num_quad, 0);
		mesh->addTIndex(1 + m_num_quad, 0);
		mesh->addTIndex(4 + m_num_quad, 0);
		mesh->addTIndex(3 + m_num_quad, 0);
		mesh->addTIndex(1 + m_num_quad, 0);
		mesh->addTIndex(2 + m_num_quad, 0);
		mesh->addTIndex(4 + m_num_quad, 0);
		mesh->addTIndex(2 + m_num_quad, 0);
		mesh->addTIndex(5 + m_num_quad, 0);
		mesh->addTIndex(4 + m_num_quad, 0);
	};

	BoundBox bb;
	for (int i = 0; i < path_points.size(); i++)
	{
		const auto &p = path_points[i];
		vec3 point, r, f;
		mul(point, itransform, p.point);
		mul3(r, itransform, p.right);
		mul3(f, itransform, p.forward);
		bb.expand(BoundSphere(point, bound_increase));
		add_point_func(point, f, r, width, i, p.time, p.distance, p.speed);
		if (i == 0)
			continue;
		link_indices(i - 1);
	}

	mesh->setBoundBox(bb);

	if (decal && path_points.size() > 2)
		decal->applyCopyMeshProceduralForce(mesh);
}

void WakeWaveTrail::hide()
{
	if (path_points.size() < 2)
		return;

	float d = path_points.last().distance - path_points[1].distance;
	if (d > max_distance_hide)
	{
		path_points.removeFirst();
	}
}

void WakeWaveTrail::add_point_internal(const Vec3 &point)
{
	auto &p = path_points.append();
	p.point = point;
	p.time = Game::getTime();
	p.speed = speed;
}

```

## WaterFetchIntersection.cpp

```cpp
#include "WaterFetchIntersection.h"

#include <UnigineVisualizer.h>

#include <functional>

REGISTER_COMPONENT(WaterFetchIntersection);

using namespace Unigine;
using namespace Math;

void WaterFetchIntersection::init()
{
	water = checked_ptr_cast<ObjectWaterGlobal>(water_node.get());

	Visualizer::setEnabled(true);
	init_gui();
}

void WaterFetchIntersection::shutdown()
{
	Visualizer::setEnabled(false);
	shutdown_gui();
}

void WaterFetchIntersection::init_gui()
{
	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();

	auto hbox_request_type = WidgetHBox::create();
	auto request_type_label = WidgetLabel::create("Request type: ");
	auto fetch_button = WidgetButton::create("Fetch");
	auto intersection_button = WidgetButton::create("Intersection");
	normal_cb = WidgetCheckBox::create("Show normals");

	fetch_button->setToggleable(true);
	intersection_button->setToggleable(true);

	intersection_button->setToggled(true);
	fetch = false;

	hbox_request_type->addChild(request_type_label);
	hbox_request_type->addChild(fetch_button);

	hbox_request_type->addChild(intersection_button);
	hbox_request_type->addChild(normal_cb);

	parameters->addChild(hbox_request_type, Gui::ALIGN_LEFT);

	fetch_button->getEventChanged().connect(*this, [this, fetch_button, intersection_button]() {
			fetch = fetch_button->isToggled();
			intersection_button->setToggled(!fetch);
		});

	intersection_button->getEventChanged().connect(*this, [this, fetch_button, intersection_button]() {
			fetch = !intersection_button->isToggled();
			fetch_button->setToggled(fetch);
		});

	sample_description_window.addIntParameter("Number of requests", "num request", num_intersection, 1, 10000,
		[this](int v) { num_intersection = v; });

	sample_description_window.addFloatParameter("Point size", "Point size", intersect_point_size, 0.1f, 1.f,
		[this](float v) { intersect_point_size = v; });

	sample_description_window.addFloatParameter("Beaufort", "beaufort", 0.f, 0.f, 12.f,
		[this](float v) { water->setBeaufort(v); });

	sample_description_window.addParameterSpacer();

	sample_description_window.addFloatParameter("Fetch Amplitude Threshold", "fetch amplitude threshold",
		water->getFetchAmplitudeThreshold(), 0.001f, 0.5f,
		[this](float v) { water->setFetchAmplitudeThreshold(v); });

	sample_description_window.addIntParameter("Fetch Steepness Quality", "fetch steepness quality",
		water->getFetchSteepnessQuality(), 0, 4, [this](int v) {
			water->setFetchSteepnessQuality(ObjectWaterGlobal::STEEPNESS_QUALITY(v));
		});

	sample_description_window.addParameterSpacer();

	sample_description_window.addFloatParameter("Intersection Amplitude Threshold",
		"intersection amplitude threshold", water->getIntersectionAmplitudeThreshold(), 0.001f,
		0.5f, [this](float v) { water->setIntersectionAmplitudeThreshold(v); });

	sample_description_window.addIntParameter("Intersection Steepness Quality",
		"intersection steepness quality", static_cast<int>(water->getIntersectionSteepnessQuality()), 0, 4,
		[this](int v) {
			water->setIntersectionSteepnessQuality(ObjectWaterGlobal::STEEPNESS_QUALITY(v));
		});

	sample_description_window.addFloatParameter("Intersection Precision", "intersection precision",
		water->getIntersectionPrecision(), 0.001f, 2.0f,
		[this](float v) { water->setIntersectionPrecision(v); });

	sample_description_window.addFloatParameter("Intersection Angle", "intersection angle", 5.f,
		-30.f, 30.f, [this](float v) { water->setIntersectionPrecision(v); });
}

void WaterFetchIntersection::shutdown_gui()
{
	sample_description_window.shutdown();
}

void WaterFetchIntersection::update()
{
	bool normal_show = normal_cb->isChecked();
	int count = (int)Math::sqrtFast((float)num_intersection);
	ObjectIntersectionPtr oi = ObjectIntersection::create();
	ObjectIntersectionNormalPtr oin = ObjectIntersectionNormal::create();
	for (int i = 0; i < count; i++)
	{
		for (int j = 0; j < count; j++)
		{
			Vec3 pos = Vec3((float)i, (float)j, 0);
			if (fetch)
			{
				float v = water->fetchHeight(pos);
				pos.z += v;
				Visualizer::renderPoint3D(pos, intersect_point_size, vec4_blue);

				if (normal_show)
				{
					vec3 n = water->fetchNormal(pos);
					Visualizer::renderVector(pos, pos + Vec3(n), vec4_white);
				}
			}
			else
			{
				Vec3 dir(Math::sin(intersection_angle * Consts::DEG2RAD), 0,
					Math::cos(intersection_angle * Consts::DEG2RAD));

				if (normal_show)
				{
					if (water->getIntersection(pos + dir * 100, pos - dir * 100, oin, 0))
					{
						Visualizer::renderPoint3D(oin->getPoint(), intersect_point_size,
							vec4_green);
						Visualizer::renderVector(oin->getPoint(),
							oin->getPoint() + Vec3(oin->getNormal()), vec4_white);
						Visualizer::renderVector(oin->getPoint() + dir * 2.f, oin->getPoint(),
							vec4_blue);
					}
				}
				else
				{
					if (water->getIntersection(pos + dir * 100, pos - dir * 100, oi, 0))
					{
						Visualizer::renderPoint3D(oi->getPoint(), intersect_point_size, vec4_green);
						Visualizer::renderVector(oi->getPoint() + dir * 2.f, oi->getPoint(),
							vec4_blue);
					}
				}
			}
		}
	}
}

```

## Waves.cpp

```cpp
#include "Waves.h"

#include <UnigineInput.h>
#include <UnigineWorld.h>
REGISTER_COMPONENT(Waves);
void Waves::init()
{
	water = Unigine::checked_ptr_cast<Unigine::ObjectWaterGlobal>(
		Unigine::World::getNodeByType(Unigine::Node::TYPE::OBJECT_WATER_GLOBAL));

	water->setBeaufort(static_cast<float>(0.f));
}

```

## WeaponClipping.cpp

```cpp
#include "WeaponClipping.h"

#include <UnigineBase.h>
#include <UnigineMathLibVec4.h>
#include <UnigineRender.h>
#include <UnigineGame.h>
#include <UnigineVisualizer.h>

REGISTER_COMPONENT(WeaponClipping);

using namespace Unigine;
using namespace Math;

void WeaponClipping::init()
{
	init_handle = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);
	ivec2 window_size = WindowManager::getMainWindow()->getSize();
	current_width = window_size.x;
	current_height = window_size.y;

	player = checked_ptr_cast<Player>(camera.get());
	weapon_player = checked_ptr_cast<Player>(weapon_camera.get());

	viewport = Viewport::create();
	viewport->setNodeLightUsage(Viewport::USAGE_NODE_LIGHT | Viewport::USAGE_WORLD_LIGHT);
	viewport->setSkipFlags(Viewport::SKIP_VELOCITY_BUFFER);

	texture = Texture::create();
	create_texture_2D(*texture);

	WindowManager::getMainWindow()->getEventResized().connect(this,
		&WeaponClipping::update_screen_size);

	Render::getEventBeginPostMaterials().connect(this, &WeaponClipping::render_callback);
}

void WeaponClipping::update()
{
	weapon_player->setTransform(player->getCamera()->getIModelview());
}

void WeaponClipping::create_texture_2D(Unigine::Texture &in_texture)
{
	in_texture.create2D(current_width, current_height, Texture::FORMAT_RGBA8,
		Texture::SAMPLER_FILTER_LINEAR | Texture::SAMPLER_ANISOTROPY_16
			| Texture::FORMAT_USAGE_RENDER);
}

void WeaponClipping::update_screen_size()
{
	ivec2 window_size = WindowManager::getMainWindow()->getSize();
	int app_width = window_size.x;
	int app_height = window_size.y;
	if (app_width != current_width || app_height != current_height)
	{
		current_width = app_width;
		current_height = app_height;
		create_texture_2D(*texture);
	}
}

void WeaponClipping::shutdown()
{
	Input::setMouseHandle(init_handle);
}

void WeaponClipping::post_update()
{
	if (Game::getPlayer() != player)
		return;

	RenderState::saveState();
	RenderState::clearStates();
	RenderState::setViewport(0, 0, current_width, current_height);
	auto target = Render::getTemporaryRenderTarget();
	target->bindColorTexture(0, texture);

	target->enable();
	{
		bool flare = Render::isLightsLensFlares();
		Render::setLightsLensFlares(false);
		RenderState::clearBuffer(RenderState::BUFFER_ALL, Math::vec4_zero);

		// render near plane with weapon to texture
		if (texture)
		{
			is_rendering_weapon = true;
			viewport->renderTexture2D(weapon_player->getCamera(), texture);
			is_rendering_weapon = false;
		}

		Render::setLightsLensFlares(flare);
	}

	target->disable();

	target->unbindColorTexture(0);
	RenderState::restoreState();
}

void WeaponClipping::render_callback()
{
	if (Game::getPlayer() != player)
		return;

	if (is_rendering_weapon)
	{
		// skip render to screen when we rendering weapon into custom texture
		return;
	}

	RenderState::saveState();
	RenderState::clearStates();
	RenderState::setViewport(0, 0, current_width, current_height);

	auto target = Render::getTemporaryRenderTarget();
	target->bindColorTexture(0, Renderer::getTextureColor());

	target->enable();
	{
		RenderState::setBlendFunc(RenderState::BLEND_SRC_ALPHA,
			RenderState::BLEND_ONE_MINUS_SRC_ALPHA);

		// render texture with weapon to screen
		if (texture)
			Render::renderScreenMaterial("Unigine::render_copy_2d", texture);
	}
	target->disable();

	target->unbindColorTexture(0);
	RenderState::restoreState();
	Render::releaseTemporaryRenderTarget(target);
}

```

## WeaponClippingSample.cpp

```cpp
#include "WeaponClippingSample.h"
#include "WeaponClipping.h"

using namespace Unigine;

REGISTER_COMPONENT(WeaponClippingSample);

void WeaponClippingSample::init()
{
	WeaponClipping* weapon_clipping_component = ComponentSystem::get()->getComponent<WeaponClipping>(weapon_clipping_node);

	if (!weapon_clipping_component)
		return;

	sample_description_window.createWindow();

	auto parameters = sample_description_window.getParameterGroupBox();
	auto hbox = WidgetHBox::create();
	auto checkbox = WidgetCheckBox::create();
	checkbox->getEventClicked().connect(*this, [weapon_clipping_component, this, checkbox]() {
		int flags = Viewport::SKIP_VELOCITY_BUFFER;
		if (checkbox->isChecked())
			flags |= Viewport::SKIP_SHADOWS;

		weapon_clipping_component->getRenderViewport()->setSkipFlags(flags);
	});

	auto label = WidgetLabel::create("Skip shadows");

	hbox->addChild(label);
	hbox->addChild(checkbox);

	parameters->addChild(hbox, Gui::ALIGN_LEFT);
}

void WeaponClippingSample::shutdown()
{
	sample_description_window.shutdown();
}


```

## WheelAttachment.cpp

```cpp
#include "WheelAttachment.h"

REGISTER_COMPONENT(WheelAttachment);

using namespace Unigine;
using namespace Math;

void WheelAttachment::init()
{
	wheel_parent = attached_to_wheel->getParent();
	wheel_local_transform = wheel_parent->getIWorldTransform() * attached_to_wheel->getWorldTransform();
	track_local_transform = attached_to_wheel->getIWorldTransform() * node->getWorldTransform();
}

void WheelAttachment::update()
{
	// change position only, ignore rotation of the wheel
	wheel_local_transform.setColumn3(3, attached_to_wheel->getPosition());
	node->setWorldTransform(wheel_parent->getWorldTransform() * wheel_local_transform * track_local_transform);
}

```

## WidgetAnimationSample.cpp

```cpp
#include <UnigineGame.h>
#include <UnigineEngine.h>
#include <UnigineLogic.h>
#include <UnigineWorld.h>
#include <UnigineAnimation.h>
#include <UniginePrimitives.h>
#include <UnigineComponentSystem.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class WidgetAnimationSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(WidgetAnimationSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_SHUTDOWN(shutdown);

private:
	void init()
	{
		// create tracks and playback
		create_animations();

		// create widgets
		EngineWindowViewportPtr main_window = WindowManager::getMainWindow();
		widgets = WidgetVBox::create();

		WidgetPtr player_0_label = WidgetLabel::create("Player 0");
		player_0_label->setFontOutline(1);
		player_0_label->setFontSize(100);
		player_0_label->setPosition(250, 300);
		player_0_label->setFontColor(vec4_red);
		widgets->addChild(player_0_label, Gui::ALIGN_OVERLAP);

		WidgetPtr player_1_label = WidgetLabel::create("Player 1");
		player_1_label->setFontOutline(1);
		player_1_label->setFontSize(100);
		player_1_label->setPosition(975, 500);
		player_1_label->setFontColor(vec4_green);
		widgets->addChild(player_1_label, Gui::ALIGN_OVERLAP);

		WidgetPtr vs_label = WidgetLabel::create("vs");
		vs_label->setFontOutline(1);
		vs_label->setFontSize(100);
		vs_label->setPosition(750, 400);
		widgets->addChild(vs_label, Gui::ALIGN_OVERLAP);

		main_window->addChild(widgets, Gui::ALIGN_OVERLAP);

		// set up runtime binds in the runtime animation objects
		{
			AnimationTrackPtr track = playback->getTrack();

			AnimationObjectRuntimePtr anim_obj;
			AnimationBindRuntimePtr bind;

			anim_obj = checked_ptr_cast<AnimationObjectRuntime>(track->getObject(0));
			bind = anim_obj->getBind();
			bind->setWidget(player_0_label);
			anim_obj->setBind(bind);

			anim_obj = checked_ptr_cast<AnimationObjectRuntime>(track->getObject(1));
			bind = anim_obj->getBind();
			bind->setWidget(player_1_label);
			anim_obj->setBind(bind);

			anim_obj = checked_ptr_cast<AnimationObjectRuntime>(track->getObject(2));
			bind = anim_obj->getBind();
			bind->setWidget(vs_label);
			anim_obj->setBind(bind);
		}

		playback->play();
	}

	void shutdown()
	{
		widgets.deleteLater();

		playback->stop();
	}

	void create_animations()
	{
		// create new track
		AnimationTrackPtr track = AnimationTrack::create();

		// create runtime animation objects
		AnimationObjectRuntimePtr player_0_obj = AnimationObjectRuntime::create("widget_player_0");
		AnimationObjectRuntimePtr player_1_obj = AnimationObjectRuntime::create("widget_player_1");
		AnimationObjectRuntimePtr vs_obj = AnimationObjectRuntime::create("widget_vs");

		track->addObject(player_0_obj);
		track->addObject(player_1_obj);
		track->addObject(vs_obj);

		// create modifiers
		auto player_0_pos_modifier = AnimationModifierInt::create("widget.position_x");
		player_0_pos_modifier->addValue(0.0f, 0);
		player_0_pos_modifier->addValue(0.25f, 250);
		player_0_pos_modifier->addValue(2.75f, 250);
		player_0_pos_modifier->addValue(3.0f, 0);
		player_0_pos_modifier->addValue(5.0f, 0);
		track->addObjectModifier(player_0_obj, player_0_pos_modifier);

		auto player_1_pos_modifier = AnimationModifierInt::create("widget.position_x");
		player_1_pos_modifier->addValue(0.0f, 1225);
		player_1_pos_modifier->addValue(0.25f, 975);
		player_1_pos_modifier->addValue(2.75f, 975);
		player_1_pos_modifier->addValue(3.0f, 1225);
		player_1_pos_modifier->addValue(5.0f, 1225);
		track->addObjectModifier(player_1_obj, player_1_pos_modifier);

		auto player_color_modifier = AnimationModifierFloat::create("widget.font_color_w");
		player_color_modifier->addValue(0.0f, 0.001f);
		player_color_modifier->addValue(0.25f, 1.0f);
		player_color_modifier->addValue(2.75f, 1.0f);
		player_color_modifier->addValue(3.0f, 0.001f);
		player_color_modifier->addValue(5.0f, 0.001f);
		track->addObjectModifier(player_0_obj, player_color_modifier);
		track->addObjectModifier(player_1_obj, player_color_modifier);

		auto player_font_size_modifier = AnimationModifierInt::create("widget.font_size");
		player_font_size_modifier->addValue(0.0f, 80);
		player_font_size_modifier->addValue(0.25f, 100);
		player_font_size_modifier->addValue(2.75f, 100);
		player_font_size_modifier->addValue(3.0f, 80);
		player_font_size_modifier->addValue(5.0f, 80);
		track->addObjectModifier(player_0_obj, player_font_size_modifier);
		track->addObjectModifier(player_1_obj, player_font_size_modifier);

		auto vs_color_modifier = AnimationModifierFVec4::create("widget.font_color");
		vs_color_modifier->addValue(0.0f, vec4(0.0f, 1.0f, 1.0f, 0.001f));
		vs_color_modifier->addValue(0.25f, vec4(0.0f, 1.0f, 1.0f, 0.001f));
		vs_color_modifier->addValue(0.3f, vec4(0.0f, 1.0f, 1.0f, 1.0f));
		vs_color_modifier->addValue(1.5f, vec4(1.0f, 1.0f, 0.0f, 1.0f));
		vs_color_modifier->addValue(2.70f, vec4(0.0f, 1.0f, 1.0f, 1.0f));
		vs_color_modifier->addValue(2.75f, vec4(0.0f, 1.0f, 1.0f, 0.001f));
		vs_color_modifier->addValue(3.0f, vec4(0.0f, 1.0f, 1.0f, 0.001f));
		vs_color_modifier->addValue(5.0f, vec4(0.0f, 1.0f, 1.0f, 0.001f));
		track->addObjectModifier(vs_obj, vs_color_modifier);

		// create playback for track
		playback = AnimationPlayback::create();
		playback->setTrack(track);
		playback->setLoop(true);
	}

	// ========================================================================================

	AnimationPlaybackPtr playback;
	WidgetPtr widgets;
};

REGISTER_COMPONENT(WidgetAnimationSample);

```

## WidgetClock.cpp

```cpp
#include "WidgetClock.h"

#include "GuiToTexture.h"

REGISTER_COMPONENT(WidgetClock);

using namespace Unigine;

void WidgetClock::setCenterPosition(const Math::ivec2 &pos)
{
	position = pos;
	adjust_screen_position();
}

void WidgetClock::init()
{
	gui_to_texture = ComponentSystem::get()->getComponent<GuiToTexture>(node);
	// Disable auto update, because we will update gui manually in set_time() method
	gui_to_texture->setAutoUpdateEnabled(false);

	// Get our custom gui
	const GuiPtr gui = gui_to_texture->getGui();


	widget_timer = WidgetLabel::create(gui);
	widget_timer->setFontSize(150);

	// Add widget as a child in gui
	gui->addChild(widget_timer, Gui::ALIGN_OVERLAP);

	setCenterPosition(gui_to_texture->getTextureResolution() / 2);

	previous_time = std::time(nullptr);
	// Set time and update gui
	set_time(previous_time);
	// Now we don't need to interact with GuiToTexture, it will be updated on its own
	// starting from here, we will just update the state of our custom widget
}

void WidgetClock::update()
{
	auto clock_equal = [](std::time_t left, std::time_t right) {
		return Math::abs(difftime(left, right)) < 1.;
	};

	const std::time_t now = std::time(nullptr);
	if (clock_equal(now, previous_time))
	{
		return;
	}

	set_time(now);
	previous_time = now;
}

void WidgetClock::adjust_screen_position() const
{
	Math::ivec2 widget_size;
	widget_size.y = widget_timer->getTextRenderSize(widget_timer->getText()).y;
	widget_size.x = widget_timer->getTextRenderSize(widget_timer->getText()).x;
	widget_timer->setPositionX(position.x - widget_size.x / 2);
	widget_timer->setPositionY(position.y - widget_size.y / 2);
}

void WidgetClock::set_time(const std::time_t &time) const
{
	tm tstruct = *localtime(&time);
	widget_timer->setText(String::format("%02d:%02d:%02d", tstruct.tm_hour, tstruct.tm_min, tstruct.tm_sec));
	adjust_screen_position();
	gui_to_texture->renderToTexture();
}
```

## WidgetNoSignal.cpp

```cpp
#include "WidgetNoSignal.h"

#include "GuiToTexture.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(WidgetNoSignal);

using namespace Unigine;
using namespace Math;


void WidgetNoSignal::init()
{
	// get GuiToTexture component
	const auto *gui_to_texture = ComponentSystem::get()->getComponent<GuiToTexture>(node);
	// get gui from GuiToTexture component
	const GuiPtr gui = gui_to_texture->getGui();

	// create a widget that you want to render in gui
	label = WidgetLabel::create(gui);
	label->setFontSize(150);
	label->setText("No Signal");

	container = WidgetVBox::create();
	container->setBackground(1);
	container->setBackgroundColor(vec4_blue);

	container->addChild(label, Gui::ALIGN_EXPAND | Gui::ALIGN_BACKGROUND);

	// add the widget to gui children
	gui->addChild(container, Gui::ALIGN_OVERLAP | Gui::ALIGN_CENTER);
	gui_to_texture->renderToTexture();
	// now we don't need to interact with GuiToTexture, it will be updated on its own
	// starting from here, we will just update the state of our custom widget
}

void WidgetNoSignal::update()
{
	const float frame_speed = label_speed * Game::getIFps();
	const vec2 delta = direction * frame_speed;
	const int pos_x = container->getPositionX();
	const int pos_y = container->getPositionY();

	if (ivec2(pos_x, pos_y) + ivec2(accumulated_delta) == ivec2(pos_x, pos_y))
	{
		accumulated_delta += delta;
		return;
	}
	container->setPositionX(pos_x + ftoi(accumulated_delta.x));
	container->setPositionY(pos_y + ftoi(accumulated_delta.y));
	accumulated_delta = vec2(0.f, 0.f);

	reflect_direction();
}

void WidgetNoSignal::reflect_direction()
{
	const ivec2 size = container->getParentGui()->getSize();

	const int label_pos_x = container->getPositionX();
	const int label_pos_y = container->getPositionY();

	const int x_right_corner_delta = label->getTextRenderSize(label->getText()).x;
	const int y_bottom_corner_delta = label->getTextRenderSize(label->getText()).y;

	const auto left_top_corner_pos = ivec2(label_pos_x, label_pos_y);
	const auto right_top_corner_pos = ivec2(label_pos_x + x_right_corner_delta, label_pos_y);
	const auto left_bottom_corner_pos = ivec2(label_pos_x, label_pos_y + y_bottom_corner_delta);
	const auto right_bottom_corner_pos = ivec2(label_pos_x + x_right_corner_delta,
		label_pos_y + y_bottom_corner_delta);

	// check top left corner
	{
		// intersected with top
		if (left_top_corner_pos.x > 0 && left_top_corner_pos.y < 0)
		{
			container->setPositionY(0);
			direction = reflect_vector(direction, vec2(0, 1));
			return;
		}

		if (left_top_corner_pos.x < 0 && left_top_corner_pos.y > 0)
		{
			container->setPositionX(0);
			direction = reflect_vector(direction, vec2(1, 0));
			return;
		}

		// intersected with corner
		if (left_top_corner_pos.x < 0 && left_top_corner_pos.y < 0)
		{
			direction = vec2(1, 1).normalize();
			container->setPositionX(0);
			container->setPositionY(0);
			return;
		}
	}

	// check top right corner
	{
		// right corner
		if (right_top_corner_pos.x > size.x && right_top_corner_pos.y > 0)
		{
			container->setPositionX(size.x - x_right_corner_delta);
			direction = reflect_vector(direction, vec2(-1, 0));
			return;
		}

		if (right_top_corner_pos.x > size.x && right_top_corner_pos.y < 0)
		{
			container->setPositionX(size.x - x_right_corner_delta);
			container->setPositionY(0);
			direction = vec2(-1, 1);
			return;
		}
	}

	// check left bottom corner
	{
		if (left_bottom_corner_pos.x < 0 && left_bottom_corner_pos.y < size.y)
		{
			container->setPositionX(0);
			direction = reflect_vector(direction, vec2(1, 0));
			return;
		}

		if (left_bottom_corner_pos.x > 0 && left_bottom_corner_pos.y > size.y)
		{
			container->setPositionY(size.y - y_bottom_corner_delta);
			direction = reflect_vector(direction, vec2(0, -1));
			return;
		}

		if (left_bottom_corner_pos.x < 0 && left_bottom_corner_pos.y > size.y)
		{
			container->setPositionX(0);
			container->setPositionY(y_bottom_corner_delta);
			direction = vec2(1, -1);
			return;
		}
	}

	// right bottom corner
	{
		if (right_bottom_corner_pos.x > size.x && right_bottom_corner_pos.y < size.y)
		{
			container->setPositionX(size.x - x_right_corner_delta);
			direction = reflect_vector(direction, vec2(-1, 0));
			return;
		}

		if (right_bottom_corner_pos.x > size.x && right_bottom_corner_pos.y > size.y)
		{
			container->setPositionX(size.x - x_right_corner_delta);
			container->setPositionY(size.y - y_bottom_corner_delta);
			direction = vec2(-1, -1);
			return;
		}
	}
}

vec2 WidgetNoSignal::reflect_vector(const vec2 &vector, const vec2 &normal)
{
	return (vector - normal * dot(vector, normal) * 2).normalize();
}
```

## Window.cpp

```cpp
#include "Window.h"

#include <UnigineConsole.h>

REGISTER_COMPONENT(Window);

using namespace Unigine;
using namespace Math;

void Window::init()
{
	EngineWindowViewportPtr main_window = WindowManager::getMainWindow();

	GuiPtr gui = main_window->getGui();

	window = WidgetWindow::create(gui, "Hello from C++", 4, 4);
	window->setWidth(320);
	window->setSizeable(1);

	auto editline = WidgetEditLine::create(gui, "Edit me");
	window->addChild(editline, Gui::ALIGN_EXPAND);
	editline->getEventChanged().connect(this, &Window::editline_changed);
	editline->setFontSize(16);

	auto button = WidgetButton::create(gui, "Press me");
	window->addChild(button, Gui::ALIGN_EXPAND);
	button->getEventClicked().connect(this, &Window::button_pressed);
	button->setFontSize(18);

	window->arrange();
	main_window->addChild(window, Gui::ALIGN_OVERLAP | Gui::ALIGN_CENTER);

	Console::setOnscreen(true);
}

void Window::shutdown()
{
	window.deleteLater();

	Console::setOnscreen(false);
}

void Window::editline_changed(const Unigine::WidgetPtr &widget)
{
	WidgetEditLinePtr editline = checked_ptr_cast<WidgetEditLine>(widget);
	Log::message("EditLine changed: %s\n", editline->getText());
}

void Window::button_pressed()
{
	Log::message("Button pressed\n");
}

```

## WorldMenu.cpp

```cpp
#include "WorldMenu.h"

#include "SamplesManager.h"

#include <UnigineGame.h>

REGISTER_COMPONENT(WorldMenu);


using namespace Unigine;
using namespace Math;

bool WorldMenu::is_selection_active = false;

void WorldMenu::init()
{
	auto sample = SamplesManager::get()->getSampleByWorldPath(World::getPath());
	if (sample)
	{
		current_sample.title = sample->title;
		current_sample.world_name = sample->world_name;
	}
	else
	{
		current_sample.title = String::filename(World::getPath());
		current_sample.world_name = current_sample.title;
	}

	main_hbox = WidgetHBox::create();
	ivec4 padding = ui_configuration->common->padding.get();
	main_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	// create hint box
	init_hint_box();

	// create back button
	init_back_button();

	init_navigation_bar();
	nav_select->setButtonPressed(is_selection_active);

	auto navigation = WidgetVBox::create();
	navigation->addChild(selector_hbox);
	navigation->addChild(navigation_hbox);

	int space_y = ui_configuration->common->space_between_hint_and_navigation;
	auto aux_vbox = WidgetVBox::create(0, space_y);
	aux_vbox->setPadding(0, 0, -space_y, -space_y);
	aux_vbox->addChild(hint_hbox);
	aux_vbox->addChild(navigation);
	//	main_hbox->addChild(navigation_hbox, Gui::ALIGN_BOTTOM | Gui::ALIGN_CENTER);
	main_hbox->addChild(aux_vbox, Gui::ALIGN_BOTTOM | Gui::ALIGN_CENTER);

	aux_vbox = WidgetVBox::create();
	aux_vbox->addChild(back_hbox, Gui::ALIGN_BOTTOM /*, Gui::ALIGN_OVERLAP*/);

	main_hbox->addChild(aux_vbox, Gui::ALIGN_BOTTOM | Gui::ALIGN_RIGHT);
	WindowManager::getMainWindow()->addChild(main_hbox, Gui::ALIGN_OVERLAP /*| Gui::ALIGN_EXPAND*/);
}

void WorldMenu::update()
{
	bool down = Input::isMouseButtonDown(Input::MOUSE_BUTTON_LEFT);
	bool up = Input::isMouseButtonUp(Input::MOUSE_BUTTON_LEFT);

	// update hint state
	hint_hbox->setHidden(!Input::isMouseGrab());
	hint_hbox->setEnabled(Input::isMouseGrab());

	update_back_button(up, down);
	update_navigation(up, down);

	// adjust UI position in case if window size changed
	EngineWindowViewportPtr window = WindowManager::getMainWindow();
	ivec2 size = window->getClientSize();

	main_hbox->setWidth(size.x);
	main_hbox->arrange();

	main_hbox->setPositionX(
		size.x - ui_configuration->common->right_offset.get() - main_hbox->getWidth());
	main_hbox->setPositionY(
		size.y - ui_configuration->common->bottom_offset.get() - main_hbox->getHeight());
}

void WorldMenu::shutdown()
{
	main_hbox.deleteLater();
	hint_hbox.deleteLater();
	back_hbox.deleteLater();

	selector_hbox.deleteLater();
	for (int i = 0; i < select_buttons.size(); i++)
	{
		delete select_buttons[i];
	}
	select_buttons.clear();

	delete nav_prev;
	delete nav_next;
	delete nav_select;
}

void WorldMenu::init_back_button()
{
	auto &config = ui_configuration->back;
	int space = config->space_between_icon_and_label.get();
	back_hbox = WidgetHBox::create(space, 0);
	back_hbox->setBackground(1);
	back_hbox->setBackgroundTexture(config->background.get());
	back_hbox->setBackgroundColor(config->background_color.get());
	back_hbox->setBackground9Sliced(true);
	vec4 back_offsets = config->background_slice_offsets.get();
	back_hbox->setBackground9SliceOffsets(back_offsets.x, back_offsets.y, back_offsets.z,
		back_offsets.w);
	back_hbox->setBackground9SliceScale(config->background_slice_scale.get());
	ivec4 back_padding = config->background_padding.get();
	back_hbox->setPadding(back_padding.x - space, back_padding.y - space, back_padding.z,
		back_padding.w);

	auto back_button_sprite = WidgetSprite::create();
	back_button_sprite->addLayer();
	back_button_sprite->setLayerTexture(0, config->icon->icon.get());
	back_button_sprite->setLayerColor(0, config->icon->icon_color.get());
	back_button_sprite->setWidth(config->icon->icon_size.get().x);
	back_button_sprite->setHeight(config->icon->icon_size.get().y);
	back_hbox->addChild(back_button_sprite, Gui::ALIGN_LEFT);

	auto back_label = WidgetLabel::create("<p align=center>Back to Main Menu</p>");
	back_label->setFontRich(1);
	back_label->setFont(config->label->font.get());
	back_label->setFontSize(config->label->font_size.get());
	back_label->setFontColor(config->label->font_color.get());
	back_hbox->addChild(back_label, Gui::ALIGN_RIGHT);
}

void WorldMenu::init_hint_box()
{
	auto &config = ui_configuration->hint;
	int space = config->space_x;
	hint_hbox = WidgetHBox::create(space, 0);
	hint_hbox->setBackground(1);
	hint_hbox->setHeight(config->height);
	hint_hbox->setBackgroundTexture(config->background.get());
	hint_hbox->setBackgroundColor(config->background_color.get());
	hint_hbox->setBackground9Sliced(true);
	vec4 hint_offsets = config->background_slice_offsets.get();
	hint_hbox->setBackground9SliceOffsets(hint_offsets.x, hint_offsets.y, hint_offsets.z,
		hint_offsets.w);
	hint_hbox->setBackground9SliceScale(config->background_slice_scale.get());
	ivec4 hint_padding = config->background_padding.get();
	hint_hbox->setPadding(hint_padding.x - space, hint_padding.y - space, hint_padding.z,
		hint_padding.w);

	auto hint_sprite = WidgetSprite::create();
	hint_sprite->addLayer();
	hint_sprite->setLayerTexture(0, config->icon->icon.get());
	hint_sprite->setLayerColor(0, config->icon->icon_color.get());
	hint_sprite->setWidth(config->icon->icon_size.get().x);
	hint_sprite->setHeight(config->icon->icon_size.get().y);
	hint_hbox->addChild(hint_sprite, Gui::ALIGN_LEFT);

	auto hint_label = WidgetLabel::create("Press <b>ESC</b> to interact with UI");
	hint_label->setFontRich(1);
	hint_label->setFont(config->label->font.get());
	hint_label->setFontSize(config->label->font_size.get());
	hint_label->setFontColor(config->label->font_color.get());
	hint_hbox->addChild(hint_label);
}

void WorldMenu::init_navigation_bar()
{
	// create selector box
	init_selector();

	auto &config = ui_configuration->navigation;
	config->button_prev->button_height = config->height;
	config->button_next->button_height = config->height;

	// create selector button
	nav_select = new SelectorButton(current_sample.title, config.get(),
		[this](bool val) { selector_hbox->setHidden(!val); });

	String prev_world, next_world;
	SamplesManager::get()->getPrevNextSamplesID(current_sample.world_name, prev_world, next_world);

	// create button to the prev sample
	const Sample *s = SamplesManager::get()->getSampleByID(prev_world);
	nav_prev = new NavigationButton(prev_world, s ? s->title : prev_world,
		config->button_prev.get(), config->tooltip.get());
	// create button to the next sample
	s = SamplesManager::get()->getSampleByID(next_world);
	nav_next = new NavigationButton(next_world, s ? s->title : next_world,
		config->button_next.get(), config->tooltip.get());

	navigation_hbox = WidgetHBox::create();
	navigation_hbox->addChild(nav_prev->getWidget(), Gui::ALIGN_LEFT);
	navigation_hbox->addChild(nav_select->getWidget(), Gui::ALIGN_LEFT);
	navigation_hbox->addChild(nav_next->getWidget(), Gui::ALIGN_LEFT);
}

void WorldMenu::init_selector()
{
	auto category = SamplesManager::get()->getCategoryBySampleID(current_sample.world_name);
	String title = category ? category->title : "No Category";

	auto &config = ui_configuration->selector;
	int width = ui_configuration->navigation->width;
	config->button->button_width = width;

	// create main box
	selector_hbox = WidgetHBox::create();
	selector_vbox = WidgetVBox::create();
	selector_vbox->setBackground(1);
	selector_vbox->setBackgroundTexture(config->background.get());
	selector_vbox->setBackground9Sliced(true);
	vec4 nav_offsets = config->background_slice_offsets.get();
	selector_vbox->setBackground9SliceOffsets(nav_offsets.x, nav_offsets.y, nav_offsets.z,
		nav_offsets.w);
	selector_vbox->setBackground9SliceScale(config->background_slice_scale.get());
	selector_vbox->setHeight(config->height);
	selector_vbox->setWidth(width);

	// create header with category name
	auto header = WidgetHBox::create();
	ivec4 padding = config->header_padding.get();
	header->setPadding(padding.x, padding.y, padding.z, padding.w);

	String text = "Samples C++ - " + title;
	auto selector_label = WidgetLabel::create(text);
	selector_label->setFont(config->header_font->font.get());
	selector_label->setFontSize(config->header_font->font_size.get());
	selector_label->setFontColor(config->header_font->font_color.get());
	header->addChild(selector_label);

	auto spacer = WidgetHBox::create();
	spacer->setBackground(1);
	spacer->setBackgroundTexture(config->spacer_background.get());
	spacer->setHeight(config->spacer_height);
	spacer->setWidth(width - 2);

	// create samples scrollbox
	int space = config->space_between_buttons;
	selector_scroll = WidgetScrollBox::create(0, space);
	selector_scroll->setBorder(0);
	padding = config->list_padding.get();
	selector_scroll->setPadding(padding.x, padding.y, padding.z, padding.w);
	selector_scroll->setHScrollEnabled(false);
	selector_scroll->setVScrollHidden(WidgetScrollBox::SCROLL_RENDER_MODE::ALWAYS_HIDE_NO_BOUNDS);
	selector_scroll->arrange();

	selector_vbox->addChild(header);
	selector_vbox->addChild(spacer);
	selector_vbox->addChild(selector_scroll, Gui::ALIGN_EXPAND);

	selector_hbox->addChild(selector_vbox);

	if (category)
	{
		for (auto &s : category->samples)
		{
			WorldButton *button = new WorldButton(s.title, s.world_name, config->button.get(),
				s.world_name == current_sample.world_name);
			select_buttons.append(button);
			selector_scroll->addChild(button->getWidget());
		}
	}
	else
	{
		WorldButton *button = new WorldButton(current_sample.title, current_sample.world_name,
			config->button.get(), true);
		select_buttons.append(button);
		selector_scroll->addChild(button->getWidget());
	}
}

void WorldMenu::update_navigation(bool up, bool down)
{
	nav_prev->update(up, down);
	nav_next->update(up, down);

	for (auto &b : select_buttons)
		b->update(up, down);

	nav_select->update(up, down);

	if (!selector_hbox->isHidden())
	{
		update_selector();
	}
}

void WorldMenu::update_selector()
{
	bool hovered = is_hovered(selector_vbox);
	if (hovered && !is_selector_hovered)
	{
		mouse_handle_at_click = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
		is_selector_hovered = hovered;
	}
	if (!hovered && is_selector_hovered)
	{
		Input::setMouseHandle(mouse_handle_at_click);
		is_selector_hovered = hovered;
	}

	if (is_hovered(selector_scroll))
	{
		int wheel = Input::getMouseWheel();
		if (wheel)
		{
			int value = selector_scroll->getVScrollValue();
			int step = selector_scroll->getVScrollStepSize();
			selector_scroll->setVScrollValue(value - wheel * step * 4);
		}
	}
	else
		selector_scroll->removeFocus();
}

void WorldMenu::update_back_button(bool up, bool down)
{
	bool hovered = is_hovered(back_hbox);

	if (pressed && up)
	{
		pressed = false;
		Input::setMouseHandle(mouse_handle_at_click);
		if (hovered)
		{
			World::loadWorld(ui_configuration->main_menu_world_name.get(), true);
			is_selection_active = false;
		}
	}

	if (!pressed && down && hovered)
	{
		pressed = true;
		// for samples with MOUSE_HANDLE_GRAB
		mouse_handle_at_click = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
	}

	if (back_prev_hovered != hovered)
	{
		back_hbox->setBackgroundTexture(hovered ? ui_configuration->back->background_hover.get()
												: ui_configuration->back->background.get());
		back_prev_hovered = hovered;
	}
	if (back_prev_pressed != pressed)
	{
		back_hbox->setBackgroundColor(pressed ? ui_configuration->back->button_tint_color
											  : ui_configuration->back->background_color);
		back_prev_pressed = pressed;
	}
}

bool WorldMenu::is_hovered(const Unigine::WidgetPtr &widget)
{
	bool hovered = widget->getMouseX() >= 0 && widget->getMouseX() < widget->getWidth()
		&& widget->getMouseY() >= 0 && widget->getMouseY() < widget->getHeight();
	return hovered;
}


bool WorldMenu::Button::isHovered() const
{
	if (!button_hbox)
		return false;

	bool is_hovered = button_hbox->getMouseX() > 0
		&& button_hbox->getMouseX() < button_hbox->getWidth() && button_hbox->getMouseY() > 0
		&& button_hbox->getMouseY() < button_hbox->getHeight();
	return is_hovered;
}

WorldMenu::NavigationButton::NavigationButton(const Unigine::String &world_path,
	const Unigine::String &title, UINavigationButton &ui, UITooltip &tooltip)
	: world_path(world_path)
{
	button_hbox = WidgetHBox::create(0, 0);
	button_hbox->setWidth(ui.button_width);
	button_hbox->setHeight(ui.button_height);
	button_hbox->setBackground(1);
	button_hbox->setBackgroundTexture(ui.background.get());
	button_hbox->setBackground9Sliced(true);
	vec4 nav_offsets = ui.background_slice_offsets.get();
	button_hbox->setBackground9SliceOffsets(nav_offsets.x, nav_offsets.y, nav_offsets.z,
		nav_offsets.w);
	button_hbox->setBackground9SliceScale(ui.background_slice_scale.get());

	auto sprite = WidgetSprite::create();
	sprite->addLayer();
	sprite->setLayerTexture(0, ui.icon->icon.get());
	sprite->setWidth(ui.icon->icon_size.get().x);
	sprite->setHeight(ui.icon->icon_size.get().y);
	button_hbox->addChild(sprite, Gui::ALIGN_CENTER);
	button_hbox->arrange();

	background = ui.background.get();
	background_hover = ui.background_hover.get();

	background_color = ui.background_color.get();
	background_tint_color = ui.background_tint_color.get();

	tooltip_hbox = WidgetHBox::create(0, 0);
	tooltip_hbox->setBackground(1);
	tooltip_hbox->setBackgroundTexture(tooltip.background.get());
	tooltip_hbox->setBackgroundColor(tooltip.background_color.get());
	tooltip_hbox->setHeight(tooltip.height);
	ivec4 padding = tooltip.padding.get();
	tooltip_hbox->setPadding(padding.x, padding.y, padding.z, padding.w);

	String text = ui.tooltip_text.get() + title;
	auto label = WidgetLabel::create(text);
	label->setFont(tooltip.font->font.get());
	label->setFontSize(tooltip.font->font_size.get());
	label->setFontColor(tooltip.font->font_color.get());
	label->setTextAlign(Gui::ALIGN_CENTER);

	tooltip_hbox->addChild(label);
	tooltip_hbox->setHidden(true);
	tooltip_hbox->setOrder(125);

	Gui::getCurrent()->addChild(tooltip_hbox, Gui::ALIGN_OVERLAP);

	time_delay = tooltip.time_delay < 0.f ? 0.1f : tooltip.time_delay;
	pos = tooltip.pos.get();
}

void WorldMenu::NavigationButton::update(bool up, bool down)
{
	if (!button_hbox)
		return;

	bool hovered = isHovered();

	// update tooltip time
	if (prev_hovered && hovered && !(prev_pressed || pressed))
		current_time += Game::getIFps();
	else
		current_time = 0.f;

	// update tooltip state
	if (current_time >= time_delay && tooltip_hbox->isHidden())
	{
		ivec2 mouse_pos = Input::getMousePosition() - Gui::getCurrent()->getPosition();
		tooltip_hbox->setHidden(false);
		tooltip_hbox->setPositionX(mouse_pos.x + pos.x);
		tooltip_hbox->setPositionY(mouse_pos.y - tooltip_hbox->getHeight() + pos.y);
	}

	if (current_time < time_delay && !tooltip_hbox->isHidden())
	{
		tooltip_hbox->setHidden(true);
	}

	// update button state
	if (pressed && up)
	{
		pressed = false;
		Input::setMouseHandle(mouse_handle_at_click);
		if (hovered)
			World::loadWorld(world_path, true);
	}

	if (!pressed && down && hovered)
	{
		pressed = true;
		// for samples with MOUSE_HANDLE_GRAB
		mouse_handle_at_click = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
	}

	if (prev_hovered != hovered)
	{
		button_hbox->setBackgroundTexture(hovered ? background_hover : background);
		prev_hovered = hovered;
	}
	if (prev_pressed != pressed)
	{
		button_hbox->setBackgroundColor(pressed ? background_tint_color : background_color);
		prev_pressed = pressed;
	}
}

WorldMenu::WorldButton::WorldButton(const Unigine::String &text, const Unigine::String &world_path,
	UIWorldButton &config, bool is_current)
	: world_path(world_path)
{
	background_color = is_current ? config.background_selected_color.get()
								  : config.background_color.get();
	background_tint_color = config.background_tint_color.get();
	background_selected_color = config.background_selected_color.get();

	button_hbox = WidgetHBox::create();
	button_hbox->setHeight(config.button_height);
	button_hbox->setWidth(config.button_width);
	button_hbox->setBackground(1);
	button_hbox->setBackgroundTexture(config.background.get());
	button_hbox->setBackgroundColor(background_color);

	auto label = WidgetLabel::create(text);
	label->setFont(config.font->font.get());
	label->setFontSize(config.font->font_size.get());
	label->setFontColor(config.font->font_color.get());
	button_hbox->addChild(label, Gui::ALIGN_CENTER);
	button_hbox->arrange();
}

void WorldMenu::WorldButton::update(bool up, bool down)
{
	if (!button_hbox)
		return;

	bool hovered = isHovered();

	if (pressed && up)
	{
		pressed = false;
		Input::setMouseHandle(mouse_handle_at_click);
		if (hovered)
		{
			World::loadWorld(world_path, true);
		}
	}

	if (!pressed && down && hovered)
	{
		pressed = true;
		// for samples with MOUSE_HANDLE_GRAB
		mouse_handle_at_click = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
	}

	if (prev_hovered != hovered)
	{
		button_hbox->setBackgroundColor(hovered ? background_tint_color : background_color);
		prev_hovered = hovered;
	}
	if (prev_pressed != pressed)
	{
		button_hbox->setBackgroundColor(pressed ? background_selected_color : background_color);
		prev_pressed = pressed;
	}
}

WorldMenu::SelectorButton::SelectorButton(const String &sample_name, UINavigationPanel &config,
	std::function<void(bool)> on_clicked)
	: on_clicked(on_clicked)
{
	button_hbox = WidgetHBox::create(0, 0);
	button_hbox->setBackground(1);
	button_hbox->setBackgroundTexture(config.background.get());
	button_hbox->setBackground9Sliced(false);
	button_hbox->setWidth(config.width);
	button_hbox->setHeight(config.height);

	auto sprite = WidgetSprite::create();
	sprite->addLayer();
	sprite->setLayerTexture(0, config.icon->icon.get());
	sprite->setWidth(config.icon->icon_size.get().x);
	sprite->setHeight(config.icon->icon_size.get().y);

	auto label = WidgetLabel::create(sample_name);
	label->setFont(config.label->font.get());
	label->setFontSize(config.label->font_size.get());
	label->setFontColor(config.label->font_color.get());

	auto aux_hbox = WidgetHBox::create(config.space_between_icon_and_label, 0);
	aux_hbox->addChild(sprite, Gui::ALIGN_LEFT);
	aux_hbox->addChild(label, Gui::ALIGN_LEFT);
	button_hbox->addChild(aux_hbox, Gui::ALIGN_CENTER);

	background = config.background.get();
	background_hover = config.background_hover.get();

	background_color = config.background_color.get();
	background_tint_color = config.background_tint_color.get();
}

void WorldMenu::SelectorButton::update(bool up, bool down)
{
	if (!button_hbox)
		return;

	bool hovered = isHovered();

	if (pressed && up)
	{
		pressed = false;
		Input::setMouseHandle(mouse_handle_at_click);
		if (hovered)
		{
			enabled = !enabled;
			on_clicked(enabled);
			is_selection_active = enabled;
		}
	}

	if (!pressed && down && hovered)
	{
		pressed = true;
		mouse_handle_at_click = Input::getMouseHandle();
		Input::setMouseHandle(Input::MOUSE_HANDLE_USER);
	}

	if (prev_hovered != hovered && !enabled)
	{
		button_hbox->setBackgroundTexture(hovered ? background_hover : background);
		prev_hovered = hovered;
	}
	if (prev_pressed != pressed && !enabled)
	{
		button_hbox->setBackgroundColor(pressed ? background_tint_color : background_color);
		prev_pressed = pressed;
	}
}

void WorldMenu::SelectorButton::setButtonPressed(bool is_pressed)
{
	button_hbox->setBackgroundTexture(is_pressed ? background_hover : background);
	button_hbox->setBackgroundColor(is_pressed ? background_tint_color : background_color);
	enabled = is_pressed;
	is_selection_active = enabled;
	pressed = false;
	prev_pressed = true;

	on_clicked(enabled);
}

```

## WorldSplineGraphSample.cpp

```cpp
#include <UnigineComponentSystem.h>
#include <UnigineVisualizer.h>
#include <UnigineWorlds.h>

#include "../../menu_ui/SampleDescriptionWindow.h"
#include "../../utils/Utils.h"

using namespace Unigine;
using namespace Math;

class WorldSplineGraphSample : public ComponentBase
{
public:
	COMPONENT_DEFINE(WorldSplineGraphSample, ComponentBase);
	COMPONENT_INIT(init);
	COMPONENT_SHUTDOWN(shutdown);

	PROP_PARAM(File, spline_file);
	PROP_PARAM(File, segment_node);

private:
	void init()
	{
		Unigine::String spline_path = spline_file.get();
		if (spline_path.size() <= 0)
		{
			Unigine::Log::error("WorldSplineGraphSample::init(): Spline File param is empty!\n");
			return;
		}
		
		Unigine::String node_path = segment_node.get();
		if (node_path.size() <= 0)
		{
			Unigine::Log::error("WorldSplineGraphSample::init(): Segment File param is empty!\n");
			return;
		}
		
		world_spline_graph = WorldSplineGraph::create();

		// load the .spl spline file
		world_spline_graph->load(spline_path);

		Vector<SplineSegmentPtr> segments;
		world_spline_graph->getSplineSegments(segments);

		// for each spline segment in the graph assign to it a source node "road.node" and set its mode to "TILING"
		for (int i = 0; i < segments.size(); i += 1)
		{
			SplineSegmentPtr &segment = segments[i];
			segment->assignSource(node_path, SplineSegment::FORWARD_X);
			segment->setSegmentMode(node_path, SplineSegment::SEGMENT_TILING);
		}

		// rebuild the graph after changing the segments' parameters
		world_spline_graph->rebuild();

		visualizer_enabled = Visualizer::isEnabled();
		Visualizer::setEnabled(true);
	}

	void shutdown()
	{
		Visualizer::setEnabled(visualizer_enabled);
	}

	// ========================================================================================

	bool visualizer_enabled = false;
	WorldSplineGraphPtr world_spline_graph;
};

REGISTER_COMPONENT(WorldSplineGraphSample);

```

## XmlSample.cpp

```cpp
#include "XmlSample.h"

#include <UnigineConsole.h>

using namespace Unigine;
using namespace Math;

XmlPtr XmlSample::xml_create()
{
	XmlPtr xml = Xml::create("node");
	XmlPtr xml_0 = XmlPtr(xml->addChild("child", "arg=\"0\""));
	XmlPtr xml_1 = XmlPtr(xml_0->addChild("child", "arg=\"1\""));
	XmlPtr xml_2 = XmlPtr(xml_1->addChild("child", "arg=\"2\""));
	xml_2->setData("some data");
	xml->setAPIInterfaceOwner(false);
	return xml;
}

void XmlSample::xml_print(Unigine::XmlPtr xml, int offset)
{
	for (int i = 0; i < offset; i++)
	{
		Log::message(" ");
	}

	Log::message("%s: ", xml->getName());
	for (int i = 0; i < xml->getNumArgs(); ++i)
	{
		Log::message("%s=%s ", xml->getArgName(i), xml->getArgValue(i));
	}
	Log::message(": %s\n", xml->getData());


	for (int i = 0; i < xml->getNumChildren(); i++)
	{
		xml_print(XmlPtr(xml->getChild(i)), offset + 1);
	}
}


//------------------------Sample Logic-----------------------

REGISTER_COMPONENT(XmlSample)

void XmlSample::init()
{
	Console::setOnscreen(true);

	{
		Log::message("\n");
		// create the XML tree
		XmlPtr xml = xml_create();

		// print xml tree
		xml_print(xml, 0);
	}
}

void XmlSample::shutdown()
{
	Console::setOnscreen(false);
}

```

## ZoomController.cpp

```cpp
#include "ZoomController.h"

#include "UnigineConsole.h"
#include "UnigineGame.h"

using namespace Unigine;
using namespace Math;

REGISTER_COMPONENT(ZoomController);

void ZoomController::init()
{
	player = checked_ptr_cast<Player>(node);
	if (!player)
	{
		Log::error("ZoomSample::init cannot cast node to player!\n");
	}

	default_FOV = player->getFov();
	default_distance_scale = Render::getDistanceScale();
	default_sensivity = ControlsApp::getMouseSensitivity();

	if (node->getType() == Node::PLAYER_SPECTATOR)
	{
		PlayerSpectatorPtr player_spectator = checked_ptr_cast<PlayerSpectator>(node);
		default_player_turning = player_spectator->getTurning();
	}
	if (node->getType() == Node::PLAYER_ACTOR)
	{
		PlayerActorPtr player_spectator = checked_ptr_cast<PlayerActor>(node);
		default_player_turning = player_spectator->getTurning();
	}
}

void ZoomController::shutdown()
{
	//so settings won't be affected between sessions
	Render::setDistanceScale(default_distance_scale);
	ControlsApp::setMouseSensitivity(default_sensivity);
}

void ZoomController::focus_on_target(NodePtr target)
{
	vec3 dir = vec3(target->getWorldPosition() - node->getWorldPosition());
	dir.normalize();
	player->setViewDirection(dir);
}

void ZoomController::udpate_zoom_factor(float zoom_factor)
{
	player->setFov(default_FOV / zoom_factor);
	Render::setDistanceScale(default_distance_scale * zoom_factor);
	ControlsApp::setMouseSensitivity(default_sensivity / zoom_factor);

	if (node->getType() == Node::PLAYER_SPECTATOR|| node->getType() == Node::PLAYER_ACTOR)
	{
		update_turning(zoom_factor);
	}
}

void ZoomController::update_turning(float zoom_factor)
{
	//Turning determines speed at which the Player is rotated. It should be lowered and heightened depending on zoom factor
	// ZoomController has been made for the base Player class so it could work with any Player derived class But not every Player has a Turning property
	// Because of that we should regulate Turning depeping on player node type.
	//There is no work around this situation and since changing behavior depending on class type is bad practice this functionality has been hidden from public interface

	if (node->getType() == Node::PLAYER_SPECTATOR)
	{
		PlayerSpectatorPtr player_spectator = checked_ptr_cast<PlayerSpectator>(node);
		player_spectator->setTurning(default_player_turning / zoom_factor);
	}
	if (node->getType() == Node::PLAYER_ACTOR)
	{
		PlayerActorPtr player_actor = checked_ptr_cast<PlayerActor>(node);
		player_actor->setTurning(default_player_turning / zoom_factor);
	}
}

void ZoomController::reset()
{
	udpate_zoom_factor(1);
}

```

## ZoomSample.cpp

```cpp
#include "ZoomSample.h"

#include "ZoomController.h"


REGISTER_COMPONENT(ZoomSample);

using namespace Unigine;
using namespace Math;

void ZoomSample::init()
{
	init_components();
	mouse_grab = Input::getMouseHandle();
	Input::setMouseHandle(Input::MOUSE_HANDLE_GRAB);

	window_sample.createWindow();

	auto slider = window_sample.addFloatParameter("Zoom", "Zoom", 1.0f, 1.0f, 100.f, [this](float f) {
		zoom->udpate_zoom_factor(f);
		fov_label->setText("FOV:" + String::ftoa(player->getFov(), 2) + " deg");
		mouse_sensivity_label->setText("Mouse sensivity : " + String::ftoa(ControlsApp::getMouseSensitivity(), 3));
		render_scale_label->setText("Render distance scale: " + String::ftoa(Render::getDistanceScale(), 2));
		});

	WidgetGroupBoxPtr parameters = window_sample.getParameterGroupBox();


	fov_label = WidgetLabel::create("FOV:" + String::ftoa(player->getFov()) + " deg");
	parameters->addChild(fov_label, Gui::ALIGN_LEFT | Gui::ALIGN_EXPAND);

	mouse_sensivity_label = WidgetLabel::create("Mouse sensivity : " + String::ftoa(ControlsApp::getMouseSensitivity(), 2));
	parameters->addChild(mouse_sensivity_label, Gui::ALIGN_LEFT | Gui::ALIGN_EXPAND);

	render_scale_label = WidgetLabel::create("Render distance scale: " + String::ftoa(Render::getDistanceScale(), 2));
	parameters->addChild(render_scale_label, Gui::ALIGN_LEFT | Gui::ALIGN_EXPAND);


	WidgetButtonPtr reset_button = WidgetButton::create("Reset");
	parameters->addChild(reset_button, Gui::ALIGN_LEFT);
	reset_button->getEventClicked().connect(*this, [this, slider](const Ptr<Widget>&, int) {
		slider->setValue(1);
		});


	WidgetHBoxPtr hbox = WidgetHBox::create();
	parameters->addChild(hbox, Gui::ALIGN_LEFT);
	WidgetLabelPtr focus_label = WidgetLabel::create("Focus on:");
	hbox->addChild(focus_label);

	hbox->setSpace(2, 1);
	WidgetButtonPtr target_one = WidgetButton::create("Target 1");
	target_one->getEventClicked().connect(*this, [this](const Ptr<Widget>&, int) {
		zoom->focus_on_target(target_one_node);
		});
	hbox->addChild(target_one);

	WidgetButtonPtr target_two = WidgetButton::create("Target 2");
	target_two->getEventClicked().connect(*this, [this](const Ptr<Widget>&, int) {
		zoom->focus_on_target(target_two_node);
		});
	hbox->addChild(target_two);


	WidgetButtonPtr target_three = WidgetButton::create("Target 3");
	target_three->getEventClicked().connect(*this, [this](const Ptr<Widget>&, int) {
		zoom->focus_on_target(target_three_node);
		});
	hbox->addChild(target_three);
}

void ZoomSample::shutdown()
{
	window_sample.shutdown();
	Input::setMouseHandle(mouse_grab);

}

void ZoomSample::init_components()
{
	zoom = getComponent<ZoomController>(zoom_node);

	if (!zoom)
	{
		Log::error("ZoomInfo::init::init_components cannot find zoom_sample node!\n");
	}

	player = checked_ptr_cast<Player>(zoom_node.get());

	if (!player)
	{
		Log::error("ZoomSample::init::init_components cannot cast node to player!\n");
	}
	if (!target_one_node||!target_two_node||!target_three_node)
	{
		Log::error("ZoomSample::init::init_components targets are not assigned!\n");
	}
}
```

## main.cpp

```cpp
#include <UnigineInit.h>
#include <UnigineEngine.h>

#include "AppSystemLogic.h"
#include "AppWorldLogic.h"
#include "utils/UnigineScriptsInterpreter.h"


#ifdef _WIN32
int wmain(int argc, wchar_t *argv[])
#else
int main(int argc, char *argv[])
#endif
{
	// init engine
	Unigine::EnginePtr engine(argc, argv);

	InterpreterRegistrator::get()->initialize();

	// UnigineLogic
	AppSystemLogic system_logic;
	AppWorldLogic world_logic;

	// enter main loop
	engine->main(&system_logic, &world_logic);

	return 0;
}

```

